var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {
      get: all[name2],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name2] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/@electric-sql/pglite/dist/chunk-BTBUZ646.js
var p, i2, c, f, l, s, a = (t) => {
  throw TypeError(t);
}, _ = (t, e, o) => (e in t) ? i2(t, e, { enumerable: true, configurable: true, writable: true, value: o }) : t[e] = o, d = (t, e) => () => (t && (e = t(t = 0)), e), D = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), F = (t, e) => {
  for (var o in e)
    i2(t, o, { get: e[o], enumerable: true });
}, g = (t, e, o, m) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let r of f(e))
      !s.call(t, r) && r !== o && i2(t, r, { get: () => e[r], enumerable: !(m = c(e, r)) || m.enumerable });
  return t;
}, L = (t, e, o) => (o = t != null ? p(l(t)) : {}, g(e || !t || !t.__esModule ? i2(o, "default", { value: t, enumerable: true }) : o, t)), P = (t, e, o) => _(t, typeof e != "symbol" ? e + "" : e, o), n = (t, e, o) => e.has(t) || a("Cannot " + o), h = (t, e, o) => (n(t, e, "read from private field"), o ? o.call(t) : e.get(t)), R = (t, e, o) => e.has(t) ? a("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, o), x = (t, e, o, m) => (n(t, e, "write to private field"), m ? m.call(t, o) : e.set(t, o), o), T = (t, e, o) => (n(t, e, "access private method"), o), U = (t, e, o, m) => ({ set _(r) {
  x(t, e, r, o);
}, get _() {
  return h(t, e, m);
} }), u;
var init_chunk_BTBUZ646 = __esm(() => {
  p = Object.create;
  i2 = Object.defineProperty;
  c = Object.getOwnPropertyDescriptor;
  f = Object.getOwnPropertyNames;
  l = Object.getPrototypeOf;
  s = Object.prototype.hasOwnProperty;
  u = d(() => {});
});

// node:util
var exports_util = {};
__export(exports_util, {
  types: () => types,
  promisify: () => promisify,
  log: () => log,
  isUndefined: () => isUndefined,
  isSymbol: () => isSymbol,
  isString: () => isString,
  isRegExp: () => isRegExp,
  isPrimitive: () => isPrimitive,
  isObject: () => isObject,
  isNumber: () => isNumber,
  isNullOrUndefined: () => isNullOrUndefined,
  isNull: () => isNull,
  isFunction: () => isFunction,
  isError: () => isError,
  isDate: () => isDate,
  isBuffer: () => isBuffer,
  isBoolean: () => isBoolean,
  isArray: () => isArray,
  inspect: () => inspect,
  inherits: () => inherits,
  format: () => format,
  deprecate: () => deprecate,
  debuglog: () => debuglog,
  callbackifyOnRejected: () => callbackifyOnRejected,
  callbackify: () => callbackify,
  _extend: () => _extend,
  TextEncoder: () => TextEncoder2,
  TextDecoder: () => TextDecoder2
});
function format(f2, ...args2) {
  if (!isString(f2)) {
    var objects = [f2];
    for (var i3 = 0;i3 < args2.length; i3++)
      objects.push(inspect(args2[i3]));
    return objects.join(" ");
  }
  var i3 = 0, len = args2.length, str = String(f2).replace(formatRegExp, function(x22) {
    if (x22 === "%%")
      return "%";
    if (i3 >= len)
      return x22;
    switch (x22) {
      case "%s":
        return String(args2[i3++]);
      case "%d":
        return Number(args2[i3++]);
      case "%j":
        try {
          return JSON.stringify(args2[i3++]);
        } catch (_3) {
          return "[Circular]";
        }
      default:
        return x22;
    }
  });
  for (var x3 = args2[i3];i3 < len; x3 = args2[++i3])
    if (isNull(x3) || !isObject(x3))
      str += " " + x3;
    else
      str += " " + inspect(x3);
  return str;
}
function deprecate(fn2, msg) {
  if (typeof process === "undefined" || process?.noDeprecation === true)
    return fn2;
  var warned = false;
  function deprecated(...args2) {
    if (!warned) {
      if (process.throwDeprecation)
        throw new Error(msg);
      else if (process.traceDeprecation)
        console.trace(msg);
      else
        console.error(msg);
      warned = true;
    }
    return fn2.apply(this, ...args2);
  }
  return deprecated;
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style)
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  else
    return str;
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  return array.forEach(function(val, idx) {
    hash[val] = true;
  }), hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret))
      ret = formatValue(ctx, ret, recurseTimes);
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive)
    return primitive;
  var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
  if (ctx.showHidden)
    keys = Object.getOwnPropertyNames(value);
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
    return formatError(value);
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name2 = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name2 + "]", "special");
    }
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    if (isDate(value))
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    if (isError(value))
      return formatError(value);
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value))
    array = true, braces = ["[", "]"];
  if (isFunction(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base = " [Function" + n2 + "]";
  }
  if (isRegExp(value))
    base = " " + RegExp.prototype.toString.call(value);
  if (isDate(value))
    base = " " + Date.prototype.toUTCString.call(value);
  if (isError(value))
    base = " " + formatError(value);
  if (keys.length === 0 && (!array || value.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    else
      return ctx.stylize("[Object]", "special");
  ctx.seen.push(value);
  var output;
  if (array)
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  else
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  return ctx.seen.pop(), reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i3 = 0, l4 = value.length;i3 < l4; ++i3)
    if (hasOwnProperty(value, String(i3)))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i3), true));
    else
      output.push("");
  return keys.forEach(function(key) {
    if (!key.match(/^\d+$/))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
  }), output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name2, str, desc;
  if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get)
    if (desc.set)
      str = ctx.stylize("[Getter/Setter]", "special");
    else
      str = ctx.stylize("[Getter]", "special");
  else if (desc.set)
    str = ctx.stylize("[Setter]", "special");
  if (!hasOwnProperty(visibleKeys, key))
    name2 = "[" + key + "]";
  if (!str)
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes))
        str = formatValue(ctx, desc.value, null);
      else
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      if (str.indexOf(`
`) > -1)
        if (array)
          str = str.split(`
`).map(function(line) {
            return "  " + line;
          }).join(`
`).slice(2);
        else
          str = `
` + str.split(`
`).map(function(line) {
            return "   " + line;
          }).join(`
`);
    } else
      str = ctx.stylize("[Circular]", "special");
  if (isUndefined(name2)) {
    if (array && key.match(/^\d+$/))
      return str;
    if (name2 = JSON.stringify("" + key), name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
      name2 = name2.slice(1, -1), name2 = ctx.stylize(name2, "name");
    else
      name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name2 = ctx.stylize(name2, "string");
  }
  return name2 + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0, length = output.reduce(function(prev, cur) {
    if (numLinesEst++, cur.indexOf(`
`) >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60)
    return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === undefined;
}
function isRegExp(re2) {
  return isObject(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d3) {
  return isObject(d3) && objectToString(d3) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer(arg) {
  return arg instanceof Buffer;
}
function objectToString(o3) {
  return Object.prototype.toString.call(o3);
}
function pad(n2) {
  return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
}
function timestamp() {
  var d3 = new Date, time = [pad(d3.getHours()), pad(d3.getMinutes()), pad(d3.getSeconds())].join(":");
  return [d3.getDate(), months[d3.getMonth()], time].join(" ");
}
function log(...args2) {
  console.log("%s - %s", timestamp(), format.apply(null, args2));
}
function inherits(ctor, superCtor) {
  if (superCtor)
    ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys = Object.keys(add), i3 = keys.length;
  while (i3--)
    origin[keys[i3]] = add[keys[i3]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason, reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  function callbackified(...args2) {
    var maybeCb = args2.pop();
    if (typeof maybeCb !== "function")
      throw new TypeError("The last argument must be of type Function");
    var self2 = this, cb = function(...args22) {
      return maybeCb.apply(self2, ...args22);
    };
    original.apply(this, args2).then(function(ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function(rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, Object.getOwnPropertyDescriptors(original)), callbackified;
}
var formatRegExp, debuglog, inspect, types = () => {}, months, promisify, TextEncoder2, TextDecoder2;
var init_util = __esm(() => {
  formatRegExp = /%[sdj%]/g;
  debuglog = ((debugs = {}, debugEnvRegex = {}, debugEnv) => ((debugEnv = typeof process !== "undefined" && process.env.NODE_DEBUG) && (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i"), (set) => {
    if (set = set.toUpperCase(), !debugs[set])
      if (debugEnvRegex.test(set))
        debugs[set] = function(...args2) {
          console.error("%s: %s", set, pid, format.apply(null, ...args2));
        };
      else
        debugs[set] = function() {};
    return debugs[set];
  }))();
  inspect = ((i3) => (i3.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, i3.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i3.custom = Symbol.for("nodejs.util.inspect.custom"), i3))(function inspect2(obj, opts, ...rest) {
    var ctx = { seen: [], stylize: stylizeNoColor };
    if (rest.length >= 1)
      ctx.depth = rest[0];
    if (rest.length >= 2)
      ctx.colors = rest[1];
    if (isBoolean(opts))
      ctx.showHidden = opts;
    else if (opts)
      _extend(ctx, opts);
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  });
  months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  promisify = ((x3) => (x3.custom = Symbol.for("nodejs.util.promisify.custom"), x3))(function promisify2(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn2 = original[kCustomPromisifiedSymbol];
      if (typeof fn2 !== "function")
        throw new TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true }), fn2;
    }
    function fn2(...args2) {
      var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {
        promiseResolve = resolve, promiseReject = reject;
      });
      args2.push(function(err2, value) {
        if (err2)
          promiseReject(err2);
        else
          promiseResolve(value);
      });
      try {
        original.apply(this, args2);
      } catch (err2) {
        promiseReject(err2);
      }
      return promise;
    }
    if (Object.setPrototypeOf(fn2, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)
      Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(fn2, Object.getOwnPropertyDescriptors(original));
  });
  ({ TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = globalThis);
});

// node:assert
var exports_assert = {};
__export(exports_assert, {
  throws: () => throws,
  strictEqual: () => strictEqual,
  strict: () => strict,
  rejects: () => rejects,
  ok: () => ok,
  notStrictEqual: () => notStrictEqual,
  notEqual: () => notEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notDeepEqual: () => notDeepEqual,
  match: () => match,
  ifError: () => ifError,
  fail: () => fail,
  equal: () => equal,
  doesNotThrow: () => doesNotThrow,
  doesNotReject: () => doesNotReject,
  doesNotMatch: () => doesNotMatch,
  default: () => assert_default,
  deepStrictEqual: () => deepStrictEqual,
  deepEqual: () => deepEqual,
  CallTracker: () => CallTracker,
  AssertionError: () => AssertionError
});
var __create2, __getProtoOf2, __defProp2, __getOwnPropNames2, __hasOwnProp2, __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_shams, require_shams2, require_es_object_atoms, require_es_errors, require_eval, require_range, require_ref, require_syntax, require_type, require_uri, require_abs, require_floor, require_max, require_min, require_pow, require_round, require_isNaN, require_sign, require_gOPD, require_gopd, require_es_define_property, require_has_symbols, require_Reflect_getPrototypeOf, require_Object_getPrototypeOf, require_implementation, require_function_bind, require_functionCall, require_functionApply, require_reflectApply, require_actualApply, require_call_bind_apply_helpers, require_get, require_get_proto, require_hasown, require_get_intrinsic, require_call_bound, require_is_arguments, require_is_regex, require_safe_regex_test, require_is_generator_function, require_is_callable, require_for_each, require_possible_typed_array_names, require_available_typed_arrays, require_define_data_property, require_has_property_descriptors, require_set_function_length, require_applyBind, require_call_bind, require_which_typed_array, require_is_typed_array, require_types, require_isBuffer, require_inherits_browser, require_inherits, require_util, require_errors, require_assertion_error, require_isArguments, require_implementation2, require_object_keys, require_implementation3, require_polyfill, require_implementation4, require_polyfill2, require_callBound, require_define_properties, require_shim, require_object_is, require_implementation5, require_polyfill3, require_shim2, require_is_nan, require_comparisons, require_assert, assert2, AssertionError, CallTracker, deepEqual, deepStrictEqual, doesNotMatch, doesNotReject, doesNotThrow, equal, fail, ifError, match, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws, assert_default;
var init_assert = __esm(() => {
  __create2 = Object.create;
  ({ getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object);
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  require_shams = __commonJS2((exports, module2) => {
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function")
        return false;
      if (typeof Symbol.iterator === "symbol")
        return true;
      var obj = {}, sym = Symbol("test"), symObj = Object(sym);
      if (typeof sym === "string")
        return false;
      if (Object.prototype.toString.call(sym) !== "[object Symbol]")
        return false;
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]")
        return false;
      var symVal = 42;
      obj[sym] = symVal;
      for (var _3 in obj)
        return false;
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0)
        return false;
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0)
        return false;
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym))
        return false;
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  require_shams2 = __commonJS2((exports, module2) => {
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  });
  require_es_object_atoms = __commonJS2((exports, module2) => {
    module2.exports = Object;
  });
  require_es_errors = __commonJS2((exports, module2) => {
    module2.exports = Error;
  });
  require_eval = __commonJS2((exports, module2) => {
    module2.exports = EvalError;
  });
  require_range = __commonJS2((exports, module2) => {
    module2.exports = RangeError;
  });
  require_ref = __commonJS2((exports, module2) => {
    module2.exports = ReferenceError;
  });
  require_syntax = __commonJS2((exports, module2) => {
    module2.exports = SyntaxError;
  });
  require_type = __commonJS2((exports, module2) => {
    module2.exports = TypeError;
  });
  require_uri = __commonJS2((exports, module2) => {
    module2.exports = URIError;
  });
  require_abs = __commonJS2((exports, module2) => {
    module2.exports = Math.abs;
  });
  require_floor = __commonJS2((exports, module2) => {
    module2.exports = Math.floor;
  });
  require_max = __commonJS2((exports, module2) => {
    module2.exports = Math.max;
  });
  require_min = __commonJS2((exports, module2) => {
    module2.exports = Math.min;
  });
  require_pow = __commonJS2((exports, module2) => {
    module2.exports = Math.pow;
  });
  require_round = __commonJS2((exports, module2) => {
    module2.exports = Math.round;
  });
  require_isNaN = __commonJS2((exports, module2) => {
    module2.exports = Number.isNaN || function isNaN(a2) {
      return a2 !== a2;
    };
  });
  require_sign = __commonJS2((exports, module2) => {
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0)
        return number;
      return number < 0 ? -1 : 1;
    };
  });
  require_gOPD = __commonJS2((exports, module2) => {
    module2.exports = Object.getOwnPropertyDescriptor;
  });
  require_gopd = __commonJS2((exports, module2) => {
    var $gOPD = require_gOPD();
    if ($gOPD)
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    module2.exports = $gOPD;
  });
  require_es_define_property = __commonJS2((exports, module2) => {
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty)
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    module2.exports = $defineProperty;
  });
  require_has_symbols = __commonJS2((exports, module2) => {
    var origSymbol = typeof Symbol !== "undefined" && Symbol, hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function")
        return false;
      if (typeof Symbol !== "function")
        return false;
      if (typeof origSymbol("foo") !== "symbol")
        return false;
      if (typeof Symbol("bar") !== "symbol")
        return false;
      return hasSymbolSham();
    };
  });
  require_Reflect_getPrototypeOf = __commonJS2((exports, module2) => {
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  });
  require_Object_getPrototypeOf = __commonJS2((exports, module2) => {
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  });
  require_implementation = __commonJS2((exports, module2) => {
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function concatty(a2, b3) {
      var arr = [];
      for (var i3 = 0;i3 < a2.length; i3 += 1)
        arr[i3] = a2[i3];
      for (var j2 = 0;j2 < b3.length; j2 += 1)
        arr[j2 + a2.length] = b3[j2];
      return arr;
    }, slicy = function slicy(arrLike, offset) {
      var arr = [];
      for (var i3 = offset || 0, j2 = 0;i3 < arrLike.length; i3 += 1, j2 += 1)
        arr[j2] = arrLike[i3];
      return arr;
    }, joiny = function(arr, joiner) {
      var str = "";
      for (var i3 = 0;i3 < arr.length; i3 += 1)
        if (str += arr[i3], i3 + 1 < arr.length)
          str += joiner;
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType)
        throw new TypeError(ERROR_MESSAGE + target);
      var args2 = slicy(arguments, 1), bound, binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, concatty(args2, arguments));
          if (Object(result) === result)
            return result;
          return this;
        }
        return target.apply(that, concatty(args2, arguments));
      }, boundLength = max(0, target.length - args2.length), boundArgs = [];
      for (var i3 = 0;i3 < boundLength; i3++)
        boundArgs[i3] = "$" + i3;
      if (bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder), target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype, bound.prototype = new Empty, Empty.prototype = null;
      }
      return bound;
    };
  });
  require_function_bind = __commonJS2((exports, module2) => {
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  });
  require_functionCall = __commonJS2((exports, module2) => {
    module2.exports = Function.prototype.call;
  });
  require_functionApply = __commonJS2((exports, module2) => {
    module2.exports = Function.prototype.apply;
  });
  require_reflectApply = __commonJS2((exports, module2) => {
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  });
  require_actualApply = __commonJS2((exports, module2) => {
    var bind = require_function_bind(), $apply = require_functionApply(), $call = require_functionCall(), $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  });
  require_call_bind_apply_helpers = __commonJS2((exports, module2) => {
    var bind = require_function_bind(), $TypeError = require_type(), $call = require_functionCall(), $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args2) {
      if (args2.length < 1 || typeof args2[0] !== "function")
        throw new $TypeError("a function is required");
      return $actualApply(bind, $call, args2);
    };
  });
  require_get = __commonJS2((exports, module2) => {
    var callBind = require_call_bind_apply_helpers(), gOPD = require_gopd(), hasProtoAccessor;
    try {
      hasProtoAccessor = [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS")
        throw e;
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__"), $Object = Object, $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    } : false;
  });
  require_get_proto = __commonJS2((exports, module2) => {
    var reflectGetProto = require_Reflect_getPrototypeOf(), originalGetProto = require_Object_getPrototypeOf(), getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O2) {
      return reflectGetProto(O2);
    } : originalGetProto ? function getProto(O2) {
      if (!O2 || typeof O2 !== "object" && typeof O2 !== "function")
        throw new TypeError("getProto: not an object");
      return originalGetProto(O2);
    } : getDunderProto ? function getProto(O2) {
      return getDunderProto(O2);
    } : null;
  });
  require_hasown = __commonJS2((exports, module2) => {
    var call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  });
  require_get_intrinsic = __commonJS2((exports, module2) => {
    var undefined2, $Object = require_es_object_atoms(), $Error = require_es_errors(), $EvalError = require_eval(), $RangeError = require_range(), $ReferenceError = require_ref(), $SyntaxError = require_syntax(), $TypeError = require_type(), $URIError = require_uri(), abs = require_abs(), floor = require_floor(), max = require_max(), min = require_min(), pow = require_pow(), round = require_round(), sign = require_sign(), $Function = Function, getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {}
    }, $gOPD = require_gopd(), $defineProperty = require_es_define_property(), throwTypeError = function() {
      throw new $TypeError;
    }, ThrowTypeError = $gOPD ? function() {
      try {
        return arguments.callee, throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError, hasSymbols = require_has_symbols()(), getProto = require_get_proto(), $ObjectGPO = require_Object_getPrototypeOf(), $ReflectGPO = require_Reflect_getPrototypeOf(), $apply = require_functionApply(), $call = require_functionCall(), needsEval = {}, TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array), INTRINSICS = { __proto__: null, "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer, "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2, "%AsyncFromSyncIteratorPrototype%": undefined2, "%AsyncFunction%": needsEval, "%AsyncGenerator%": needsEval, "%AsyncGeneratorFunction%": needsEval, "%AsyncIteratorPrototype%": needsEval, "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics, "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt, "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": $Error, "%eval%": eval, "%EvalError%": $EvalError, "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array, "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array, "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry, "%Function%": $Function, "%GeneratorFunction%": needsEval, "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array, "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array, "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2, "%JSON%": typeof JSON === "object" ? JSON : undefined2, "%Map%": typeof Map === "undefined" ? undefined2 : Map, "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": $Object, "%Object.getOwnPropertyDescriptor%": $gOPD, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise, "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy, "%RangeError%": $RangeError, "%ReferenceError%": $ReferenceError, "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set === "undefined" ? undefined2 : Set, "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2, "%Symbol%": hasSymbols ? Symbol : undefined2, "%SyntaxError%": $SyntaxError, "%ThrowTypeError%": ThrowTypeError, "%TypedArray%": TypedArray, "%TypeError%": $TypeError, "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array, "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array, "%URIError%": $URIError, "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap, "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef, "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet, "%Function.prototype.call%": $call, "%Function.prototype.apply%": $apply, "%Object.defineProperty%": $defineProperty, "%Object.getPrototypeOf%": $ObjectGPO, "%Math.abs%": abs, "%Math.floor%": floor, "%Math.max%": max, "%Math.min%": min, "%Math.pow%": pow, "%Math.round%": round, "%Math.sign%": sign, "%Reflect.getPrototypeOf%": $ReflectGPO };
    if (getProto)
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e)), INTRINSICS["%Error.prototype%"] = errorProto;
      }
    var errorProto, doEval = function doEval(name2) {
      var value;
      if (name2 === "%AsyncFunction%")
        value = getEvalledConstructor("async function () {}");
      else if (name2 === "%GeneratorFunction%")
        value = getEvalledConstructor("function* () {}");
      else if (name2 === "%AsyncGeneratorFunction%")
        value = getEvalledConstructor("async function* () {}");
      else if (name2 === "%AsyncGenerator%") {
        var fn2 = doEval("%AsyncGeneratorFunction%");
        if (fn2)
          value = fn2.prototype;
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval("%AsyncGenerator%");
        if (gen && getProto)
          value = getProto(gen.prototype);
      }
      return INTRINSICS[name2] = value, value;
    }, LEGACY_ALIASES = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, bind = require_function_bind(), hasOwn = require_hasown(), $concat = bind.call($call, Array.prototype.concat), $spliceApply = bind.call($apply, Array.prototype.splice), $replace = bind.call($call, String.prototype.replace), $strSlice = bind.call($call, String.prototype.slice), $exec = bind.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function stringToPath(string) {
      var first = $strSlice(string, 0, 1), last = $strSlice(string, -1);
      if (first === "%" && last !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      else if (last === "%" && first !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      var result = [];
      return $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      }), result;
    }, getBaseIntrinsic = function getBaseIntrinsic(name2, allowMissing) {
      var intrinsicName = name2, alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName))
        alias = LEGACY_ALIASES[intrinsicName], intrinsicName = "%" + alias[0] + "%";
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval)
          value = doEval(intrinsicName);
        if (typeof value === "undefined" && !allowMissing)
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        return { alias, name: intrinsicName, value };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0)
        throw new $TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof allowMissing !== "boolean")
        throw new $TypeError('"allowMissing" argument must be a boolean');
      if ($exec(/^%?[^%]*%?$/, name2) === null)
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var parts2 = stringToPath(name2), intrinsicBaseName = parts2.length > 0 ? parts2[0] : "", intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing), intrinsicRealName = intrinsic.name, value = intrinsic.value, skipFurtherCaching = false, alias = intrinsic.alias;
      if (alias)
        intrinsicBaseName = alias[0], $spliceApply(parts2, $concat([0, 1], alias));
      for (var i3 = 1, isOwn = true;i3 < parts2.length; i3 += 1) {
        var part = parts2[i3], first = $strSlice(part, 0, 1), last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last)
          throw new $SyntaxError("property names with quotes must have matching quotes");
        if (part === "constructor" || !isOwn)
          skipFurtherCaching = true;
        if (intrinsicBaseName += "." + part, intrinsicRealName = "%" + intrinsicBaseName + "%", hasOwn(INTRINSICS, intrinsicRealName))
          value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing)
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            return;
          }
          if ($gOPD && i3 + 1 >= parts2.length) {
            var desc = $gOPD(value, part);
            if (isOwn = !!desc, isOwn && "get" in desc && !("originalValue" in desc.get))
              value = desc.get;
            else
              value = value[part];
          } else
            isOwn = hasOwn(value, part), value = value[part];
          if (isOwn && !skipFurtherCaching)
            INTRINSICS[intrinsicRealName] = value;
        }
      }
      return value;
    };
  });
  require_call_bound = __commonJS2((exports, module2) => {
    var GetIntrinsic = require_get_intrinsic(), callBindBasic = require_call_bind_apply_helpers(), $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1)
        return callBindBasic([intrinsic]);
      return intrinsic;
    };
  });
  require_is_arguments = __commonJS2((exports, module2) => {
    var hasToStringTag = require_shams2()(), callBound = require_call_bound(), $toString = callBound("Object.prototype.toString"), isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value)
        return false;
      return $toString(value) === "[object Arguments]";
    }, isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value))
        return true;
      return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
    }, supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  });
  require_is_regex = __commonJS2((exports, module2) => {
    var callBound = require_call_bound(), hasToStringTag = require_shams2()(), hasOwn = require_hasown(), gOPD = require_gopd(), fn2;
    if (hasToStringTag) {
      if ($exec = callBound("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
        throw isRegexMarker;
      }, badStringifier = { toString: throwRegexMarker, valueOf: throwRegexMarker }, typeof Symbol.toPrimitive === "symbol")
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      fn2 = function isRegex(value) {
        if (!value || typeof value !== "object")
          return false;
        var descriptor = gOPD(value, "lastIndex"), hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty)
          return false;
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      };
    } else
      $toString = callBound("Object.prototype.toString"), regexClass = "[object RegExp]", fn2 = function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function")
          return false;
        return $toString(value) === regexClass;
      };
    var $exec, isRegexMarker, throwRegexMarker, badStringifier, $toString, regexClass;
    module2.exports = fn2;
  });
  require_safe_regex_test = __commonJS2((exports, module2) => {
    var callBound = require_call_bound(), isRegex = require_is_regex(), $exec = callBound("RegExp.prototype.exec"), $TypeError = require_type();
    module2.exports = function regexTester(regex) {
      if (!isRegex(regex))
        throw new $TypeError("`regex` must be a RegExp");
      return function test(s3) {
        return $exec(regex, s3) !== null;
      };
    };
  });
  require_is_generator_function = __commonJS2((exports, module2) => {
    var callBound = require_call_bound(), safeRegexTest = require_safe_regex_test(), isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag = require_shams2()(), getProto = require_get_proto(), toStr = callBound("Object.prototype.toString"), fnToStr = callBound("Function.prototype.toString"), getGeneratorFunc = function() {
      if (!hasToStringTag)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (e) {}
    }, GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn2) {
      if (typeof fn2 !== "function")
        return false;
      if (isFnRegex(fnToStr(fn2)))
        return true;
      if (!hasToStringTag) {
        var str = toStr(fn2);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto)
        return false;
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn2) === GeneratorFunction;
    };
  });
  require_is_callable = __commonJS2((exports, module2) => {
    var fnToStr = Function.prototype.toString, reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function")
      try {
        badArrayLike = Object.defineProperty({}, "length", { get: function() {
          throw isCallableMarker;
        } }), isCallableMarker = {}, reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_3) {
        if (_3 !== isCallableMarker)
          reflectApply = null;
      }
    else
      reflectApply = null;
    var constructorRegex = /^\s*class\b/, isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    }, tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value))
          return false;
        return fnToStr.call(value), true;
      } catch (e) {
        return false;
      }
    }, toStr = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      if (all = document.all, toStr.call(all) === toStr.call(document.all))
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object"))
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {}
          return false;
        };
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value))
        return true;
      if (!value)
        return false;
      if (typeof value !== "function" && typeof value !== "object")
        return false;
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker)
          return false;
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value))
        return true;
      if (!value)
        return false;
      if (typeof value !== "function" && typeof value !== "object")
        return false;
      if (hasToStringTag)
        return tryFunctionObject(value);
      if (isES6ClassFn(value))
        return false;
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass))
        return false;
      return tryFunctionObject(value);
    };
  });
  require_for_each = __commonJS2((exports, module2) => {
    var isCallable = require_is_callable(), toStr = Object.prototype.toString, hasOwnProperty2 = Object.prototype.hasOwnProperty, forEachArray = function forEachArray(array, iterator, receiver) {
      for (var i3 = 0, len = array.length;i3 < len; i3++)
        if (hasOwnProperty2.call(array, i3))
          if (receiver == null)
            iterator(array[i3], i3, array);
          else
            iterator.call(receiver, array[i3], i3, array);
    }, forEachString = function forEachString(string, iterator, receiver) {
      for (var i3 = 0, len = string.length;i3 < len; i3++)
        if (receiver == null)
          iterator(string.charAt(i3), i3, string);
        else
          iterator.call(receiver, string.charAt(i3), i3, string);
    }, forEachObject = function forEachObject(object, iterator, receiver) {
      for (var k2 in object)
        if (hasOwnProperty2.call(object, k2))
          if (receiver == null)
            iterator(object[k2], k2, object);
          else
            iterator.call(receiver, object[k2], k2, object);
    };
    function isArray2(x3) {
      return toStr.call(x3) === "[object Array]";
    }
    module2.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator))
        throw new TypeError("iterator must be a function");
      var receiver;
      if (arguments.length >= 3)
        receiver = thisArg;
      if (isArray2(list))
        forEachArray(list, iterator, receiver);
      else if (typeof list === "string")
        forEachString(list, iterator, receiver);
      else
        forEachObject(list, iterator, receiver);
    };
  });
  require_possible_typed_array_names = __commonJS2((exports, module2) => {
    module2.exports = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
  });
  require_available_typed_arrays = __commonJS2((exports, module2) => {
    var possibleNames = require_possible_typed_array_names(), g4 = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out2 = [];
      for (var i3 = 0;i3 < possibleNames.length; i3++)
        if (typeof g4[possibleNames[i3]] === "function")
          out2[out2.length] = possibleNames[i3];
      return out2;
    };
  });
  require_define_data_property = __commonJS2((exports, module2) => {
    var $defineProperty = require_es_define_property(), $SyntaxError = require_syntax(), $TypeError = require_type(), gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function")
        throw new $TypeError("`obj` must be an object or a function`");
      if (typeof property !== "string" && typeof property !== "symbol")
        throw new $TypeError("`property` must be a string or a symbol`");
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null)
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null)
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null)
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      if (arguments.length > 6 && typeof arguments[6] !== "boolean")
        throw new $TypeError("`loose`, if provided, must be a boolean");
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null, nonWritable = arguments.length > 4 ? arguments[4] : null, nonConfigurable = arguments.length > 5 ? arguments[5] : null, loose = arguments.length > 6 ? arguments[6] : false, desc = !!gopd && gopd(obj, property);
      if ($defineProperty)
        $defineProperty(obj, property, { configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable, enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable, value, writable: nonWritable === null && desc ? desc.writable : !nonWritable });
      else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable)
        obj[property] = value;
      else
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    };
  });
  require_has_property_descriptors = __commonJS2((exports, module2) => {
    var $defineProperty = require_es_define_property(), hasPropertyDescriptors = function hasPropertyDescriptors() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty)
        return null;
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  });
  require_set_function_length = __commonJS2((exports, module2) => {
    var GetIntrinsic = require_get_intrinsic(), define = require_define_data_property(), hasDescriptors = require_has_property_descriptors()(), gOPD = require_gopd(), $TypeError = require_type(), $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn2, length) {
      if (typeof fn2 !== "function")
        throw new $TypeError("`fn` is not a function");
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length)
        throw new $TypeError("`length` must be a positive 32-bit integer");
      var loose = arguments.length > 2 && !!arguments[2], functionLengthIsConfigurable = true, functionLengthIsWritable = true;
      if ("length" in fn2 && gOPD) {
        var desc = gOPD(fn2, "length");
        if (desc && !desc.configurable)
          functionLengthIsConfigurable = false;
        if (desc && !desc.writable)
          functionLengthIsWritable = false;
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose)
        if (hasDescriptors)
          define(fn2, "length", length, true, true);
        else
          define(fn2, "length", length);
      return fn2;
    };
  });
  require_applyBind = __commonJS2((exports, module2) => {
    var bind = require_function_bind(), $apply = require_functionApply(), actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  });
  require_call_bind = __commonJS2((exports, module2) => {
    var setFunctionLength = require_set_function_length(), $defineProperty = require_es_define_property(), callBindBasic = require_call_bind_apply_helpers(), applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func2 = callBindBasic(arguments), adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(func2, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
    };
    if ($defineProperty)
      $defineProperty(module2.exports, "apply", { value: applyBind });
    else
      module2.exports.apply = applyBind;
  });
  require_which_typed_array = __commonJS2((exports, module2) => {
    var forEach = require_for_each(), availableTypedArrays = require_available_typed_arrays(), callBind = require_call_bind(), callBound = require_call_bound(), gOPD = require_gopd(), getProto = require_get_proto(), $toString = callBound("Object.prototype.toString"), hasToStringTag = require_shams2()(), g4 = typeof globalThis === "undefined" ? global : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i3 = 0;i3 < array.length; i3 += 1)
        if (array[i3] === value)
          return i3;
      return -1;
    }, cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto)
      forEach(typedArrays, function(typedArray) {
        var arr = new g4[typedArray];
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr), descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    else
      forEach(typedArrays, function(typedArray) {
        var arr = new g4[typedArray], fn2 = arr.slice || arr.set;
        if (fn2)
          cache["$" + typedArray] = callBind(fn2);
      });
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      return forEach(cache, function(getter, typedArray) {
        if (!found)
          try {
            if ("$" + getter(value) === typedArray)
              found = $slice(typedArray, 1);
          } catch (e) {}
      }), found;
    }, trySlices = function tryAllSlices(value) {
      var found = false;
      return forEach(cache, function(getter, name2) {
        if (!found)
          try {
            getter(value), found = $slice(name2, 1);
          } catch (e) {}
      }), found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object")
        return false;
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1)
          return tag;
        if (tag !== "Object")
          return false;
        return trySlices(value);
      }
      if (!gOPD)
        return null;
      return tryTypedArrays(value);
    };
  });
  require_is_typed_array = __commonJS2((exports, module2) => {
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  });
  require_types = __commonJS2((exports) => {
    var isArgumentsObject = require_is_arguments(), isGeneratorFunction = require_is_generator_function(), whichTypedArray = require_which_typed_array(), isTypedArray = require_is_typed_array();
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var BigIntSupported = typeof BigInt !== "undefined", SymbolSupported = typeof Symbol !== "undefined", ObjectToString = uncurryThis(Object.prototype.toString), numberValue = uncurryThis(Number.prototype.valueOf), stringValue = uncurryThis(String.prototype.valueOf), booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported)
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    var bigIntValue;
    if (SymbolSupported)
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object")
        return false;
      try {
        return prototypeValueOf(value), true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView)
        return ArrayBuffer.isView(value);
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map);
    function isMap(value) {
      if (typeof Map === "undefined")
        return false;
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set);
    function isSet(value) {
      if (typeof Set === "undefined")
        return false;
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap);
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined")
        return false;
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet);
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer);
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined")
        return false;
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined")
        return false;
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined")
        return false;
      if (typeof isSharedArrayBufferToString.working === "undefined")
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy);
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, { enumerable: false, value: function() {
        throw new Error(method + " is not supported in userland");
      } });
    });
  });
  require_isBuffer = __commonJS2((exports, module2) => {
    module2.exports = function isBuffer(arg) {
      return arg instanceof Buffer;
    };
  });
  require_inherits_browser = __commonJS2((exports, module2) => {
    if (typeof Object.create === "function")
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor)
          ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
      };
    else
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
      };
  });
  require_inherits = __commonJS2((exports, module2) => {
    try {
      if (util = (init_util(), __toCommonJS(exports_util)), typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  });
  require_util = __commonJS2((exports) => {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
      var keys = Object.keys(obj), descriptors = {};
      for (var i3 = 0;i3 < keys.length; i3++)
        descriptors[keys[i3]] = Object.getOwnPropertyDescriptor(obj, keys[i3]);
      return descriptors;
    }, formatRegExp2 = /%[sdj%]/g;
    exports.format = function(f2) {
      if (!isString2(f2)) {
        var objects = [];
        for (var i3 = 0;i3 < arguments.length; i3++)
          objects.push(inspect3(arguments[i3]));
        return objects.join(" ");
      }
      var i3 = 1, args2 = arguments, len = args2.length, str = String(f2).replace(formatRegExp2, function(x22) {
        if (x22 === "%%")
          return "%";
        if (i3 >= len)
          return x22;
        switch (x22) {
          case "%s":
            return String(args2[i3++]);
          case "%d":
            return Number(args2[i3++]);
          case "%j":
            try {
              return JSON.stringify(args2[i3++]);
            } catch (_3) {
              return "[Circular]";
            }
          default:
            return x22;
        }
      });
      for (var x3 = args2[i3];i3 < len; x3 = args2[++i3])
        if (isNull2(x3) || !isObject2(x3))
          str += " " + x3;
        else
          str += " " + inspect3(x3);
      return str;
    };
    exports.deprecate = function(fn2, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true)
        return fn2;
      if (typeof process === "undefined")
        return function() {
          return exports.deprecate(fn2, msg).apply(this, arguments);
        };
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation)
            throw new Error(msg);
          else if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {}, debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG)
      debugEnv = process.env.NODE_DEBUG, debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    var debugEnv;
    exports.debuglog = function(set) {
      if (set = set.toUpperCase(), !debugs[set])
        if (debugEnvRegex.test(set)) {
          var pid2 = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid2, msg);
          };
        } else
          debugs[set] = function() {};
      return debugs[set];
    };
    function inspect3(obj, opts) {
      var ctx = { seen: [], stylize: stylizeNoColor2 };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean2(opts))
        ctx.showHidden = opts;
      else if (opts)
        exports._extend(ctx, opts);
      if (isUndefined2(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined2(ctx.depth))
        ctx.depth = 2;
      if (isUndefined2(ctx.colors))
        ctx.colors = false;
      if (isUndefined2(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor2;
      return formatValue2(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect3;
    inspect3.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    inspect3.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function stylizeWithColor2(str, styleType) {
      var style = inspect3.styles[styleType];
      if (style)
        return "\x1B[" + inspect3.colors[style][0] + "m" + str + "\x1B[" + inspect3.colors[style][1] + "m";
      else
        return str;
    }
    function stylizeNoColor2(str, styleType) {
      return str;
    }
    function arrayToHash2(array) {
      var hash = {};
      return array.forEach(function(val, idx) {
        hash[val] = true;
      }), hash;
    }
    function formatValue2(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret))
          ret = formatValue2(ctx, ret, recurseTimes);
        return ret;
      }
      var primitive = formatPrimitive2(ctx, value);
      if (primitive)
        return primitive;
      var keys = Object.keys(value), visibleKeys = arrayToHash2(keys);
      if (ctx.showHidden)
        keys = Object.getOwnPropertyNames(value);
      if (isError2(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
        return formatError2(value);
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp2(value))
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        if (isDate2(value))
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        if (isError2(value))
          return formatError2(value);
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value))
        array = true, braces = ["[", "]"];
      if (isFunction2(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base = " [Function" + n2 + "]";
      }
      if (isRegExp2(value))
        base = " " + RegExp.prototype.toString.call(value);
      if (isDate2(value))
        base = " " + Date.prototype.toUTCString.call(value);
      if (isError2(value))
        base = " " + formatError2(value);
      if (keys.length === 0 && (!array || value.length == 0))
        return braces[0] + base + braces[1];
      if (recurseTimes < 0)
        if (isRegExp2(value))
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        else
          return ctx.stylize("[Object]", "special");
      ctx.seen.push(value);
      var output;
      if (array)
        output = formatArray2(ctx, value, recurseTimes, visibleKeys, keys);
      else
        output = keys.map(function(key) {
          return formatProperty2(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      return ctx.seen.pop(), reduceToSingleString2(output, base, braces);
    }
    function formatPrimitive2(ctx, value) {
      if (isUndefined2(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean2(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull2(value))
        return ctx.stylize("null", "null");
    }
    function formatError2(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray2(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i3 = 0, l4 = value.length;i3 < l4; ++i3)
        if (hasOwnProperty2(value, String(i3)))
          output.push(formatProperty2(ctx, value, recurseTimes, visibleKeys, String(i3), true));
        else
          output.push("");
      return keys.forEach(function(key) {
        if (!key.match(/^\d+$/))
          output.push(formatProperty2(ctx, value, recurseTimes, visibleKeys, key, true));
      }), output;
    }
    function formatProperty2(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name2, str, desc;
      if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get)
        if (desc.set)
          str = ctx.stylize("[Getter/Setter]", "special");
        else
          str = ctx.stylize("[Getter]", "special");
      else if (desc.set)
        str = ctx.stylize("[Setter]", "special");
      if (!hasOwnProperty2(visibleKeys, key))
        name2 = "[" + key + "]";
      if (!str)
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull2(recurseTimes))
            str = formatValue2(ctx, desc.value, null);
          else
            str = formatValue2(ctx, desc.value, recurseTimes - 1);
          if (str.indexOf(`
`) > -1)
            if (array)
              str = str.split(`
`).map(function(line) {
                return "  " + line;
              }).join(`
`).slice(2);
            else
              str = `
` + str.split(`
`).map(function(line) {
                return "   " + line;
              }).join(`
`);
        } else
          str = ctx.stylize("[Circular]", "special");
      if (isUndefined2(name2)) {
        if (array && key.match(/^\d+$/))
          return str;
        if (name2 = JSON.stringify("" + key), name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
          name2 = name2.slice(1, -1), name2 = ctx.stylize(name2, "name");
        else
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name2 = ctx.stylize(name2, "string");
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString2(output, base, braces) {
      var numLinesEst = 0, length = output.reduce(function(prev, cur) {
        if (numLinesEst++, cur.indexOf(`
`) >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60)
        return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray2;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports.isNull = isNull2;
    function isNullOrUndefined2(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined2;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString2;
    function isSymbol2(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol2;
    function isUndefined2(arg) {
      return arg === undefined;
    }
    exports.isUndefined = isUndefined2;
    function isRegExp2(re2) {
      return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp2;
    exports.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject2;
    function isDate2(d3) {
      return isObject2(d3) && objectToString2(d3) === "[object Date]";
    }
    exports.isDate = isDate2;
    exports.types.isDate = isDate2;
    function isError2(e) {
      return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError2;
    exports.types.isNativeError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive2;
    exports.isBuffer = require_isBuffer();
    function objectToString2(o3) {
      return Object.prototype.toString.call(o3);
    }
    function pad2(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function timestamp2() {
      var d3 = new Date, time = [pad2(d3.getHours()), pad2(d3.getMinutes()), pad2(d3.getSeconds())].join(":");
      return [d3.getDate(), months2[d3.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp2(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits();
    exports._extend = function(origin, add) {
      if (!add || !isObject2(add))
        return origin;
      var keys = Object.keys(add), i3 = keys.length;
      while (i3--)
        origin[keys[i3]] = add[keys[i3]];
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol2 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol2 && original[kCustomPromisifiedSymbol2]) {
        var fn2 = original[kCustomPromisifiedSymbol2];
        if (typeof fn2 !== "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(fn2, kCustomPromisifiedSymbol2, { value: fn2, enumerable: false, writable: false, configurable: true }), fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve, promiseReject = reject;
        }), args2 = [];
        for (var i3 = 0;i3 < arguments.length; i3++)
          args2.push(arguments[i3]);
        args2.push(function(err2, value) {
          if (err2)
            promiseReject(err2);
          else
            promiseResolve(value);
        });
        try {
          original.apply(this, args2);
        } catch (err2) {
          promiseReject(err2);
        }
        return promise;
      }
      if (Object.setPrototypeOf(fn2, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol2)
        Object.defineProperty(fn2, kCustomPromisifiedSymbol2, { value: fn2, enumerable: false, writable: false, configurable: true });
      return Object.defineProperties(fn2, getOwnPropertyDescriptors(original));
    };
    exports.promisify.custom = kCustomPromisifiedSymbol2;
    function callbackifyOnRejected2(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason, reason = newReason;
      }
      return cb(reason);
    }
    function callbackify2(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      function callbackified() {
        var args2 = [];
        for (var i3 = 0;i3 < arguments.length; i3++)
          args2.push(arguments[i3]);
        var maybeCb = args2.pop();
        if (typeof maybeCb !== "function")
          throw new TypeError("The last argument must be of type Function");
        var self2 = this, cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args2).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected2.bind(null, rej, cb));
        });
      }
      return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, getOwnPropertyDescriptors(original)), callbackified;
    }
    exports.callbackify = callbackify2;
  });
  require_errors = __commonJS2((exports, module2) => {
    function _typeof(o3) {
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
        return typeof o22;
      } : function(o22) {
        return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
      }, _typeof(o3);
    }
    function _defineProperties(target, props) {
      for (var i3 = 0;i3 < props.length; i3++) {
        var descriptor = props[i3];
        if (descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      if (subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }), Object.defineProperty(subClass, "prototype", { writable: false }), superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o3, p2) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o22, p22) {
        return o22.__proto__ = p22, o22;
      }, _setPrototypeOf(o3, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function"))
        return call;
      else if (call !== undefined)
        throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o3) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o22) {
        return o22.__proto__ || Object.getPrototypeOf(o22);
      }, _getPrototypeOf(o3);
    }
    var codes = {}, assert2, util;
    function createErrorType(code, message, Base) {
      if (!Base)
        Base = Error;
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string")
          return message;
        else
          return message(arg1, arg2, arg3);
      }
      var NodeError = function(_Base) {
        _inherits(NodeError2, _Base);
        var _super = _createSuper(NodeError2);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          return _classCallCheck(this, NodeError2), _this = _super.call(this, getMessage(arg1, arg2, arg3)), _this.code = code, _this;
        }
        return _createClass(NodeError2);
      }(Base);
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        if (expected = expected.map(function(i3) {
          return String(i3);
        }), len > 2)
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2)
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else
          return "of ".concat(thing, " ").concat(expected[0]);
      } else
        return "of ".concat(thing, " ").concat(String(expected));
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length)
        this_len = str.length;
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start2) {
      if (typeof start2 !== "number")
        start2 = 0;
      if (start2 + search.length > str.length)
        return false;
      else
        return str.indexOf(search, start2) !== -1;
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      if (assert2 === undefined)
        assert2 = require_assert();
      assert2(typeof name2 === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not "))
        determiner = "must not be", expected = expected.replace(/^not /, "");
      else
        determiner = "must be";
      var msg;
      if (endsWith(name2, " argument"))
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      return msg += ". Received type ".concat(_typeof(actual)), msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name2, value) {
      var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
      if (util === undefined)
        util = require_util();
      var inspected = util.inspect(value);
      if (inspected.length > 128)
        inspected = "".concat(inspected.slice(0, 128), "...");
      return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name2, value) {
      var type;
      if (value && value.constructor && value.constructor.name)
        type = "instance of ".concat(value.constructor.name);
      else
        type = "type ".concat(_typeof(value));
      return "Expected ".concat(input, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0;_key < _len; _key++)
        args2[_key] = arguments[_key];
      if (assert2 === undefined)
        assert2 = require_assert();
      assert2(args2.length > 0, "At least one arg needs to be specified");
      var msg = "The ", len = args2.length;
      switch (args2 = args2.map(function(a2) {
        return '"'.concat(a2, '"');
      }), len) {
        case 1:
          msg += "".concat(args2[0], " argument");
          break;
        case 2:
          msg += "".concat(args2[0], " and ").concat(args2[1], " arguments");
          break;
        default:
          msg += args2.slice(0, len - 1).join(", "), msg += ", and ".concat(args2[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    exports.codes = codes;
  });
  require_assertion_error = __commonJS2((exports, module2) => {
    function ownKeys(e, r2) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(e);
        r2 && (o3 = o3.filter(function(r22) {
          return Object.getOwnPropertyDescriptor(e, r22).enumerable;
        })), t.push.apply(t, o3);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r2 = 1;r2 < arguments.length; r2++) {
        var t = arguments[r2] != null ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t), true).forEach(function(r22) {
          _defineProperty(e, r22, t[r22]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r22) {
          Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
        });
      }
      return e;
    }
    function _defineProperty(obj, key, value) {
      if (key = _toPropertyKey(key), key in obj)
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      else
        obj[key] = value;
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i3 = 0;i3 < props.length; i3++) {
        var descriptor = props[i3];
        if (descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      if (subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }), Object.defineProperty(subClass, "prototype", { writable: false }), superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function"))
        return call;
      else if (call !== undefined)
        throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map : undefined;
      return _wrapNativeSuper = function _wrapNativeSuper(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, Class2);
      }, _wrapNativeSuper(Class);
    }
    function _construct(Parent, args2, Class) {
      if (_isNativeReflectConstruct())
        _construct = Reflect.construct.bind();
      else
        _construct = function _construct(Parent2, args22, Class2) {
          var a2 = [null];
          a2.push.apply(a2, args22);
          var Constructor = Function.bind.apply(Parent2, a2), instance2 = new Constructor;
          if (Class2)
            _setPrototypeOf(instance2, Class2.prototype);
          return instance2;
        };
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o3, p2) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o22, p22) {
        return o22.__proto__ = p22, o22;
      }, _setPrototypeOf(o3, p2);
    }
    function _getPrototypeOf(o3) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o22) {
        return o22.__proto__ || Object.getPrototypeOf(o22);
      }, _getPrototypeOf(o3);
    }
    function _typeof(o3) {
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
        return typeof o22;
      } : function(o22) {
        return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
      }, _typeof(o3);
    }
    var _require = require_util(), inspect3 = _require.inspect, _require2 = require_errors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length)
        this_len = str.length;
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      if (count = Math.floor(count), str.length == 0 || count == 0)
        return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count)
        str += str, count--;
      return str += str.substring(0, maxCount - str.length), str;
    }
    var blue = "", green = "", red = "", white = "", kReadableOperator = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" }, kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source), target = Object.create(Object.getPrototypeOf(source));
      return keys.forEach(function(key) {
        target[key] = source[key];
      }), Object.defineProperty(target, "message", { value: source.message }), target;
    }
    function inspectValue(val) {
      return inspect3(val, { compact: false, customInspect: false, depth: 1000, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "", res = "", lastPos = 0, end = "", skipped = false, actualInspected = inspectValue(actual), actualLines = actualInspected.split(`
`), expectedLines = inspectValue(expected).split(`
`), i3 = 0, indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null)
        operator = "strictEqualObject";
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0))
            return "".concat(kReadableOperator[operator], `

`) + "".concat(actualLines[0], " !== ").concat(expectedLines[0], `
`);
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i3] === expectedLines[0][i3])
              i3++;
            if (i3 > 2)
              indicator = `
  `.concat(repeat(" ", i3), "^"), i3 = 0;
          }
        }
      }
      var a2 = actualLines[actualLines.length - 1], b3 = expectedLines[expectedLines.length - 1];
      while (a2 === b3) {
        if (i3++ < 2)
          end = `
  `.concat(a2).concat(end);
        else
          other = a2;
        if (actualLines.pop(), expectedLines.pop(), actualLines.length === 0 || expectedLines.length === 0)
          break;
        a2 = actualLines[actualLines.length - 1], b3 = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split(`
`);
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27)
            _actualLines.pop();
        }
        return "".concat(kReadableOperator.notIdentical, `

`).concat(_actualLines.join(`
`), `
`);
      }
      if (i3 > 3)
        end = `
`.concat(blue, "...").concat(white).concat(end), skipped = true;
      if (other !== "")
        end = `
  `.concat(other).concat(end), other = "";
      var printedLines = 0, msg = kReadableOperator[operator] + `
`.concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white), skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i3 = 0;i3 < maxLines; i3++) {
        var cur = i3 - lastPos;
        if (actualLines.length < i3 + 1) {
          if (cur > 1 && i3 > 2) {
            if (cur > 4)
              res += `
`.concat(blue, "...").concat(white), skipped = true;
            else if (cur > 3)
              res += `
  `.concat(expectedLines[i3 - 2]), printedLines++;
            res += `
  `.concat(expectedLines[i3 - 1]), printedLines++;
          }
          lastPos = i3, other += `
`.concat(red, "-").concat(white, " ").concat(expectedLines[i3]), printedLines++;
        } else if (expectedLines.length < i3 + 1) {
          if (cur > 1 && i3 > 2) {
            if (cur > 4)
              res += `
`.concat(blue, "...").concat(white), skipped = true;
            else if (cur > 3)
              res += `
  `.concat(actualLines[i3 - 2]), printedLines++;
            res += `
  `.concat(actualLines[i3 - 1]), printedLines++;
          }
          lastPos = i3, res += `
`.concat(green, "+").concat(white, " ").concat(actualLines[i3]), printedLines++;
        } else {
          var expectedLine = expectedLines[i3], actualLine = actualLines[i3], divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine)
            divergingLines = false, actualLine += ",";
          if (divergingLines) {
            if (cur > 1 && i3 > 2) {
              if (cur > 4)
                res += `
`.concat(blue, "...").concat(white), skipped = true;
              else if (cur > 3)
                res += `
  `.concat(actualLines[i3 - 2]), printedLines++;
              res += `
  `.concat(actualLines[i3 - 1]), printedLines++;
            }
            lastPos = i3, res += `
`.concat(green, "+").concat(white, " ").concat(actualLine), other += `
`.concat(red, "-").concat(white, " ").concat(expectedLine), printedLines += 2;
          } else if (res += other, other = "", cur === 1 || i3 === 0)
            res += `
  `.concat(actualLine), printedLines++;
        }
        if (printedLines > 20 && i3 < maxLines - 2)
          return "".concat(msg).concat(skippedMsg, `
`).concat(res, `
`).concat(blue, "...").concat(white).concat(other, `
`) + "".concat(blue, "...").concat(white);
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", `
`).concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = function(_Error, _inspect$custom) {
      _inherits(AssertionError2, _Error);
      var _super = _createSuper(AssertionError2);
      function AssertionError2(options) {
        var _this;
        if (_classCallCheck(this, AssertionError2), _typeof(options) !== "object" || options === null)
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        var { message, operator, stackStartFn, actual, expected } = options, limit = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, message != null)
          _this = _super.call(this, String(message));
        else {
          if (process.stderr && process.stderr.isTTY)
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1)
              blue = "\x1B[34m", green = "\x1B[32m", white = "\x1B[39m", red = "\x1B[31m";
            else
              blue = "", green = "", white = "", red = "";
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error)
            actual = copyError(actual), expected = copyError(expected);
          if (operator === "deepStrictEqual" || operator === "strictEqual")
            _this = _super.call(this, createErrDiff(actual, expected, operator));
          else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator], res = inspectValue(actual).split(`
`);
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null)
              base = kReadableOperator.notStrictEqualObject;
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27)
                res.pop();
            }
            if (res.length === 1)
              _this = _super.call(this, "".concat(base, " ").concat(res[0]));
            else
              _this = _super.call(this, "".concat(base, `

`).concat(res.join(`
`), `
`));
          } else {
            var _res = inspectValue(actual), other = "", knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              if (_res = "".concat(kReadableOperator[operator], `

`).concat(_res), _res.length > 1024)
                _res = "".concat(_res.slice(0, 1021), "...");
            } else {
              if (other = "".concat(inspectValue(expected)), _res.length > 512)
                _res = "".concat(_res.slice(0, 509), "...");
              if (other.length > 512)
                other = "".concat(other.slice(0, 509), "...");
              if (operator === "deepEqual" || operator === "equal")
                _res = "".concat(knownOperators, `

`).concat(_res, `

should equal

`);
              else
                other = " ".concat(operator, " ").concat(other);
            }
            _this = _super.call(this, "".concat(_res).concat(other));
          }
        }
        if (Error.stackTraceLimit = limit, _this.generatedMessage = !message, Object.defineProperty(_assertThisInitialized(_this), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), _this.code = "ERR_ASSERTION", _this.actual = actual, _this.expected = expected, _this.operator = operator, Error.captureStackTrace)
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        return _this.stack, _this.name = "AssertionError", _possibleConstructorReturn(_this);
      }
      return _createClass(AssertionError2, [{ key: "toString", value: function toString() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: _inspect$custom, value: function value(recurseTimes, ctx) {
        return inspect3(this, _objectSpread(_objectSpread({}, ctx), {}, { customInspect: false, depth: 0 }));
      } }]), AssertionError2;
    }(_wrapNativeSuper(Error), inspect3.custom);
    module2.exports = AssertionError;
  });
  require_isArguments = __commonJS2((exports, module2) => {
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value), isArgs = str === "[object Arguments]";
      if (!isArgs)
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      return isArgs;
    };
  });
  require_implementation2 = __commonJS2((exports, module2) => {
    var keysShim;
    if (!Object.keys)
      has = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, isArgs = require_isArguments(), isEnumerable = Object.prototype.propertyIsEnumerable, hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString"), hasProtoEnumBug = isEnumerable.call(function() {}, "prototype"), dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], equalsConstructorPrototype = function(o3) {
        var ctor = o3.constructor;
        return ctor && ctor.prototype === o3;
      }, excludedKeys = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, hasAutomationEqualityBug = function() {
        if (typeof window === "undefined")
          return false;
        for (var k2 in window)
          try {
            if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object")
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e) {
                return true;
              }
          } catch (e) {
            return true;
          }
        return false;
      }(), equalsConstructorPrototypeIfNotBuggy = function(o3) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug)
          return equalsConstructorPrototype(o3);
        try {
          return equalsConstructorPrototype(o3);
        } catch (e) {
          return false;
        }
      }, keysShim = function keys(object) {
        var isObject2 = object !== null && typeof object === "object", isFunction2 = toStr.call(object) === "[object Function]", isArguments = isArgs(object), isString2 = isObject2 && toStr.call(object) === "[object String]", theKeys = [];
        if (!isObject2 && !isFunction2 && !isArguments)
          throw new TypeError("Object.keys called on a non-object");
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has.call(object, 0))
          for (var i3 = 0;i3 < object.length; ++i3)
            theKeys.push(String(i3));
        if (isArguments && object.length > 0)
          for (var j2 = 0;j2 < object.length; ++j2)
            theKeys.push(String(j2));
        else
          for (var name2 in object)
            if (!(skipProto && name2 === "prototype") && has.call(object, name2))
              theKeys.push(String(name2));
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k2 = 0;k2 < dontEnums.length; ++k2)
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object, dontEnums[k2]))
              theKeys.push(dontEnums[k2]);
        }
        return theKeys;
      };
    var has, toStr, isArgs, isEnumerable, hasDontEnumBug, hasProtoEnumBug, dontEnums, equalsConstructorPrototype, excludedKeys, hasAutomationEqualityBug, equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  });
  require_object_keys = __commonJS2((exports, module2) => {
    var slice = Array.prototype.slice, isArgs = require_isArguments(), origKeys = Object.keys, keysShim = origKeys ? function keys(o3) {
      return origKeys(o3);
    } : require_implementation2(), originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args2 = Object.keys(arguments);
          return args2 && args2.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments)
          Object.keys = function keys(object) {
            if (isArgs(object))
              return originalKeys(slice.call(object));
            return originalKeys(object);
          };
      } else
        Object.keys = keysShim;
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  });
  require_implementation3 = __commonJS2((exports, module2) => {
    var objectKeys = require_object_keys(), hasSymbols = require_shams()(), callBound = require_call_bound(), $Object = require_es_object_atoms(), $push = callBound("Array.prototype.push"), $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable"), originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;
    module2.exports = function assign(target, source1) {
      if (target == null)
        throw new TypeError("target must be an object");
      var to = $Object(target);
      if (arguments.length === 1)
        return to;
      for (var s3 = 1;s3 < arguments.length; ++s3) {
        var from = $Object(arguments[s3]), keys = objectKeys(from), getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j2 = 0;j2 < syms.length; ++j2) {
            var key = syms[j2];
            if ($propIsEnumerable(from, key))
              $push(keys, key);
          }
        }
        for (var i3 = 0;i3 < keys.length; ++i3) {
          var nextKey = keys[i3];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  });
  require_polyfill = __commonJS2((exports, module2) => {
    var implementation = require_implementation3(), lacksProperEnumerationOrder = function() {
      if (!Object.assign)
        return false;
      var str = "abcdefghijklmnopqrst", letters = str.split(""), map = {};
      for (var i3 = 0;i3 < letters.length; ++i3)
        map[letters[i3]] = letters[i3];
      var obj = Object.assign({}, map), actual = "";
      for (var k2 in obj)
        actual += k2;
      return str !== actual;
    }, assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions)
        return false;
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e) {
        return thrower[1] === "y";
      }
      return false;
    };
    module2.exports = function getPolyfill() {
      if (!Object.assign)
        return implementation;
      if (lacksProperEnumerationOrder())
        return implementation;
      if (assignHasPendingExceptions())
        return implementation;
      return Object.assign;
    };
  });
  require_implementation4 = __commonJS2((exports, module2) => {
    var numberIsNaN2 = function(value) {
      return value !== value;
    };
    module2.exports = function is(a2, b3) {
      if (a2 === 0 && b3 === 0)
        return 1 / a2 === 1 / b3;
      if (a2 === b3)
        return true;
      if (numberIsNaN2(a2) && numberIsNaN2(b3))
        return true;
      return false;
    };
  });
  require_polyfill2 = __commonJS2((exports, module2) => {
    var implementation = require_implementation4();
    module2.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  });
  require_callBound = __commonJS2((exports, module2) => {
    var GetIntrinsic = require_get_intrinsic(), callBind = require_call_bind(), $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1)
        return callBind(intrinsic);
      return intrinsic;
    };
  });
  require_define_properties = __commonJS2((exports, module2) => {
    var keys = require_object_keys(), hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol", toStr = Object.prototype.toString, concat = Array.prototype.concat, defineDataProperty = require_define_data_property(), isFunction2 = function(fn2) {
      return typeof fn2 === "function" && toStr.call(fn2) === "[object Function]";
    }, supportsDescriptors = require_has_property_descriptors()(), defineProperty = function(object, name2, value, predicate) {
      if (name2 in object) {
        if (predicate === true) {
          if (object[name2] === value)
            return;
        } else if (!isFunction2(predicate) || !predicate())
          return;
      }
      if (supportsDescriptors)
        defineDataProperty(object, name2, value, true);
      else
        defineDataProperty(object, name2, value);
    }, defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {}, props = keys(map);
      if (hasSymbols)
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      for (var i3 = 0;i3 < props.length; i3 += 1)
        defineProperty(object, props[i3], map[props[i3]], predicates[props[i3]]);
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  });
  require_shim = __commonJS2((exports, module2) => {
    var getPolyfill = require_polyfill2(), define = require_define_properties();
    module2.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      return define(Object, { is: polyfill }, { is: function testObjectIs() {
        return Object.is !== polyfill;
      } }), polyfill;
    };
  });
  require_object_is = __commonJS2((exports, module2) => {
    var define = require_define_properties(), callBind = require_call_bind(), implementation = require_implementation4(), getPolyfill = require_polyfill2(), shim = require_shim(), polyfill = callBind(getPolyfill(), Object);
    define(polyfill, { getPolyfill, implementation, shim });
    module2.exports = polyfill;
  });
  require_implementation5 = __commonJS2((exports, module2) => {
    module2.exports = function isNaN(value) {
      return value !== value;
    };
  });
  require_polyfill3 = __commonJS2((exports, module2) => {
    var implementation = require_implementation5();
    module2.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a"))
        return Number.isNaN;
      return implementation;
    };
  });
  require_shim2 = __commonJS2((exports, module2) => {
    var define = require_define_properties(), getPolyfill = require_polyfill3();
    module2.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      return define(Number, { isNaN: polyfill }, { isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill;
      } }), polyfill;
    };
  });
  require_is_nan = __commonJS2((exports, module2) => {
    var callBind = require_call_bind(), define = require_define_properties(), implementation = require_implementation5(), getPolyfill = require_polyfill3(), shim = require_shim2(), polyfill = callBind(getPolyfill(), Number);
    define(polyfill, { getPolyfill, implementation, shim });
    module2.exports = polyfill;
  });
  require_comparisons = __commonJS2((exports, module2) => {
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o3, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len);i3 < len; i3++)
        arr2[i3] = arr[i3];
      return arr2;
    }
    function _iterableToArrayLimit(r2, l4) {
      var t = r2 == null ? null : typeof Symbol != "undefined" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t != null) {
        var e, n2, i3, u3, a2 = [], f2 = true, o3 = false;
        try {
          if (i3 = (t = t.call(r2)).next, l4 === 0) {
            if (Object(t) !== t)
              return;
            f2 = false;
          } else
            for (;!(f2 = (e = i3.call(t)).done) && (a2.push(e.value), a2.length !== l4); f2 = true)
              ;
        } catch (r22) {
          o3 = true, n2 = r22;
        } finally {
          try {
            if (!f2 && t.return != null && (u3 = t.return(), Object(u3) !== u3))
              return;
          } finally {
            if (o3)
              throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof(o3) {
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
        return typeof o22;
      } : function(o22) {
        return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
      }, _typeof(o3);
    }
    var regexFlagsSupported = /a/g.flags !== undefined, arrayFromSet = function arrayFromSet(set) {
      var array = [];
      return set.forEach(function(value) {
        return array.push(value);
      }), array;
    }, arrayFromMap = function arrayFromMap(map) {
      var array = [];
      return map.forEach(function(value, key) {
        return array.push([key, value]);
      }), array;
    }, objectIs = Object.is ? Object.is : require_object_is(), objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    }, numberIsNaN2 = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty), propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable), objectToString2 = uncurryThis(Object.prototype.toString), _require$types = require_util().types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate2 = _require$types.isDate, isMap = _require$types.isMap, isRegExp2 = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10)
        return true;
      for (var i3 = 0;i3 < key.length; i3++) {
        var code = key.charCodeAt(i3);
        if (code < 48 || code > 57)
          return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    function compare(a2, b3) {
      if (a2 === b3)
        return 0;
      var x3 = a2.length, y2 = b3.length;
      for (var i3 = 0, len = Math.min(x3, y2);i3 < len; ++i3)
        if (a2[i3] !== b3[i3]) {
          x3 = a2[i3], y2 = b3[i3];
          break;
        }
      if (x3 < y2)
        return -1;
      if (y2 < x3)
        return 1;
      return 0;
    }
    var ONLY_ENUMERABLE = undefined, kStrict = true, kLoose = false, kNoIterator = 0, kIsArray = 1, kIsSet = 2, kIsMap = 3;
    function areSimilarRegExps(a2, b3) {
      return regexFlagsSupported ? a2.source === b3.source && a2.flags === b3.flags : RegExp.prototype.toString.call(a2) === RegExp.prototype.toString.call(b3);
    }
    function areSimilarFloatArrays(a2, b3) {
      if (a2.byteLength !== b3.byteLength)
        return false;
      for (var offset = 0;offset < a2.byteLength; offset++)
        if (a2[offset] !== b3[offset])
          return false;
      return true;
    }
    function areSimilarTypedArrays(a2, b3) {
      if (a2.byteLength !== b3.byteLength)
        return false;
      return compare(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b3.buffer, b3.byteOffset, b3.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1))
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      if (isStringObject(val1))
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      if (isBooleanObject(val1))
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      if (isBigIntObject(val1))
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0)
          return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object")
          return typeof val1 === "number" && numberIsNaN2(val1) && numberIsNaN2(val2);
        if (_typeof(val2) !== "object" || val1 === null || val2 === null)
          return false;
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2))
          return false;
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object")
            return val1 == val2;
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object")
          return false;
      }
      var val1Tag = objectToString2(val1), val2Tag = objectToString2(val2);
      if (val1Tag !== val2Tag)
        return false;
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length)
          return false;
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE), keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length)
          return false;
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2))
          return false;
      }
      if (isDate2(val1)) {
        if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2))
          return false;
      } else if (isRegExp2(val1)) {
        if (!isRegExp2(val2) || !areSimilarRegExps(val1, val2))
          return false;
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name)
          return false;
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2))
            return false;
        } else if (!areSimilarTypedArrays(val1, val2))
          return false;
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE), _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length)
          return false;
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size)
          return false;
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size)
          return false;
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2))
          return false;
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2))
        return false;
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k2) {
        return propertyIsEnumerable(val, k2);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length)
          return false;
      }
      var i3 = 0;
      for (;i3 < aKeys.length; i3++)
        if (!hasOwnProperty2(val2, aKeys[i3]))
          return false;
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i3 = 0;i3 < symbolKeysA.length; i3++) {
            var key = symbolKeysA[i3];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key))
                return false;
              aKeys.push(key), count++;
            } else if (propertyIsEnumerable(val2, key))
              return false;
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count)
            return false;
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0)
            return false;
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0))
        return true;
      if (memos === undefined)
        memos = { val1: new Map, val2: new Map, position: 0 };
      else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== undefined)
            return val2MemoA === val2MemoB;
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position), memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      return memos.val1.delete(val1), memos.val2.delete(val2), areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i3 = 0;i3 < setValues.length; i3++) {
        var val2 = setValues[i3];
        if (innerDeepEqual(val1, val2, strict, memo))
          return set.delete(val2), true;
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN2(prim))
            return false;
      }
      return true;
    }
    function setMightHaveLoosePrim(a2, b3, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      return b3.has(altValue) && !a2.has(altValue);
    }
    function mapMightHaveLoosePrim(a2, b3, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      var curB = b3.get(altValue);
      if (curB === undefined && !b3.has(altValue) || !innerDeepEqual(item, curB, false, memo))
        return false;
      return !a2.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a2, b3, strict, memo) {
      var set = null, aValues = arrayFromSet(a2);
      for (var i3 = 0;i3 < aValues.length; i3++) {
        var val = aValues[i3];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null)
            set = new Set;
          set.add(val);
        } else if (!b3.has(val)) {
          if (strict)
            return false;
          if (!setMightHaveLoosePrim(a2, b3, val))
            return false;
          if (set === null)
            set = new Set;
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b3);
        for (var _i = 0;_i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo))
              return false;
          } else if (!strict && !a2.has(_val) && !setHasEqualElement(set, _val, strict, memo))
            return false;
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i3 = 0;i3 < setValues.length; i3++) {
        var key2 = setValues[i3];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo))
          return set.delete(key2), true;
      }
      return false;
    }
    function mapEquiv(a2, b3, strict, memo) {
      var set = null, aEntries = arrayFromMap(a2);
      for (var i3 = 0;i3 < aEntries.length; i3++) {
        var _aEntries$i = _slicedToArray(aEntries[i3], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (set === null)
            set = new Set;
          set.add(key);
        } else {
          var item2 = b3.get(key);
          if (item2 === undefined && !b3.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict)
              return false;
            if (!mapMightHaveLoosePrim(a2, b3, key, item1, memo))
              return false;
            if (set === null)
              set = new Set;
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b3);
        for (var _i2 = 0;_i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(_key) === "object" && _key !== null) {
            if (!mapHasEqualEntry(set, a2, _key, item, strict, memo))
              return false;
          } else if (!strict && (!a2.has(_key) || !innerDeepEqual(a2.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a2, _key, item, false, memo))
            return false;
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a2, b3, strict, keys, memos, iterationType) {
      var i3 = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a2, b3, strict, memos))
          return false;
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a2, b3, strict, memos))
          return false;
      } else if (iterationType === kIsArray)
        for (;i3 < a2.length; i3++)
          if (hasOwnProperty2(a2, i3)) {
            if (!hasOwnProperty2(b3, i3) || !innerDeepEqual(a2[i3], b3[i3], strict, memos))
              return false;
          } else if (hasOwnProperty2(b3, i3))
            return false;
          else {
            var keysA = Object.keys(a2);
            for (;i3 < keysA.length; i3++) {
              var key = keysA[i3];
              if (!hasOwnProperty2(b3, key) || !innerDeepEqual(a2[key], b3[key], strict, memos))
                return false;
            }
            if (keysA.length !== Object.keys(b3).length)
              return false;
            return true;
          }
      for (i3 = 0;i3 < keys.length; i3++) {
        var _key2 = keys[i3];
        if (!innerDeepEqual(a2[_key2], b3[_key2], strict, memos))
          return false;
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module2.exports = { isDeepEqual, isDeepStrictEqual };
  });
  require_assert = __commonJS2((exports, module2) => {
    function _typeof(o3) {
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
        return typeof o22;
      } : function(o22) {
        return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
      }, _typeof(o3);
    }
    function _defineProperties(target, props) {
      for (var i3 = 0;i3 < props.length; i3++) {
        var descriptor = props[i3];
        if (descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    var _require = require_errors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, AssertionError = require_assertion_error(), _require2 = require_util(), inspect3 = _require2.inspect, _require$types = require_util().types, isPromise = _require$types.isPromise, isRegExp2 = _require$types.isRegExp, objectAssign = require_polyfill()(), objectIs = require_polyfill2()(), RegExpPrototypeTest = require_callBound()("RegExp.prototype.test"), isDeepEqual, isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual, isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false, assert2 = module2.exports = ok, NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error)
        throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length, internalMessage;
      if (argsLen === 0)
        internalMessage = "Failed";
      else if (argsLen === 1)
        message = actual, actual = undefined;
      else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2)
          operator = "!=";
      }
      if (message instanceof Error)
        throw message;
      var errArgs = { actual, expected, operator: operator === undefined ? "fail" : operator, stackStartFn: stackStartFn || fail };
      if (message !== undefined)
        errArgs.message = message;
      var err2 = new AssertionError(errArgs);
      if (internalMessage)
        err2.message = internalMessage, err2.generatedMessage = true;
      throw err2;
    }
    assert2.fail = fail;
    assert2.AssertionError = AssertionError;
    function innerOk(fn2, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0)
          generatedMessage = true, message = "No value argument passed to `assert.ok()`";
        else if (message instanceof Error)
          throw message;
        var err2 = new AssertionError({ actual: value, expected: true, message, operator: "==", stackStartFn: fn2 });
        throw err2.generatedMessage = generatedMessage, err2;
      }
    }
    function ok() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0;_key < _len; _key++)
        args2[_key] = arguments[_key];
      innerOk.apply(undefined, [ok, args2.length].concat(args2));
    }
    assert2.ok = ok;
    assert2.equal = function equal(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (actual != expected)
        innerFail({ actual, expected, message, operator: "==", stackStartFn: equal });
    };
    assert2.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (actual == expected)
        innerFail({ actual, expected, message, operator: "!=", stackStartFn: notEqual });
    };
    assert2.deepEqual = function deepEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (isDeepEqual === undefined)
        lazyLoadComparison();
      if (!isDeepEqual(actual, expected))
        innerFail({ actual, expected, message, operator: "deepEqual", stackStartFn: deepEqual });
    };
    assert2.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (isDeepEqual === undefined)
        lazyLoadComparison();
      if (isDeepEqual(actual, expected))
        innerFail({ actual, expected, message, operator: "notDeepEqual", stackStartFn: notDeepEqual });
    };
    assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (isDeepEqual === undefined)
        lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected))
        innerFail({ actual, expected, message, operator: "deepStrictEqual", stackStartFn: deepStrictEqual });
    };
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (isDeepEqual === undefined)
        lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected))
        innerFail({ actual, expected, message, operator: "notDeepStrictEqual", stackStartFn: notDeepStrictEqual });
    }
    assert2.strictEqual = function strictEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (!objectIs(actual, expected))
        innerFail({ actual, expected, message, operator: "strictEqual", stackStartFn: strictEqual });
    };
    assert2.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2)
        throw new ERR_MISSING_ARGS("actual", "expected");
      if (objectIs(actual, expected))
        innerFail({ actual, expected, message, operator: "notStrictEqual", stackStartFn: notStrictEqual });
    };
    var Comparison = _createClass(function Comparison(obj, keys, actual) {
      var _this = this;
      _classCallCheck(this, Comparison), keys.forEach(function(key) {
        if (key in obj)
          if (actual !== undefined && typeof actual[key] === "string" && isRegExp2(obj[key]) && RegExpPrototypeTest(obj[key], actual[key]))
            _this[key] = actual[key];
          else
            _this[key] = obj[key];
      });
    });
    function compareExceptionKey(actual, expected, key, message, keys, fn2) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a2 = new Comparison(actual, keys), b3 = new Comparison(expected, keys, actual), err2 = new AssertionError({ actual: a2, expected: b3, operator: "deepStrictEqual", stackStartFn: fn2 });
          throw err2.actual = actual, err2.expected = expected, err2.operator = fn2.name, err2;
        }
        innerFail({ actual, expected, message, operator: fn2.name, stackStartFn: fn2 });
      }
    }
    function expectedException(actual, expected, msg, fn2) {
      if (typeof expected !== "function") {
        if (isRegExp2(expected))
          return RegExpPrototypeTest(expected, actual);
        if (arguments.length === 2)
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        if (_typeof(actual) !== "object" || actual === null) {
          var err2 = new AssertionError({ actual, expected, message: msg, operator: "deepStrictEqual", stackStartFn: fn2 });
          throw err2.operator = fn2.name, err2;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error)
          keys.push("name", "message");
        else if (keys.length === 0)
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        if (isDeepEqual === undefined)
          lazyLoadComparison();
        return keys.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp2(expected[key]) && RegExpPrototypeTest(expected[key], actual[key]))
            return;
          compareExceptionKey(actual, expected, key, msg, keys, fn2);
        }), true;
      }
      if (expected.prototype !== undefined && actual instanceof expected)
        return true;
      if (Error.isPrototypeOf(expected))
        return false;
      return expected.call({}, actual) === true;
    }
    function getActual(fn2) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn2);
      try {
        fn2();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          if (resultPromise = promiseFn(), !checkIsPromise(resultPromise))
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        } else if (checkIsPromise(promiseFn))
          resultPromise = promiseFn;
        else
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4)
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error)
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        } else if (actual === error)
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        message = error, error = undefined;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function")
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name)
          details += " (".concat(error.name, ")");
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({ actual: undefined, expected: error, operator: stackStartFn.name, message: "Missing expected ".concat(fnType).concat(details), stackStartFn });
      }
      if (error && !expectedException(actual, error, message, stackStartFn))
        throw actual;
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL)
        return;
      if (typeof error === "string")
        message = error, error = undefined;
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".", fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({ actual, expected: error, operator: stackStartFn.name, message: "Got unwanted ".concat(fnType).concat(details, `
`) + 'Actual message: "'.concat(actual && actual.message, '"'), stackStartFn });
      }
      throw actual;
    }
    assert2.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++)
        args2[_key2 - 1] = arguments[_key2];
      expectsError.apply(undefined, [throws, getActual(promiseFn)].concat(args2));
    };
    assert2.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1;_key3 < _len3; _key3++)
        args2[_key3 - 1] = arguments[_key3];
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(undefined, [rejects, result].concat(args2));
      });
    };
    assert2.doesNotThrow = function doesNotThrow(fn2) {
      for (var _len4 = arguments.length, args2 = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1;_key4 < _len4; _key4++)
        args2[_key4 - 1] = arguments[_key4];
      expectsNoError.apply(undefined, [doesNotThrow, getActual(fn2)].concat(args2));
    };
    assert2.doesNotReject = function doesNotReject(fn2) {
      for (var _len5 = arguments.length, args2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1;_key5 < _len5; _key5++)
        args2[_key5 - 1] = arguments[_key5];
      return waitForActual(fn2).then(function(result) {
        return expectsNoError.apply(undefined, [doesNotReject, result].concat(args2));
      });
    };
    assert2.ifError = function ifError(err2) {
      if (err2 !== null && err2 !== undefined) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err2) === "object" && typeof err2.message === "string")
          if (err2.message.length === 0 && err2.constructor)
            message += err2.constructor.name;
          else
            message += err2.message;
        else
          message += inspect3(err2);
        var newErr = new AssertionError({ actual: err2, expected: null, operator: "ifError", message, stackStartFn: ifError }), origStack = err2.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split(`
`);
          tmp2.shift();
          var tmp1 = newErr.stack.split(`
`);
          for (var i3 = 0;i3 < tmp2.length; i3++) {
            var pos = tmp1.indexOf(tmp2[i3]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join(`
`), `
`).concat(tmp2.join(`
`));
        }
        throw newErr;
      }
    };
    function internalMatch(string, regexp, message, fn2, fnName) {
      if (!isRegExp2(regexp))
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      var match = fnName === "match";
      if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
        if (message instanceof Error)
          throw message;
        var generatedMessage = !message;
        message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect3(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect3(regexp), `. Input:

`).concat(inspect3(string), `
`));
        var err2 = new AssertionError({ actual: string, expected: regexp, message, operator: fnName, stackStartFn: fn2 });
        throw err2.generatedMessage = generatedMessage, err2;
      }
    }
    assert2.match = function match(string, regexp, message) {
      internalMatch(string, regexp, message, match, "match");
    };
    assert2.doesNotMatch = function doesNotMatch(string, regexp, message) {
      internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
    };
    function strict() {
      for (var _len6 = arguments.length, args2 = new Array(_len6), _key6 = 0;_key6 < _len6; _key6++)
        args2[_key6] = arguments[_key6];
      innerOk.apply(undefined, [strict, args2.length].concat(args2));
    }
    assert2.strict = objectAssign(strict, assert2, { equal: assert2.strictEqual, deepEqual: assert2.deepStrictEqual, notEqual: assert2.notStrictEqual, notDeepEqual: assert2.notDeepStrictEqual });
    assert2.strict.strict = assert2.strict;
  });
  assert2 = __toESM2(require_assert(), 1);
  ({ AssertionError, CallTracker, deepEqual, deepStrictEqual, doesNotMatch, doesNotReject, doesNotThrow, equal, fail, ifError, match, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws } = assert2);
  assert_default = assert2;
});

// node:buffer
var exports_buffer2 = {};
__export(exports_buffer2, {
  transcode: () => transcode,
  resolveObjectURL: () => resolveObjectURL,
  kStringMaxLength: () => kStringMaxLength,
  kMaxLength: () => kMaxLength,
  isUtf8: () => isUtf8,
  isAscii: () => isAscii,
  default: () => buffer_default,
  constants: () => constants,
  btoa: () => btoa,
  atob: () => atob,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  File: () => File2,
  Buffer: () => Buffer2,
  Blob: () => Blob2
});
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function _byteLength(validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i4;
  for (i4 = 0;i4 < len2; i4 += 4)
    tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 2)
    tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 1)
    tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end) {
  var tmp, output = [];
  for (var i4 = start2;i4 < end; i4 += 3)
    tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255), output.push(tripletToBase64(tmp));
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts2 = [], maxChunkLength = 16383;
  for (var i4 = 0, len22 = len2 - extraBytes;i4 < len22; i4 += maxChunkLength)
    parts2.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
  if (extraBytes === 1)
    tmp = uint8[len2 - 1], parts2.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  else if (extraBytes === 2)
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts2.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  return parts2.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m2, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i4 = isLE ? nBytes - 1 : 0, d3 = isLE ? -1 : 1, s3 = buffer[offset + i4];
  i4 += d3, e = s3 & (1 << -nBits) - 1, s3 >>= -nBits, nBits += eLen;
  for (;nBits > 0; e = e * 256 + buffer[offset + i4], i4 += d3, nBits -= 8)
    ;
  m2 = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen;
  for (;nBits > 0; m2 = m2 * 256 + buffer[offset + i4], i4 += d3, nBits -= 8)
    ;
  if (e === 0)
    e = 1 - eBias;
  else if (e === eMax)
    return m2 ? NaN : (s3 ? -1 : 1) * (1 / 0);
  else
    m2 = m2 + Math.pow(2, mLen), e = e - eBias;
  return (s3 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m2, c2, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i4 = isLE ? 0 : nBytes - 1, d3 = isLE ? 1 : -1, s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  if (value = Math.abs(value), isNaN(value) || value === 1 / 0)
    m2 = isNaN(value) ? 1 : 0, e = eMax;
  else {
    if (e = Math.floor(Math.log(value) / Math.LN2), value * (c2 = Math.pow(2, -e)) < 1)
      e--, c2 *= 2;
    if (e + eBias >= 1)
      value += rt2 / c2;
    else
      value += rt2 * Math.pow(2, 1 - eBias);
    if (value * c2 >= 2)
      e++, c2 /= 2;
    if (e + eBias >= eMax)
      m2 = 0, e = eMax;
    else if (e + eBias >= 1)
      m2 = (value * c2 - 1) * Math.pow(2, mLen), e = e + eBias;
    else
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0;
  }
  for (;mLen >= 8; buffer[offset + i4] = m2 & 255, i4 += d3, m2 /= 256, mLen -= 8)
    ;
  e = e << mLen | m2, eLen += mLen;
  for (;eLen > 0; buffer[offset + i4] = e & 255, i4 += d3, e /= 256, eLen -= 8)
    ;
  buffer[offset + i4 - d3] |= s3 * 128;
}
function createBuffer(length) {
  if (length > kMaxLength)
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  let buf = new Uint8Array(length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function E2(sym, getMessage, Base) {
  return class NodeError extends Base {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: getMessage.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string")
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
function from(value, encodingOrOffset, length) {
  if (typeof value === "string")
    return fromString(value, encodingOrOffset);
  if (ArrayBuffer.isView(value))
    return fromArrayView(value);
  if (value == null)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof value === "number")
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  let valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value)
    return Buffer2.from(valueOf, encodingOrOffset, length);
  let b3 = fromObject(value);
  if (b3)
    return b3;
  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function")
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
function assertSize(size) {
  if (typeof size !== "number")
    throw new TypeError('"size" argument must be of type number');
  else if (size < 0)
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
  if (assertSize(size), size <= 0)
    return createBuffer(size);
  if (fill !== undefined)
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  return createBuffer(size);
}
function allocUnsafe(size) {
  return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
}
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "")
    encoding = "utf8";
  if (!Buffer2.isEncoding(encoding))
    throw new TypeError("Unknown encoding: " + encoding);
  let length = byteLength(string, encoding) | 0, buf = createBuffer(length), actual = buf.write(string, encoding);
  if (actual !== length)
    buf = buf.slice(0, actual);
  return buf;
}
function fromArrayLike(array) {
  let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
  for (let i4 = 0;i4 < length; i4 += 1)
    buf[i4] = array[i4] & 255;
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    let copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (array.byteLength < byteOffset + (length || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  let buf;
  if (byteOffset === undefined && length === undefined)
    buf = new Uint8Array(array);
  else if (length === undefined)
    buf = new Uint8Array(array, byteOffset);
  else
    buf = new Uint8Array(array, byteOffset, length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function fromObject(obj) {
  if (Buffer2.isBuffer(obj)) {
    let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
    if (buf.length === 0)
      return buf;
    return obj.copy(buf, 0, 0, len2), buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || numberIsNaN(obj.length))
      return createBuffer(0);
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data))
    return fromArrayLike(obj.data);
}
function checked(length) {
  if (length >= kMaxLength)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  return length | 0;
}
function byteLength(string, encoding) {
  if (Buffer2.isBuffer(string))
    return string.length;
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
    return string.byteLength;
  if (typeof string !== "string")
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  let len2 = string.length, mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len2 === 0)
    return 0;
  let loweredCase = false;
  for (;; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len2;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len2 * 2;
      case "hex":
        return len2 >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return mustMatch ? -1 : utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = true;
    }
}
function slowToString(encoding, start2, end) {
  let loweredCase = false;
  if (start2 === undefined || start2 < 0)
    start2 = 0;
  if (start2 > this.length)
    return "";
  if (end === undefined || end > this.length)
    end = this.length;
  if (end <= 0)
    return "";
  if (end >>>= 0, start2 >>>= 0, end <= start2)
    return "";
  if (!encoding)
    encoding = "utf8";
  while (true)
    switch (encoding) {
      case "hex":
        return hexSlice(this, start2, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start2, end);
      case "ascii":
        return asciiSlice(this, start2, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start2, end);
      case "base64":
        return base64Slice(this, start2, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start2, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = true;
    }
}
function swap(b3, n2, m2) {
  let i4 = b3[n2];
  b3[n2] = b3[m2], b3[m2] = i4;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string")
    encoding = byteOffset, byteOffset = 0;
  else if (byteOffset > 2147483647)
    byteOffset = 2147483647;
  else if (byteOffset < -2147483648)
    byteOffset = -2147483648;
  if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
    byteOffset = dir ? 0 : buffer.length - 1;
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length)
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val === "string")
    val = Buffer2.from(val, encoding);
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0)
      return -1;
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
      if (dir)
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      else
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== undefined) {
    if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2)
        return -1;
      indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
    }
  }
  function read2(buf, i22) {
    if (indexSize === 1)
      return buf[i22];
    else
      return buf.readUInt16BE(i22 * indexSize);
  }
  let i4;
  if (dir) {
    let foundIndex = -1;
    for (i4 = byteOffset;i4 < arrLength; i4++)
      if (read2(arr, i4) === read2(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i4 = byteOffset;i4 >= 0; i4--) {
      let found = true;
      for (let j2 = 0;j2 < valLength; j2++)
        if (read2(arr, i4 + j2) !== read2(val, j2)) {
          found = false;
          break;
        }
      if (found)
        return i4;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  let remaining = buf.length - offset;
  if (!length)
    length = remaining;
  else if (length = Number(length), length > remaining)
    length = remaining;
  let strLen = string.length;
  if (length > strLen / 2)
    length = strLen / 2;
  let i4;
  for (i4 = 0;i4 < length; ++i4) {
    let parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (numberIsNaN(parsed))
      return i4;
    buf[offset + i4] = parsed;
  }
  return i4;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start2, end) {
  if (start2 === 0 && end === buf.length)
    return fromByteArray(buf);
  else
    return fromByteArray(buf.slice(start2, end));
}
function utf8Slice(buf, start2, end) {
  end = Math.min(buf.length, end);
  let res = [], i4 = start2;
  while (i4 < end) {
    let firstByte = buf[i4], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128)
            codePoint = firstByte;
          break;
        case 2:
          if (secondByte = buf[i4 + 1], (secondByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
              codePoint = tempCodePoint;
          }
          break;
        case 3:
          if (secondByte = buf[i4 + 1], thirdByte = buf[i4 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
              codePoint = tempCodePoint;
          }
          break;
        case 4:
          if (secondByte = buf[i4 + 1], thirdByte = buf[i4 + 2], fourthByte = buf[i4 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
              codePoint = tempCodePoint;
          }
      }
    }
    if (codePoint === null)
      codePoint = 65533, bytesPerSequence = 1;
    else if (codePoint > 65535)
      codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
    res.push(codePoint), i4 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  let len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  let res = "", i4 = 0;
  while (i4 < len2)
    res += String.fromCharCode.apply(String, codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH));
  return res;
}
function asciiSlice(buf, start2, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i4 = start2;i4 < end; ++i4)
    ret += String.fromCharCode(buf[i4] & 127);
  return ret;
}
function latin1Slice(buf, start2, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i4 = start2;i4 < end; ++i4)
    ret += String.fromCharCode(buf[i4]);
  return ret;
}
function hexSlice(buf, start2, end) {
  let len2 = buf.length;
  if (!start2 || start2 < 0)
    start2 = 0;
  if (!end || end < 0 || end > len2)
    end = len2;
  let out2 = "";
  for (let i4 = start2;i4 < end; ++i4)
    out2 += hexSliceLookupTable[buf[i4]];
  return out2;
}
function utf16leSlice(buf, start2, end) {
  let bytes = buf.slice(start2, end), res = "";
  for (let i4 = 0;i4 < bytes.length - 1; i4 += 2)
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer2.isBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset + 3] = hi, hi = hi >> 8, buf[offset + 2] = hi, hi = hi >> 8, buf[offset + 1] = hi, hi = hi >> 8, buf[offset] = hi, offset + 8;
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  return write(buf, value, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  return write(buf, value, offset, littleEndian, 52, 8), offset + 8;
}
function addNumericalSeparator(val) {
  let res = "", i4 = val.length, start2 = val[0] === "-" ? 1 : 0;
  for (;i4 >= start2 + 4; i4 -= 3)
    res = `_${val.slice(i4 - 3, i4)}${res}`;
  return `${val.slice(0, i4)}${res}`;
}
function checkBounds(buf, offset, byteLength2) {
  if (validateNumber(offset, "offset"), buf[offset] === undefined || buf[offset + byteLength2] === undefined)
    boundsError(offset, buf.length - (byteLength2 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
  if (value > max || value < min) {
    let n2 = typeof min === "bigint" ? "n" : "", range;
    if (byteLength2 > 3)
      if (min === 0 || min === BigInt(0))
        range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
      else
        range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
    else
      range = `>= ${min}${n2} and <= ${max}${n2}`;
    throw new ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength2);
}
function validateNumber(value, name2) {
  if (typeof value !== "number")
    throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value)
    throw validateNumber(value, type), new ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  if (length < 0)
    throw new ERR_BUFFER_OUT_OF_BOUNDS;
  throw new ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function base64clean(str) {
  if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  while (str.length % 4 !== 0)
    str = str + "=";
  return str;
}
function utf8ToBytes(string, units) {
  units = units || 1 / 0;
  let codePoint, length = string.length, leadSurrogate = null, bytes = [];
  for (let i4 = 0;i4 < length; ++i4) {
    if (codePoint = string.charCodeAt(i4), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str) {
  let byteArray = [];
  for (let i4 = 0;i4 < str.length; ++i4)
    byteArray.push(str.charCodeAt(i4) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c2, hi, lo, byteArray = [];
  for (let i4 = 0;i4 < str.length; ++i4) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i4), hi = c2 >> 8, lo = c2 % 256, byteArray.push(lo), byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  let i4;
  for (i4 = 0;i4 < length; ++i4) {
    if (i4 + offset >= dst.length || i4 >= src.length)
      break;
    dst[i4 + offset] = src[i4];
  }
  return i4;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function defineBigIntMethod(fn2) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
function notimpl(name2) {
  return () => {
    throw new Error(name2 + " is not implemented for node:buffer browser polyfill");
  };
}
var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i3, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa, atob, File2, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
  for (let char of str)
    if (char.charCodeAt(0) > 127)
      return false;
  return true;
}, transcode, buffer_default;
var init_buffer = __esm(() => {
  lookup = [];
  revLookup = [];
  for (i3 = 0, len = code.length;i3 < len; ++i3)
    lookup[i3] = code[i3], revLookup[code.charCodeAt(i3)] = i3;
  revLookup[45] = 62;
  revLookup[95] = 63;
  customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  btoa = globalThis.btoa;
  atob = globalThis.atob;
  File2 = globalThis.File;
  Blob2 = globalThis.Blob;
  constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
  ERR_BUFFER_OUT_OF_BOUNDS = E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2)
      return `${name2} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  ERR_INVALID_ARG_TYPE = E2("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  ERR_OUT_OF_RANGE = E2("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`, received = input;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
        received = addNumericalSeparator(received);
      received += "n";
    }
    return msg += ` It must be ${range}. Received ${received}`, msg;
  }, RangeError);
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  } });
  Buffer2.poolSize = 8192;
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.isBuffer = function isBuffer2(b3) {
    return b3 != null && b3._isBuffer === true && b3 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b3) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b3, Uint8Array))
      b3 = Buffer2.from(b3, b3.offset, b3.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b3))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a2 === b3)
      return 0;
    let x3 = a2.length, y2 = b3.length;
    for (let i4 = 0, len2 = Math.min(x3, y2);i4 < len2; ++i4)
      if (a2[i4] !== b3[i4]) {
        x3 = a2[i4], y2 = b3[i4];
        break;
      }
    if (x3 < y2)
      return -1;
    if (y2 < x3)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0)
      return Buffer2.alloc(0);
    let i4;
    if (length === undefined) {
      length = 0;
      for (i4 = 0;i4 < list.length; ++i4)
        length += list[i4].length;
    }
    let buffer = Buffer2.allocUnsafe(length), pos = 0;
    for (i4 = 0;i4 < list.length; ++i4) {
      let buf = list[i4];
      if (isInstance(buf, Uint8Array))
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else
          Uint8Array.prototype.set.call(buffer, buf, pos);
      else if (!Buffer2.isBuffer(buf))
        throw new TypeError('"list" argument must be an Array of Buffers');
      else
        buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.prototype.swap16 = function swap16() {
    let len2 = this.length;
    if (len2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let i4 = 0;i4 < len2; i4 += 2)
      swap(this, i4, i4 + 1);
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    let len2 = this.length;
    if (len2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let i4 = 0;i4 < len2; i4 += 4)
      swap(this, i4, i4 + 3), swap(this, i4 + 1, i4 + 2);
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    let len2 = this.length;
    if (len2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let i4 = 0;i4 < len2; i4 += 8)
      swap(this, i4, i4 + 7), swap(this, i4 + 1, i4 + 6), swap(this, i4 + 2, i4 + 5), swap(this, i4 + 3, i4 + 4);
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    let length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b3) {
    if (!Buffer2.isBuffer(b3))
      throw new TypeError("Argument must be a Buffer");
    if (this === b3)
      return true;
    return Buffer2.compare(this, b3) === 0;
  };
  Buffer2.prototype.inspect = function inspect3() {
    let str = "", max = exports_buffer.INSPECT_MAX_BYTES;
    if (str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol)
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  Buffer2.prototype.compare = function compare2(target, start2, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array))
      target = Buffer2.from(target, target.offset, target.byteLength);
    if (!Buffer2.isBuffer(target))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start2 === undefined)
      start2 = 0;
    if (end === undefined)
      end = target ? target.length : 0;
    if (thisStart === undefined)
      thisStart = 0;
    if (thisEnd === undefined)
      thisEnd = this.length;
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
      throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start2 >= end)
      return 0;
    if (thisStart >= thisEnd)
      return -1;
    if (start2 >= end)
      return 1;
    if (start2 >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
      return 0;
    let x3 = thisEnd - thisStart, y2 = end - start2, len2 = Math.min(x3, y2), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start2, end);
    for (let i4 = 0;i4 < len2; ++i4)
      if (thisCopy[i4] !== targetCopy[i4]) {
        x3 = thisCopy[i4], y2 = targetCopy[i4];
        break;
      }
    if (x3 < y2)
      return -1;
    if (y2 < x3)
      return 1;
    return 0;
  };
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  Buffer2.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === undefined)
      encoding = "utf8", length = this.length, offset = 0;
    else if (length === undefined && typeof offset === "string")
      encoding = offset, length = this.length, offset = 0;
    else if (isFinite(offset))
      if (offset = offset >>> 0, isFinite(length)) {
        if (length = length >>> 0, encoding === undefined)
          encoding = "utf8";
      } else
        encoding = length, length = undefined;
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  Buffer2.prototype.slice = function slice(start2, end) {
    let len2 = this.length;
    if (start2 = ~~start2, end = end === undefined ? len2 : ~~end, start2 < 0) {
      if (start2 += len2, start2 < 0)
        start2 = 0;
    } else if (start2 > len2)
      start2 = len2;
    if (end < 0) {
      if (end += len2, end < 0)
        end = 0;
    } else if (end > len2)
      end = len2;
    if (end < start2)
      end = start2;
    let newBuf = this.subarray(start2, end);
    return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
  };
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i4 = 0;
    while (++i4 < byteLength2 && (mul *= 256))
      val += this[offset + i4] * mul;
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2], mul = 1;
    while (byteLength2 > 0 && (mul *= 256))
      val += this[offset + --byteLength2] * mul;
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216, hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 16777216;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let hi = first * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset], lo = this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i4 = 0;
    while (++i4 < byteLength2 && (mul *= 256))
      val += this[offset + i4] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i4 = byteLength2, mul = 1, val = this[offset + --i4];
    while (i4 > 0 && (mul *= 256))
      val += this[offset + --i4] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1, i4 = 0;
    this[offset] = value & 255;
    while (++i4 < byteLength2 && (mul *= 256))
      this[offset + i4] = value / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i4 = byteLength2 - 1, mul = 1;
    this[offset + i4] = value & 255;
    while (--i4 >= 0 && (mul *= 256))
      this[offset + i4] = value / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i4 = 0, mul = 1, sub = 0;
    this[offset] = value & 255;
    while (++i4 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i4 - 1] !== 0)
        sub = 1;
      this[offset + i4] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i4 = byteLength2 - 1, mul = 1, sub = 0;
    this[offset + i4] = value & 255;
    while (--i4 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i4 + 1] !== 0)
        sub = 1;
      this[offset + i4] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start2, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start2)
      start2 = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start2)
      end = start2;
    if (end === start2)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0)
      throw new RangeError("targetStart out of bounds");
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start2)
      end = target.length - targetStart + start2;
    let len2 = end - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
      this.copyWithin(targetStart, start2, end);
    else
      Uint8Array.prototype.set.call(target, this.subarray(start2, end), targetStart);
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string")
        encoding = start2, start2 = 0, end = this.length;
      else if (typeof end === "string")
        encoding = end, end = this.length;
      if (encoding !== undefined && typeof encoding !== "string")
        throw new TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
        throw new TypeError("Unknown encoding: " + encoding);
      if (val.length === 1) {
        let code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
          val = code2;
      }
    } else if (typeof val === "number")
      val = val & 255;
    else if (typeof val === "boolean")
      val = Number(val);
    if (start2 < 0 || this.length < start2 || this.length < end)
      throw new RangeError("Out of range index");
    if (end <= start2)
      return this;
    if (start2 = start2 >>> 0, end = end === undefined ? this.length : end >>> 0, !val)
      val = 0;
    let i4;
    if (typeof val === "number")
      for (i4 = start2;i4 < end; ++i4)
        this[i4] = val;
    else {
      let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes.length;
      if (len2 === 0)
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      for (i4 = 0;i4 < end - start2; ++i4)
        this[i4 + start2] = bytes[i4 % len2];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  hexSliceLookupTable = function() {
    let table = new Array(256);
    for (let i4 = 0;i4 < 16; ++i4) {
      let i16 = i4 * 16;
      for (let j2 = 0;j2 < 16; ++j2)
        table[i16 + j2] = "0123456789abcdef"[i4] + "0123456789abcdef"[j2];
    }
    return table;
  }();
  resolveObjectURL = notimpl("resolveObjectURL");
  isUtf8 = notimpl("isUtf8");
  transcode = notimpl("transcode");
  buffer_default = Buffer2;
});

// node:events
var exports_events = {};
__export(exports_events, {
  setMaxListeners: () => setMaxListeners2,
  once: () => once2,
  listenerCount: () => listenerCount2,
  init: () => EventEmitter,
  getMaxListeners: () => getMaxListeners2,
  getEventListeners: () => getEventListeners,
  default: () => events_default,
  captureRejectionSymbol: () => captureRejectionSymbol,
  addAbortListener: () => addAbortListener,
  EventEmitter: () => EventEmitter
});
function emitError(emitter, args2) {
  var { _events: events } = emitter;
  if (args2[0] ??= new Error("Unhandled error."), !events)
    throw args2[0];
  var errorMonitor = events[kErrorMonitor];
  if (errorMonitor)
    for (var handler of ArrayPrototypeSlice.call(errorMonitor))
      handler.apply(emitter, args2);
  var handlers = events.error;
  if (!handlers)
    throw args2[0];
  for (var handler of ArrayPrototypeSlice.call(handlers))
    handler.apply(emitter, args2);
  return true;
}
function addCatch(emitter, promise, type, args2) {
  promise.then(undefined, function(err2) {
    queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err2, type, args2));
  });
}
function emitUnhandledRejectionOrErr(emitter, err2, type, args2) {
  if (typeof emitter[kRejection] === "function")
    emitter[kRejection](err2, type, ...args2);
  else
    try {
      emitter[kCapture] = false, emitter.emit("error", err2);
    } finally {
      emitter[kCapture] = true;
    }
}
function overflowWarning(emitter, type, handlers) {
  handlers.warned = true;
  let warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, console.warn(warn);
}
function onceWrapper(type, listener, ...args2) {
  this.removeListener(type, listener), listener.apply(this, args2);
}
function once2(emitter, type, options) {
  var signal = options?.signal;
  if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  let { resolve, reject, promise } = $newPromiseCapability(Promise), errorListener = (err2) => {
    if (emitter.removeListener(type, resolver), signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    reject(err2);
  }, resolver = (...args2) => {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener("error", errorListener);
    if (signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    resolve(args2);
  };
  if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: true }), type !== "error" && typeof emitter.once === "function")
    emitter.once("error", errorListener);
  function abortListener() {
    eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
  }
  if (signal != null)
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  return promise;
}
function getEventListeners(emitter, type) {
  return emitter.listeners(type);
}
function setMaxListeners2(n2, ...eventTargets) {
  validateNumber2(n2, "setMaxListeners", 0);
  var length;
  if (eventTargets && (length = eventTargets.length))
    for (let i4 = 0;i4 < length; i4++)
      eventTargets[i4].setMaxListeners(n2);
  else
    defaultMaxListeners = n2;
}
function listenerCount2(emitter, type) {
  return emitter.listenerCount(type);
}
function eventTargetAgnosticRemoveListener(emitter, name2, listener, flags2) {
  if (typeof emitter.removeListener === "function")
    emitter.removeListener(name2, listener);
  else
    emitter.removeEventListener(name2, listener, flags2);
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags2) {
  if (typeof emitter.on === "function")
    if (flags2.once)
      emitter.once(name2, listener);
    else
      emitter.on(name2, listener);
  else
    emitter.addEventListener(name2, listener, flags2);
}
function ERR_INVALID_ARG_TYPE2(name2, type, value) {
  let err2 = new TypeError(`The "${name2}" argument must be of type ${type}. Received ${value}`);
  return err2.code = "ERR_INVALID_ARG_TYPE", err2;
}
function ERR_OUT_OF_RANGE2(name2, range, value) {
  let err2 = new RangeError(`The "${name2}" argument is out of range. It must be ${range}. Received ${value}`);
  return err2.code = "ERR_OUT_OF_RANGE", err2;
}
function validateAbortSignal(signal, name2) {
  if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
    throw ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
}
function validateNumber2(value, name2, min, max) {
  if (typeof value !== "number")
    throw ERR_INVALID_ARG_TYPE2(name2, "number", value);
  if (min != null && value < min || max != null && value > max || (min != null || max != null) && Number.isNaN(value))
    throw ERR_OUT_OF_RANGE2(name2, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
}
function checkListener(listener) {
  if (typeof listener !== "function")
    throw new TypeError("The listener must be a function");
}
function validateBoolean(value, name2) {
  if (typeof value !== "boolean")
    throw ERR_INVALID_ARG_TYPE2(name2, "boolean", value);
}
function getMaxListeners2(emitterOrTarget) {
  return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
}
function addAbortListener(signal, listener) {
  if (signal === undefined)
    throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
  if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
    throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
  let removeEventListener;
  if (signal.aborted)
    queueMicrotask(() => listener());
  else
    signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
      signal.removeEventListener("abort", listener);
    };
  return { __proto__: null, [Symbol.dispose]() {
    removeEventListener?.();
  } };
}
var SymbolFor, kCapture, kErrorMonitor, kMaxEventTargetListeners, kMaxEventTargetListenersWarned, kRejection, captureRejectionSymbol, ArrayPrototypeSlice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {
  if (this._events === undefined || this._events === this.__proto__._events)
    this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
    this.emit = emitWithRejectionCapture;
}, EventEmitterPrototype, emitWithoutRejectionCapture = function emit(type, ...args2) {
  if (type === "error")
    return emitError(this, args2);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i4 = 0, { length } = maybeClonedHandlers;i4 < length; i4++) {
    let handler = maybeClonedHandlers[i4];
    switch (args2.length) {
      case 0:
        handler.call(this);
        break;
      case 1:
        handler.call(this, args2[0]);
        break;
      case 2:
        handler.call(this, args2[0], args2[1]);
        break;
      case 3:
        handler.call(this, args2[0], args2[1], args2[2]);
        break;
      default:
        handler.apply(this, args2);
        break;
    }
  }
  return true;
}, emitWithRejectionCapture = function emit2(type, ...args2) {
  if (type === "error")
    return emitError(this, args2);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i4 = 0, { length } = maybeClonedHandlers;i4 < length; i4++) {
    let handler = maybeClonedHandlers[i4], result;
    switch (args2.length) {
      case 0:
        result = handler.call(this);
        break;
      case 1:
        result = handler.call(this, args2[0]);
        break;
      case 2:
        result = handler.call(this, args2[0], args2[1]);
        break;
      case 3:
        result = handler.call(this, args2[0], args2[1], args2[2]);
        break;
      default:
        result = handler.apply(this, args2);
        break;
    }
    if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
      addCatch(this, result, type, args2);
  }
  return true;
}, AbortError, events_default;
var init_events = __esm(() => {
  SymbolFor = Symbol.for;
  kCapture = Symbol("kCapture");
  kErrorMonitor = SymbolFor("events.errorMonitor");
  kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
  kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
  kRejection = SymbolFor("nodejs.rejection");
  captureRejectionSymbol = SymbolFor("nodejs.rejection");
  ArrayPrototypeSlice = Array.prototype.slice;
  EventEmitterPrototype = EventEmitter.prototype = {};
  EventEmitterPrototype._events = undefined;
  EventEmitterPrototype._eventsCount = 0;
  EventEmitterPrototype._maxListeners = undefined;
  EventEmitterPrototype.setMaxListeners = function setMaxListeners(n2) {
    return validateNumber2(n2, "setMaxListeners", 0), this._maxListeners = n2, this;
  };
  EventEmitterPrototype.constructor = EventEmitter;
  EventEmitterPrototype.getMaxListeners = function getMaxListeners() {
    return this?._maxListeners ?? defaultMaxListeners;
  };
  EventEmitterPrototype.emit = emitWithoutRejectionCapture;
  EventEmitterPrototype.addListener = function addListener(type, fn2) {
    checkListener(fn2);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn2.listener ?? fn2);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn2], this._eventsCount++;
    else {
      handlers.push(fn2);
      var m2 = this._maxListeners ?? defaultMaxListeners;
      if (m2 > 0 && handlers.length > m2 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.on = EventEmitterPrototype.addListener;
  EventEmitterPrototype.prependListener = function prependListener(type, fn2) {
    checkListener(fn2);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn2.listener ?? fn2);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn2], this._eventsCount++;
    else {
      handlers.unshift(fn2);
      var m2 = this._maxListeners ?? defaultMaxListeners;
      if (m2 > 0 && handlers.length > m2 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.once = function once(type, fn2) {
    checkListener(fn2);
    let bound = onceWrapper.bind(this, type, fn2);
    return bound.listener = fn2, this.addListener(type, bound), this;
  };
  EventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn2) {
    checkListener(fn2);
    let bound = onceWrapper.bind(this, type, fn2);
    return bound.listener = fn2, this.prependListener(type, bound), this;
  };
  EventEmitterPrototype.removeListener = function removeListener(type, fn2) {
    checkListener(fn2);
    var { _events: events } = this;
    if (!events)
      return this;
    var handlers = events[type];
    if (!handlers)
      return this;
    var length = handlers.length;
    let position = -1;
    for (let i4 = length - 1;i4 >= 0; i4--)
      if (handlers[i4] === fn2 || handlers[i4].listener === fn2) {
        position = i4;
        break;
      }
    if (position < 0)
      return this;
    if (position === 0)
      handlers.shift();
    else
      handlers.splice(position, 1);
    if (handlers.length === 0)
      delete events[type], this._eventsCount--;
    return this;
  };
  EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
  EventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {
    var { _events: events } = this;
    if (type && events) {
      if (events[type])
        delete events[type], this._eventsCount--;
    } else
      this._events = { __proto__: null };
    return this;
  };
  EventEmitterPrototype.listeners = function listeners(type) {
    var { _events: events } = this;
    if (!events)
      return [];
    var handlers = events[type];
    if (!handlers)
      return [];
    return handlers.map((x3) => x3.listener ?? x3);
  };
  EventEmitterPrototype.rawListeners = function rawListeners(type) {
    var { _events } = this;
    if (!_events)
      return [];
    var handlers = _events[type];
    if (!handlers)
      return [];
    return handlers.slice();
  };
  EventEmitterPrototype.listenerCount = function listenerCount(type) {
    var { _events: events } = this;
    if (!events)
      return 0;
    return events[type]?.length ?? 0;
  };
  EventEmitterPrototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  EventEmitterPrototype[kCapture] = false;
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object")
        throw ERR_INVALID_ARG_TYPE2("options", "Object", options);
      super(message, options);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  Object.defineProperties(EventEmitter, { captureRejections: { get() {
    return EventEmitterPrototype[kCapture];
  }, set(value) {
    validateBoolean(value, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
    return defaultMaxListeners;
  }, set: (arg) => {
    validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
  } }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
  Object.assign(EventEmitter, { once: once2, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter, listenerCount: listenerCount2 });
  events_default = EventEmitter;
});

// node:process
var exports_process = {};
__export(exports_process, {
  versions: () => versions,
  version: () => version,
  umask: () => umask,
  title: () => title,
  removeListener: () => removeListener2,
  removeAllListeners: () => removeAllListeners2,
  prependOnceListener: () => prependOnceListener2,
  prependListener: () => prependListener2,
  once: () => once3,
  on: () => on2,
  off: () => off,
  nextTick: () => nextTick,
  listeners: () => listeners2,
  env: () => env,
  emit: () => emit3,
  cwd: () => cwd,
  chdir: () => chdir,
  browser: () => browser,
  binding: () => binding,
  argv: () => argv,
  addListener: () => addListener2
});
function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;
  if (draining = false, currentQueue.length)
    queue = currentQueue.concat(queue);
  else
    queueIndex = -1;
  if (queue.length)
    drainQueue();
}
function drainQueue() {
  if (draining)
    return;
  var timeout = setTimeout(cleanUpNextTick, 0);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue, queue = [];
    while (++queueIndex < len2)
      if (currentQueue) {
        var item = currentQueue[queueIndex];
        item.fun.apply(null, item.array);
      }
    queueIndex = -1, len2 = queue.length;
  }
  currentQueue = null, draining = false, clearTimeout(timeout, 0);
}
function nextTick(fun) {
  var args2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var i4 = 1;i4 < arguments.length; i4++)
      args2[i4 - 1] = arguments[i4];
  if (queue.push({ fun, args: args2 }), queue.length === 1 && !draining)
    setTimeout(drainQueue, 0);
}
function noop() {}
var queue, draining = false, currentQueue, queueIndex = -1, title = "browser", browser = true, env, argv, version = "", versions, on2, addListener2, once3, off, removeListener2, removeAllListeners2, emit3, prependListener2, prependOnceListener2, listeners2 = function(name2) {
  return [];
}, binding = function(name2) {
  throw new Error("process.binding is not supported in browser polyfill");
}, cwd = function() {
  return "/";
}, chdir = function(dir) {
  throw new Error("process.chdir is not supported in browser polyfill");
}, umask = function() {
  return 0;
};
var init_process = __esm(() => {
  queue = [];
  env = {};
  argv = [];
  versions = {};
  on2 = noop;
  addListener2 = noop;
  once3 = noop;
  off = noop;
  removeListener2 = noop;
  removeAllListeners2 = noop;
  emit3 = noop;
  prependListener2 = noop;
  prependOnceListener2 = noop;
});

// node:stream
var require_stream = __commonJS((exports, module2) => {
  var __commonJS3 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
  var require_primordials = __commonJS3((exports2, module22) => {

    class AggregateError2 extends Error {
      constructor(errors) {
        if (!Array.isArray(errors))
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        let message = "";
        for (let i4 = 0;i4 < errors.length; i4++)
          message += `    ${errors[i4].stack}
`;
        super(message);
        this.name = "AggregateError", this.errors = errors;
      }
    }
    module22.exports = { AggregateError: AggregateError2, ArrayIsArray(self2) {
      return Array.isArray(self2);
    }, ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    }, ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    }, ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    }, ArrayPrototypeMap(self2, fn2) {
      return self2.map(fn2);
    }, ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    }, ArrayPrototypePush(self2, el) {
      return self2.push(el);
    }, ArrayPrototypeSlice(self2, start2, end) {
      return self2.slice(start2, end);
    }, Error, FunctionPrototypeCall(fn2, thisArgs, ...args2) {
      return fn2.call(thisArgs, ...args2);
    }, FunctionPrototypeSymbolHasInstance(self2, instance2) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance2);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    }, ObjectDefineProperty(self2, name2, prop) {
      return Object.defineProperty(self2, name2, prop);
    }, ObjectGetOwnPropertyDescriptor(self2, name2) {
      return Object.getOwnPropertyDescriptor(self2, name2);
    }, ObjectKeys(obj) {
      return Object.keys(obj);
    }, ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    }, Promise, PromisePrototypeCatch(self2, fn2) {
      return self2.catch(fn2);
    }, PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    }, PromiseReject(err2) {
      return Promise.reject(err2);
    }, PromiseResolve(val) {
      return Promise.resolve(val);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    }, SafeSet: Set, String, StringPrototypeSlice(self2, start2, end) {
      return self2.slice(start2, end);
    }, StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    }, StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    }, StringPrototypeTrim(self2) {
      return self2.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(self2, buf, len2) {
      return self2.set(buf, len2);
    }, Boolean, Uint8Array };
  });
  var require_inspect = __commonJS3((exports2, module22) => {
    module22.exports = { format(format2, ...args2) {
      return format2.replace(/%([sdifj])/g, function(...[_unused, type]) {
        let replacement = args2.shift();
        if (type === "f")
          return replacement.toFixed(6);
        else if (type === "j")
          return JSON.stringify(replacement);
        else if (type === "s" && typeof replacement === "object")
          return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
        else
          return replacement.toString();
      });
    }, inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"'))
              return `"${value}"`;
            else if (!value.includes("`") && !value.includes("${"))
              return `\`${value}\``;
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value))
            return "NaN";
          else if (Object.is(value, -0))
            return String(value);
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    } };
  });
  var require_errors2 = __commonJS3((exports2, module22) => {
    var { format: format2, inspect: inspect4 } = require_inspect(), { AggregateError: CustomAggregateError } = require_primordials(), AggregateError2 = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
    function assert3(value, message) {
      if (!value)
        throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
    function addNumericalSeparator2(val) {
      let res = "", i4 = val.length, start2 = val[0] === "-" ? 1 : 0;
      for (;i4 >= start2 + 4; i4 -= 3)
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      return `${val.slice(0, i4)}${res}`;
    }
    function getMessage(key, msg, args2) {
      if (typeof msg === "function")
        return assert3(msg.length <= args2.length, `Code: ${key}; The provided arguments length (${args2.length}) does not match the required ones (${msg.length}).`), msg(...args2);
      let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      if (assert3(expectedLength === args2.length, `Code: ${key}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), args2.length === 0)
        return msg;
      return format2(msg, ...args2);
    }
    function E3(code2, message, Base) {
      if (!Base)
        Base = Error;

      class NodeError extends Base {
        constructor(...args2) {
          super(getMessage(code2, message, args2));
        }
        toString() {
          return `${this.name} [${code2}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, { name: { value: Base.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${code2}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), NodeError.prototype.code = code2, NodeError.prototype[kIsNodeError] = true, codes[code2] = NodeError;
    }
    function hideStackFrames(fn2) {
      let hidden = "__node_internal_" + fn2.name;
      return Object.defineProperty(fn2, "name", { value: hidden }), fn2;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors))
          return outerError.errors.push(innerError), outerError;
        let err2 = new AggregateError2([outerError, innerError], outerError.message);
        return err2.code = outerError.code, err2;
      }
      return innerError || outerError;
    }

    class AbortError2 extends Error {
      constructor(message = "The operation was aborted", options = undefined) {
        if (options !== undefined && typeof options !== "object")
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        super(message, options);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    E3("ERR_ASSERTION", "%s", Error);
    E3("ERR_INVALID_ARG_TYPE", (name2, expected, actual) => {
      if (assert3(typeof name2 === "string", "'name' must be a string"), !Array.isArray(expected))
        expected = [expected];
      let msg = "The ";
      if (name2.endsWith(" argument"))
        msg += `${name2} `;
      else
        msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
      msg += "must be ";
      let types2 = [], instances = [], other = [];
      for (let value of expected)
        if (assert3(typeof value === "string", "All expected entries have to be of type string"), kTypes.includes(value))
          types2.push(value.toLowerCase());
        else if (classRegExp.test(value))
          instances.push(value);
        else
          assert3(value !== "object", 'The value "object" should be written as "Object"'), other.push(value);
      if (instances.length > 0) {
        let pos = types2.indexOf("object");
        if (pos !== -1)
          types2.splice(types2, pos, 1), instances.push("Object");
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            let last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0)
          msg += " or ";
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            let last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0)
          msg += " or ";
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0])
            msg += "an ";
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          let last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null)
        msg += `. Received ${actual}`;
      else if (typeof actual === "function" && actual.name)
        msg += `. Received function ${actual.name}`;
      else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name)
          msg += `. Received an instance of ${actual.constructor.name}`;
        else {
          let inspected = inspect4(actual, { depth: -1 });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect4(actual, { colors: false });
        if (inspected.length > 25)
          inspected = `${inspected.slice(0, 25)}...`;
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E3("ERR_INVALID_ARG_VALUE", (name2, value, reason = "is invalid") => {
      let inspected = inspect4(value);
      if (inspected.length > 128)
        inspected = inspected.slice(0, 128) + "...";
      return `The ${name2.includes(".") ? "property" : "argument"} '${name2}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E3("ERR_INVALID_RETURN_VALUE", (input, name2, value) => {
      var _value$constructor;
      let type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name2}" function but got ${type}.`;
    }, TypeError);
    E3("ERR_MISSING_ARGS", (...args2) => {
      assert3(args2.length > 0, "At least one arg needs to be specified");
      let msg, len2 = args2.length;
      switch (args2 = (Array.isArray(args2) ? args2 : [args2]).map((a2) => `"${a2}"`).join(" or "), len2) {
        case 1:
          msg += `The ${args2[0]} argument`;
          break;
        case 2:
          msg += `The ${args2[0]} and ${args2[1]} arguments`;
          break;
        default:
          {
            let last = args2.pop();
            msg += `The ${args2.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E3("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert3(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 4294967296)
        received = addNumericalSeparator2(String(input));
      else if (typeof input === "bigint") {
        received = String(input);
        let limit = BigInt(2) ** BigInt(32);
        if (input > limit || input < -limit)
          received = addNumericalSeparator2(received);
        received += "n";
      } else
        received = inspect4(input);
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module22.exports = { AbortError: AbortError2, aggregateTwoErrors: hideStackFrames(aggregateTwoErrors), hideStackFrames, codes };
  });
  var require_event_target_shim = __commonJS3((exports2, module22) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = new WeakMap, wrappers = new WeakMap;
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function")
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        return;
      }
      if (!data.event.cancelable)
        return;
      if (data.canceled = true, typeof data.event.preventDefault === "function")
        data.event.preventDefault();
    }
    function Event2(eventTarget, event) {
      privateData.set(this, { eventTarget, event, eventPhase: 2, currentTarget: eventTarget, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: event.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let keys = Object.keys(event);
      for (let i4 = 0;i4 < keys.length; ++i4) {
        let key = keys[i4];
        if (!(key in this))
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event2.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      let currentTarget = pd(this).currentTarget;
      if (currentTarget == null)
        return [];
      return [currentTarget];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      let data = pd(this);
      if (data.stopped = true, typeof data.event.stopPropagation === "function")
        data.event.stopPropagation();
    }, stopImmediatePropagation() {
      let data = pd(this);
      if (data.stopped = true, data.immediateStopped = true, typeof data.event.stopImmediatePropagation === "function")
        data.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(pd(this).event.bubbles);
    }, get cancelable() {
      return Boolean(pd(this).event.cancelable);
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return Boolean(pd(this).event.composed);
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(value) {
      if (!value)
        return;
      let data = pd(this);
      if (data.stopped = true, typeof data.event.cancelBubble === "boolean")
        data.event.cancelBubble = true;
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(value) {
      if (!value)
        setCancelFlag(pd(this));
    }, initEvent() {} };
    Object.defineProperty(Event2.prototype, "constructor", { value: Event2, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined")
      Object.setPrototypeOf(Event2.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event2);
    function defineRedirectDescriptor(key) {
      return { get() {
        return pd(this).event[key];
      }, set(value) {
        pd(this).event[key] = value;
      }, configurable: true, enumerable: true };
    }
    function defineCallDescriptor(key) {
      return { value() {
        let event = pd(this).event;
        return event[key].apply(event, arguments);
      }, configurable: true, enumerable: true };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: { value: CustomEvent, configurable: true, writable: true } });
      for (let i4 = 0;i4 < keys.length; ++i4) {
        let key = keys[i4];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event2;
      let wrapper = wrappers.get(proto);
      if (wrapper == null)
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper);
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject2(x3) {
      return x3 !== null && typeof x3 === "object";
    }
    function getListeners(eventTarget) {
      let listeners3 = listenersMap.get(eventTarget);
      if (listeners3 == null)
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      return listeners3;
    }
    function defineEventAttributeDescriptor(eventName) {
      return { get() {
        let node = getListeners(this).get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            return node.listener;
          node = node.next;
        }
        return null;
      }, set(listener) {
        if (typeof listener !== "function" && !isObject2(listener))
          listener = null;
        let listeners3 = getListeners(this), prev = null, node = listeners3.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners3.set(eventName, node.next);
            else
              listeners3.delete(eventName);
          else
            prev = node;
          node = node.next;
        }
        if (listener !== null) {
          let newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          if (prev === null)
            listeners3.set(eventName, newNode);
          else
            prev.next = newNode;
        }
      }, configurable: true, enumerable: true };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames2) {
      function CustomEventTarget() {
        EventTarget2.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget2.prototype, { constructor: { value: CustomEventTarget, configurable: true, writable: true } });
      for (let i4 = 0;i4 < eventNames2.length; ++i4)
        defineEventAttribute(CustomEventTarget.prototype, eventNames2[i4]);
      return CustomEventTarget;
    }
    function EventTarget2() {
      if (this instanceof EventTarget2) {
        listenersMap.set(this, new Map);
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types2 = new Array(arguments.length);
        for (let i4 = 0;i4 < arguments.length; ++i4)
          types2[i4] = arguments[i4];
        return defineCustomEventTarget(types2);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget2.prototype = { addEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      if (typeof listener !== "function" && !isObject2(listener))
        throw new TypeError("'listener' should be a function or an object.");
      let listeners3 = getListeners(this), optionsIsObj = isObject2(options), listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, newNode = { listener, listenerType, passive: optionsIsObj && Boolean(options.passive), once: optionsIsObj && Boolean(options.once), next: null }, node = listeners3.get(eventName);
      if (node === undefined) {
        listeners3.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType)
          return;
        prev = node, node = node.next;
      }
      prev.next = newNode;
    }, removeEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      let listeners3 = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners3.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners3.set(eventName, node.next);
          else
            listeners3.delete(eventName);
          return;
        }
        prev = node, node = node.next;
      }
    }, dispatchEvent(event) {
      if (event == null || typeof event.type !== "string")
        throw new TypeError('"event.type" should be a string.');
      let listeners3 = getListeners(this), eventName = event.type, node = listeners3.get(eventName);
      if (node == null)
        return true;
      let wrappedEvent = wrapEvent(this, event), prev = null;
      while (node != null) {
        if (node.once)
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners3.set(eventName, node.next);
          else
            listeners3.delete(eventName);
        else
          prev = node;
        if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err2) {
            if (typeof console !== "undefined" && typeof console.error === "function")
              console.error(err2);
          }
        else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
          node.listener.handleEvent(wrappedEvent);
        if (isStopped(wrappedEvent))
          break;
        node = node.next;
      }
      return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
    } };
    Object.defineProperty(EventTarget2.prototype, "constructor", { value: EventTarget2, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined")
      Object.setPrototypeOf(EventTarget2.prototype, window.EventTarget.prototype);
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget2;
    exports2.default = EventTarget2;
    module22.exports = EventTarget2;
    module22.exports.EventTarget = module22.exports.default = EventTarget2;
    module22.exports.defineEventAttribute = defineEventAttribute;
  });
  var require_abort_controller = __commonJS3((exports2, module22) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();

    class AbortSignal extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    }
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, false), signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false)
        return;
      abortedFlags.set(signal, true), signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = new WeakMap;
    Object.defineProperties(AbortSignal.prototype, { aborted: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });

    class AbortController {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    }
    var signals = new WeakMap;
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController.prototype, { signal: { enumerable: true }, abort: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    exports2.AbortController = AbortController;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController;
    module22.exports = AbortController;
    module22.exports.AbortController = module22.exports.default = AbortController;
    module22.exports.AbortSignal = AbortSignal;
  });
  var require_util2 = __commonJS3((exports2, module22) => {
    var bufferModule = (init_buffer(), __toCommonJS(exports_buffer2)), { format: format2, inspect: inspect4 } = require_inspect(), { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } } = require_errors2(), { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials(), AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b3) {
      return b3 instanceof Blob3;
    } : function isBlob(b3) {
      return false;
    }, validateAbortSignal2 = (signal, name2) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name2, "AbortSignal", signal);
    }, validateFunction = (value, name2) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name2, "Function", value);
    };
    module22.exports = { AggregateError: AggregateError2, kEmptyObject: Object.freeze({}), once(callback) {
      let called = false;
      return function(...args2) {
        if (called)
          return;
        called = true, callback.apply(this, args2);
      };
    }, createDeferredPromise: function() {
      let resolve, reject;
      return { promise: new Promise((res, rej) => {
        resolve = res, reject = rej;
      }), resolve, reject };
    }, promisify(fn2) {
      return new Promise((resolve, reject) => {
        fn2((err2, ...args2) => {
          if (err2)
            return reject(err2);
          return resolve(...args2);
        });
      });
    }, debuglog() {
      return function() {};
    }, format: format2, inspect: inspect4, types: { isAsyncFunction(fn2) {
      return fn2 instanceof AsyncFunction;
    }, isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr);
    } }, isBlob, deprecate(fn2, message) {
      return fn2;
    }, addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined)
        throw new ERR_INVALID_ARG_TYPE3("signal", "AbortSignal", signal);
      validateAbortSignal2(signal, "signal"), validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted)
        queueMicrotask(() => listener());
      else
        signal.addEventListener("abort", listener, { __proto__: null, once: true, [kResistStopPropagation]: true }), removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      return { __proto__: null, [SymbolDispose]() {
        var _removeEventListener;
        (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
      } };
    }, AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
      if (signals.length === 1)
        return signals[0];
      let ac = new AbortController, abort2 = () => ac.abort();
      return signals.forEach((signal) => {
        validateAbortSignal2(signal, "signals"), signal.addEventListener("abort", abort2, { once: true });
      }), ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort2));
      }, { once: true }), ac.signal;
    } };
    module22.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  var require_validators = __commonJS3((exports2, module22) => {
    var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String2, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials(), { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_UNKNOWN_SIGNAL } } = require_errors2(), { normalizeEncoding } = require_util2(), { isAsyncFunction, isArrayBufferView } = require_util2().types, signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name2, def) {
      if (typeof value === "undefined")
        value = def;
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null)
          throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
        value = NumberParseInt(value, 8);
      }
      return validateUint32(value, name2), value;
    }
    var validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name2, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name2, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name2, `>= ${min} && <= ${max}`, value);
    }), validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name2, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name2, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name2, `>= ${min} && <= ${max}`, value);
    }), validateUint32 = hideStackFrames((value, name2, positive = false) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name2, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name2, "an integer", value);
      let min = positive ? 1 : 0, max = 4294967295;
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name2, `>= ${min} && <= ${max}`, value);
    });
    function validateString(value, name2) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE3(name2, "string", value);
    }
    function validateNumber3(value, name2, min = undefined, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name2, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value))
        throw new ERR_OUT_OF_RANGE3(name2, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
    var validateOneOf = hideStackFrames((value, name2, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String2(v2)), ", ");
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateBoolean2(value, name2) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE3(name2, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name2, options = null) => {
      let allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false), allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function"))
        throw new ERR_INVALID_ARG_TYPE3(name2, "Object", value);
    }), validateDictionary = hideStackFrames((value, name2) => {
      if (value != null && typeof value !== "object" && typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name2, "a dictionary", value);
    }), validateArray = hideStackFrames((value, name2, minLength = 0) => {
      if (!ArrayIsArray(value))
        throw new ERR_INVALID_ARG_TYPE3(name2, "Array", value);
      if (value.length < minLength) {
        let reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateStringArray(value, name2) {
      validateArray(value, name2);
      for (let i4 = 0;i4 < value.length; i4++)
        validateString(value[i4], `${name2}[${i4}]`);
    }
    function validateBooleanArray(value, name2) {
      validateArray(value, name2);
      for (let i4 = 0;i4 < value.length; i4++)
        validateBoolean2(value[i4], `${name2}[${i4}]`);
    }
    function validateAbortSignalArray(value, name2) {
      validateArray(value, name2);
      for (let i4 = 0;i4 < value.length; i4++) {
        let signal = value[i4], indexedName = `${name2}[${i4}]`;
        if (signal == null)
          throw new ERR_INVALID_ARG_TYPE3(indexedName, "AbortSignal", signal);
        validateAbortSignal2(signal, indexedName);
      }
    }
    function validateSignalName(signal, name2 = "signal") {
      if (validateString(signal, name2), signals[signal] === undefined) {
        if (signals[StringPrototypeToUpperCase(signal)] !== undefined)
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name2 = "buffer") => {
      if (!isArrayBufferView(buffer))
        throw new ERR_INVALID_ARG_TYPE3(name2, ["Buffer", "TypedArray", "DataView"], buffer);
    });
    function validateEncoding(data, encoding) {
      let normalizedEncoding = normalizeEncoding(encoding), length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0)
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
    function validatePort(port, name2 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
        throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
      return port | 0;
    }
    var validateAbortSignal2 = hideStackFrames((signal, name2) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name2, "AbortSignal", signal);
    }), validateFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name2, "Function", value);
    }), validatePlainFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE3(name2, "Function", value);
    }), validateUndefined = hideStackFrames((value, name2) => {
      if (value !== undefined)
        throw new ERR_INVALID_ARG_TYPE3(name2, "undefined", value);
    });
    function validateUnion(value, name2, union) {
      if (!ArrayPrototypeIncludes(union, value))
        throw new ERR_INVALID_ARG_TYPE3(name2, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name2) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value))
        throw new ERR_INVALID_ARG_VALUE(name2, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string")
        return validateLinkHeaderFormat(hints, "hints"), hints;
      else if (ArrayIsArray(hints)) {
        let hintsLength = hints.length, result = "";
        if (hintsLength === 0)
          return result;
        for (let i4 = 0;i4 < hintsLength; i4++) {
          let link = hints[i4];
          if (validateLinkHeaderFormat(link, "hints"), result += link, i4 !== hintsLength - 1)
            result += ", ";
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module22.exports = { isInt32, isUint32, parseFileMode, validateArray, validateStringArray, validateBooleanArray, validateAbortSignalArray, validateBoolean: validateBoolean2, validateBuffer, validateDictionary, validateEncoding, validateFunction, validateInt32, validateInteger, validateNumber: validateNumber3, validateObject, validateOneOf, validatePlainFunction, validatePort, validateSignalName, validateString, validateUint32, validateUndefined, validateUnion, validateAbortSignal: validateAbortSignal2, validateLinkHeaderValue };
  });
  var require_process = __commonJS3((exports2, module22) => {
    module22.exports = (init_process(), __toCommonJS(exports_process));
  });
  var require_utils = __commonJS3((exports2, module22) => {
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor: SymbolFor2 } = require_primordials(), kIsDestroyed = SymbolFor2("nodejs.stream.destroyed"), kIsErrored = SymbolFor2("nodejs.stream.errored"), kIsReadable = SymbolFor2("nodejs.stream.readable"), kIsWritable = SymbolFor2("nodejs.stream.writable"), kIsDisturbed = SymbolFor2("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor2("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor2("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict2 = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict2 || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict2) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict2 === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      let rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict2) {
      if (!isReadableNodeStream(stream))
        return null;
      let rState = stream._readableState;
      if (rState !== null && rState !== undefined && rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict2 === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream))
        return null;
      if (isDestroyed(stream))
        return true;
      if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream))
        return false;
      if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream))
        return false;
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.writableErrored)
        return stream.writableErrored;
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.readableErrored)
        return stream.readableErrored;
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream))
        return null;
      if (typeof stream.closed === "boolean")
        return stream.closed;
      let { _writableState: wState, _readableState: rState } = stream;
      if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean")
        return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream))
        return stream._closed;
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
    }
    module22.exports = { isDestroyed, kIsDestroyed, isDisturbed, kIsDisturbed, isErrored, kIsErrored, isReadable, kIsReadable, kIsClosedPromise, kControllerErrorFunction, kIsWritable, isClosed, isDuplexNodeStream, isFinished, isIterable, isReadableNodeStream, isReadableStream, isReadableEnded, isReadableFinished, isReadableErrored, isNodeStream, isWebStream, isWritable, isWritableNodeStream, isWritableStream, isWritableEnded, isWritableFinished, isWritableErrored, isServerRequest, isServerResponse, willEmitClose, isTransformStream };
  });
  var require_end_of_stream = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { AbortError: AbortError2, codes } = require_errors2(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once: once4 } = require_util2(), { validateAbortSignal: validateAbortSignal2, validateFunction, validateObject, validateBoolean: validateBoolean2 } = require_validators(), { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials(), { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils(), addAbortListener2;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {};
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2)
        callback = options, options = kEmptyObject;
      else if (options == null)
        options = kEmptyObject;
      else
        validateObject(options, "options");
      if (validateFunction(callback, "callback"), validateAbortSignal2(options.signal, "options.signal"), callback = once4(callback), isReadableStream(stream) || isWritableStream(stream))
        return eosWeb(stream, options, callback);
      if (!isNodeStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      let readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream), wState = stream._writableState, rState = stream._readableState, onlegacyfinish = () => {
        if (!stream.writable)
          onfinish();
      }, willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, false), onfinish = () => {
        if (writableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable))
          return;
        if (!readable || readableFinished)
          callback.call(stream);
      }, readableFinished = isReadableFinished(stream, false), onend = () => {
        if (readableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable))
          return;
        if (!writable || writableFinished)
          callback.call(stream);
      }, onerror = (err2) => {
        callback.call(stream, err2);
      }, closed = isClosed(stream), onclose = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        callback.call(stream);
      }, onclosed = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        callback.call(stream);
      }, onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        if (stream.on("complete", onfinish), !willEmitClose)
          stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !wState)
        stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
      if (!willEmitClose && typeof stream.aborted === "boolean")
        stream.on("aborted", onclose);
      if (stream.on("end", onend), stream.on("finish", onfinish), options.error !== false)
        stream.on("error", onerror);
      if (stream.on("close", onclose), closed)
        process2.nextTick(onclose);
      else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
        if (!willEmitClose)
          process2.nextTick(onclosed);
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false))
        process2.nextTick(onclosed);
      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false))
        process2.nextTick(onclosed);
      else if (rState && stream.req && stream.aborted)
        process2.nextTick(onclosed);
      let cleanup = () => {
        if (callback = nop, stream.removeListener("aborted", onclose), stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        let abort2 = () => {
          let endCallback = callback;
          cleanup(), endCallback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        };
        if (options.signal.aborted)
          process2.nextTick(abort2);
        else {
          addAbortListener2 = addAbortListener2 || require_util2().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort2), originalCallback = callback;
          callback = once4((...args2) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args2);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false, abort2 = nop;
      if (options.signal)
        if (abort2 = () => {
          isAborted = true, callback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        }, options.signal.aborted)
          process2.nextTick(abort2);
        else {
          addAbortListener2 = addAbortListener2 || require_util2().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort2), originalCallback = callback;
          callback = once4((...args2) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args2);
          });
        }
      let resolverFn = (...args2) => {
        if (!isAborted)
          process2.nextTick(() => callback.apply(stream, args2));
      };
      return PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null)
        opts = kEmptyObject;
      if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup)
        validateBoolean2(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
      return new Promise2((resolve, reject) => {
        let cleanup = eos(stream, opts, (err2) => {
          if (autoCleanup)
            cleanup();
          if (err2)
            reject(err2);
          else
            resolve();
        });
      });
    }
    module22.exports = eos;
    module22.exports.finished = finished;
  });
  var require_destroy = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors2(), { Symbol: Symbol2 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = Symbol2("kDestroy"), kConstruct = Symbol2("kConstruct");
    function checkError(err2, w2, r2) {
      if (err2) {
        if (err2.stack, w2 && !w2.errored)
          w2.errored = err2;
        if (r2 && !r2.errored)
          r2.errored = err2;
      }
    }
    function destroy(err2, cb) {
      let r2 = this._readableState, w2 = this._writableState, s3 = w2 || r2;
      if (w2 !== null && w2 !== undefined && w2.destroyed || r2 !== null && r2 !== undefined && r2.destroyed) {
        if (typeof cb === "function")
          cb();
        return this;
      }
      if (checkError(err2, w2, r2), w2)
        w2.destroyed = true;
      if (r2)
        r2.destroyed = true;
      if (!s3.constructed)
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err2), cb);
        });
      else
        _destroy(this, err2, cb);
      return this;
    }
    function _destroy(self2, err2, cb) {
      let called = false;
      function onDestroy(err22) {
        if (called)
          return;
        called = true;
        let { _readableState: r2, _writableState: w2 } = self2;
        if (checkError(err22, w2, r2), w2)
          w2.closed = true;
        if (r2)
          r2.closed = true;
        if (typeof cb === "function")
          cb(err22);
        if (err22)
          process2.nextTick(emitErrorCloseNT, self2, err22);
        else
          process2.nextTick(emitCloseNT, self2);
      }
      try {
        self2._destroy(err2 || null, onDestroy);
      } catch (err22) {
        onDestroy(err22);
      }
    }
    function emitErrorCloseNT(self2, err2) {
      emitErrorNT(self2, err2), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      let { _readableState: r2, _writableState: w2 } = self2;
      if (w2)
        w2.closeEmitted = true;
      if (r2)
        r2.closeEmitted = true;
      if (w2 !== null && w2 !== undefined && w2.emitClose || r2 !== null && r2 !== undefined && r2.emitClose)
        self2.emit("close");
    }
    function emitErrorNT(self2, err2) {
      let { _readableState: r2, _writableState: w2 } = self2;
      if (w2 !== null && w2 !== undefined && w2.errorEmitted || r2 !== null && r2 !== undefined && r2.errorEmitted)
        return;
      if (w2)
        w2.errorEmitted = true;
      if (r2)
        r2.errorEmitted = true;
      self2.emit("error", err2);
    }
    function undestroy() {
      let r2 = this._readableState, w2 = this._writableState;
      if (r2)
        r2.constructed = true, r2.closed = false, r2.closeEmitted = false, r2.destroyed = false, r2.errored = null, r2.errorEmitted = false, r2.reading = false, r2.ended = r2.readable === false, r2.endEmitted = r2.readable === false;
      if (w2)
        w2.constructed = true, w2.destroyed = false, w2.closed = false, w2.closeEmitted = false, w2.errored = null, w2.errorEmitted = false, w2.finalCalled = false, w2.prefinished = false, w2.ended = w2.writable === false, w2.ending = w2.writable === false, w2.finished = w2.writable === false;
    }
    function errorOrDestroy(stream, err2, sync) {
      let { _readableState: r2, _writableState: w2 } = stream;
      if (w2 !== null && w2 !== undefined && w2.destroyed || r2 !== null && r2 !== undefined && r2.destroyed)
        return this;
      if (r2 !== null && r2 !== undefined && r2.autoDestroy || w2 !== null && w2 !== undefined && w2.autoDestroy)
        stream.destroy(err2);
      else if (err2) {
        if (err2.stack, w2 && !w2.errored)
          w2.errored = err2;
        if (r2 && !r2.errored)
          r2.errored = err2;
        if (sync)
          process2.nextTick(emitErrorNT, stream, err2);
        else
          emitErrorNT(stream, err2);
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function")
        return;
      let { _readableState: r2, _writableState: w2 } = stream;
      if (r2)
        r2.constructed = false;
      if (w2)
        w2.constructed = false;
      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)
        return;
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err2) {
        if (called) {
          errorOrDestroy(stream, err2 !== null && err2 !== undefined ? err2 : new ERR_MULTIPLE_CALLBACK);
          return;
        }
        called = true;
        let { _readableState: r2, _writableState: w2 } = stream, s3 = w2 || r2;
        if (r2)
          r2.constructed = true;
        if (w2)
          w2.constructed = true;
        if (s3.destroyed)
          stream.emit(kDestroy, err2);
        else if (err2)
          errorOrDestroy(stream, err2, true);
        else
          process2.nextTick(emitConstructNT, stream);
      }
      try {
        stream._construct((err2) => {
          process2.nextTick(onConstruct, err2);
        });
      } catch (err2) {
        process2.nextTick(onConstruct, err2);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err2) {
      stream.emit("error", err2), process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err2) {
      if (!stream || isDestroyed(stream))
        return;
      if (!err2 && !isFinished(stream))
        err2 = new AbortError2;
      if (isServerRequest(stream))
        stream.socket = null, stream.destroy(err2);
      else if (isRequest(stream))
        stream.abort();
      else if (isRequest(stream.req))
        stream.req.abort();
      else if (typeof stream.destroy === "function")
        stream.destroy(err2);
      else if (typeof stream.close === "function")
        stream.close();
      else if (err2)
        process2.nextTick(emitErrorCloseLegacy, stream, err2);
      else
        process2.nextTick(emitCloseLegacy, stream);
      if (!stream.destroyed)
        stream[kIsDestroyed] = true;
    }
    module22.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
  });
  var require_legacy = __commonJS3((exports2, module22) => {
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      let source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause)
          source.pause();
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume)
          source.resume();
      }
      if (dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== false))
        source.on("end", onend), source.on("close", onclose);
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true, dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        if (didOnEnd = true, typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        if (cleanup(), EE.listenerCount(this, "error") === 0)
          this.emit("error", er);
      }
      prependListener3(source, "error", onerror), prependListener3(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
    };
    function prependListener3(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    module22.exports = { Stream, prependListener: prependListener3 };
  });
  var require_add_abort_signal = __commonJS3((exports2, module22) => {
    var { SymbolDispose } = require_primordials(), { AbortError: AbortError2, codes } = require_errors2(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } = codes, addAbortListener2, validateAbortSignal2 = (signal, name2) => {
      if (typeof signal !== "object" || !("aborted" in signal))
        throw new ERR_INVALID_ARG_TYPE3(name2, "AbortSignal", signal);
    };
    module22.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      if (validateAbortSignal2(signal, "signal"), !isNodeStream(stream) && !isWebStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      return module22.exports.addAbortSignalNoValidate(signal, stream);
    };
    module22.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal))
        return stream;
      let onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError2(undefined, { cause: signal.reason }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError2(undefined, { cause: signal.reason }));
      };
      if (signal.aborted)
        onAbort();
      else {
        addAbortListener2 = addAbortListener2 || require_util2().addAbortListener;
        let disposable = addAbortListener2(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  });
  var require_buffer_list = __commonJS3((exports2, module22) => {
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { inspect: inspect4 } = require_util2();
    module22.exports = class BufferList {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(v2) {
        let entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry, ++this.length;
      }
      unshift(v2) {
        let entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        return --this.length, ret;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(s3) {
        if (this.length === 0)
          return "";
        let p2 = this.head, ret = "" + p2.data;
        while ((p2 = p2.next) !== null)
          ret += s3 + p2.data;
        return ret;
      }
      concat(n2) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        let ret = Buffer3.allocUnsafe(n2 >>> 0), p2 = this.head, i4 = 0;
        while (p2)
          TypedArrayPrototypeSet(ret, p2.data, i4), i4 += p2.data.length, p2 = p2.next;
        return ret;
      }
      consume(n2, hasStrings) {
        let data = this.head.data;
        if (n2 < data.length) {
          let slice2 = data.slice(0, n2);
          return this.head.data = data.slice(n2), slice2;
        }
        if (n2 === data.length)
          return this.shift();
        return hasStrings ? this._getString(n2) : this._getBuffer(n2);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p2 = this.head;p2; p2 = p2.next)
          yield p2.data;
      }
      _getString(n2) {
        let ret = "", p2 = this.head, c2 = 0;
        do {
          let str = p2.data;
          if (n2 > str.length)
            ret += str, n2 -= str.length;
          else {
            if (n2 === str.length)
              if (ret += str, ++c2, p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            else
              ret += StringPrototypeSlice(str, 0, n2), this.head = p2, p2.data = StringPrototypeSlice(str, n2);
            break;
          }
          ++c2;
        } while ((p2 = p2.next) !== null);
        return this.length -= c2, ret;
      }
      _getBuffer(n2) {
        let ret = Buffer3.allocUnsafe(n2), retLen = n2, p2 = this.head, c2 = 0;
        do {
          let buf = p2.data;
          if (n2 > buf.length)
            TypedArrayPrototypeSet(ret, buf, retLen - n2), n2 -= buf.length;
          else {
            if (n2 === buf.length)
              if (TypedArrayPrototypeSet(ret, buf, retLen - n2), ++c2, p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            else
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n2), retLen - n2), this.head = p2, p2.data = buf.slice(n2);
            break;
          }
          ++c2;
        } while ((p2 = p2.next) !== null);
        return this.length -= c2, ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_3, options) {
        return inspect4(this, { ...options, depth: 0, customInspect: false });
      }
    };
  });
  var require_state = __commonJS3((exports2, module22) => {
    var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors2().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      if (validateInteger(value, "value", 0), objectMode)
        defaultHighWaterMarkObjectMode = value;
      else
        defaultHighWaterMarkBytes = value;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      let hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          let name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name2, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module22.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
  });
  var require_safe_buffer = __commonJS3((exports2, module22) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer2)), Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow)
      module22.exports = buffer;
    else
      copyProps(buffer, exports2), exports2.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw new TypeError("Argument must not be a number");
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer3(size);
      if (fill2 !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill2, encoding);
        else
          buf.fill(fill2);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  });
  var require_string_decoder = __commonJS3((exports2) => {
    var Buffer3 = require_safe_buffer().Buffer, isEncoding2 = Buffer3.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true)
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase(), retried = true;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding2 || !isEncoding2(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r2, i4;
      if (this.lastNeed) {
        if (r2 = this.fillLast(buf), r2 === undefined)
          return "";
        i4 = this.lastNeed, this.lastNeed = 0;
      } else
        i4 = 0;
      if (i4 < buf.length)
        return r2 ? r2 + this.text(buf, i4) : this.text(buf, i4);
      return r2 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j2 = buf.length - 1;
      if (j2 < i4)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j2]), nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j2]), nb >= 0) {
        if (nb > 0)
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p2) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "";
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128)
            return self2.lastNeed = 2, "";
        }
      }
    }
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed, r2 = utf8CheckExtraBytes(this, buf, p2);
      if (r2 !== undefined)
        return r2;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p2, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r2 + "";
      return r2;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r2 = buf.toString("utf16le", i4);
        if (r2) {
          var c2 = r2.charCodeAt(r2.length - 1);
          if (c2 >= 55296 && c2 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r2.slice(0, -1);
        }
        return r2;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r2 + this.lastChar.toString("utf16le", 0, end);
      }
      return r2;
    }
    function base64Text(buf, i4) {
      var n2 = (buf.length - i4) % 3;
      if (n2 === 0)
        return buf.toString("base64", i4);
      if (this.lastNeed = 3 - n2, this.lastTotal = 3, n2 === 1)
        this.lastChar[0] = buf[buf.length - 1];
      else
        this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
      return buf.toString("base64", i4, buf.length - n2);
    }
    function base64End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r2;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });
  var require_from = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from2(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3)
        return new Readable({ objectMode: true, ...opts, read() {
          this.push(iterable), this.push(null);
        } });
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator])
        isAsync = true, iterator = iterable[SymbolAsyncIterator]();
      else if (iterable && iterable[SymbolIterator])
        isAsync = false, iterator = iterable[SymbolIterator]();
      else
        throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
      let readable = new Readable({ objectMode: true, highWaterMark: 1, ...opts }), reading = false;
      readable._read = function() {
        if (!reading)
          reading = true, next();
      }, readable._destroy = function(error, cb) {
        PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
      };
      async function close(error) {
        let hadError = error !== undefined && error !== null, hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          let { value, done } = await iterator.throw(error);
          if (await value, done)
            return;
        }
        if (typeof iterator.return === "function") {
          let { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (;; ) {
          try {
            let { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done)
              readable.push(null);
            else {
              let res = value && typeof value.then === "function" ? await value : value;
              if (res === null)
                throw reading = false, new ERR_STREAM_NULL_VALUES;
              else if (readable.push(res))
                continue;
              else
                reading = false;
            }
          } catch (err2) {
            readable.destroy(err2);
          }
          break;
        }
      }
      return readable;
    }
    module22.exports = from2;
  });
  var require_readable = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise2, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol2 } = require_primordials();
    module22.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), { Stream, prependListener: prependListener3 } = require_legacy(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug = require_util2().debuglog("stream", (fn2) => {
      debug = fn2;
    }), BufferList = require_buffer_list(), destroyImpl = require_destroy(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors2(), { validateObject } = require_validators(), kPaused = Symbol2("kPaused"), { StringDecoder } = require_string_decoder(), from2 = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
    function makeBitMapDescriptor(bit) {
      return { enumerable: false, get() {
        return (this.state & bit) !== 0;
      }, set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      } };
    }
    ObjectDefineProperties(ReadableState.prototype, { objectMode: makeBitMapDescriptor(kObjectMode), ended: makeBitMapDescriptor(kEnded), endEmitted: makeBitMapDescriptor(kEndEmitted), reading: makeBitMapDescriptor(kReading), constructed: makeBitMapDescriptor(kConstructed), sync: makeBitMapDescriptor(kSync), needReadable: makeBitMapDescriptor(kNeedReadable), emittedReadable: makeBitMapDescriptor(kEmittedReadable), readableListening: makeBitMapDescriptor(kReadableListening), resumeScheduled: makeBitMapDescriptor(kResumeScheduled), errorEmitted: makeBitMapDescriptor(kErrorEmitted), emitClose: makeBitMapDescriptor(kEmitClose), autoDestroy: makeBitMapDescriptor(kAutoDestroy), destroyed: makeBitMapDescriptor(kDestroyed), closed: makeBitMapDescriptor(kClosed), closeEmitted: makeBitMapDescriptor(kCloseEmitted), multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain), readingMore: makeBitMapDescriptor(kReadingMore), dataEmitted: makeBitMapDescriptor(kDataEmitted) });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      if (this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      if (this.errored = null, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options && options.encoding)
        this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      let isDuplex = this instanceof require_duplex();
      if (this._readableState = new ReadableState(options, this, isDuplex), options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        if (this._readableState.needReadable)
          maybeReadMore(this, this._readableState);
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err2) {
      this.destroy(err2);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed)
        error = this.readableEnded ? null : new AbortError2, this.destroy(error);
      return new Promise2((resolve, reject) => eos(this, (err2) => err2 && err2 !== error ? reject(err2) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      let state = stream._readableState, err2;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
            if (addToFront && state.encoding)
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            else
              chunk = Buffer3.from(chunk, encoding), encoding = "";
        } else if (chunk instanceof Buffer3)
          encoding = "";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "";
        else if (chunk != null)
          err2 = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      if (err2)
        errorOrDestroy(stream, err2);
      else if (chunk === null)
        state.state &= ~kReading, onEofChunk(stream, state);
      else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0)
        if (addToFront)
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        else if (state.ended)
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        else if (state.destroyed || state.errored)
          return false;
        else if (state.state &= ~kReading, state.decoder && !encoding)
          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        else
          addChunk(stream, state, chunk, false);
      else if (!addToFront)
        state.state &= ~kReading, maybeReadMore(stream, state);
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0)
          state.awaitDrainWriters.clear();
        else
          state.awaitDrainWriters = null;
        state.dataEmitted = true, stream.emit("data", chunk);
      } else {
        if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      let state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      let decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      let buffer = this._readableState.buffer, content = "";
      for (let data of buffer)
        content += decoder.write(data);
      if (buffer.clear(), content !== "")
        buffer.push(content);
      return this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 > MAX_HWM)
        throw new ERR_OUT_OF_RANGE3("size", "<= 1GiB", n2);
      else
        n2--, n2 |= n2 >>> 1, n2 |= n2 >>> 2, n2 |= n2 >>> 4, n2 |= n2 >>> 8, n2 |= n2 >>> 16, n2++;
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n2)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n2 <= state.length)
        return n2;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n2) {
      if (debug("read", n2), n2 === undefined)
        n2 = NaN;
      else if (!NumberIsInteger(n2))
        n2 = NumberParseInt(n2, 10);
      let state = this._readableState, nOrig = n2;
      if (n2 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 !== 0)
        state.state &= ~kEmittedReadable;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      if (n2 = howMuchToRead(n2, state), n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      if (debug("need readable", doRead), state.length === 0 || state.length - n2 < state.highWaterMark)
        doRead = true, debug("length less than watermark", doRead);
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
        doRead = false, debug("reading, ended or constructing", doRead);
      else if (doRead) {
        if (debug("do read"), state.state |= kReading | kSync, state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err2) {
          errorOrDestroy(this, err2);
        }
        if (state.state &= ~kSync, !state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null)
        state.needReadable = state.length <= state.highWaterMark, n2 = 0;
      else if (state.length -= n2, state.multiAwaitDrain)
        state.awaitDrainWriters.clear();
      else
        state.awaitDrainWriters = null;
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted)
        state.dataEmitted = true, this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (debug("onEofChunk"), state.ended)
        return;
      if (state.decoder) {
        let chunk = state.decoder.end();
        if (chunk && chunk.length)
          state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
      }
      if (state.ended = true, state.sync)
        emitReadable(stream);
      else
        state.needReadable = false, state.emittedReadable = true, emitReadable_(stream);
    }
    function emitReadable(stream) {
      let state = stream._readableState;
      if (debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
        debug("emitReadable", state.flowing), state.emittedReadable = true, process2.nextTick(emitReadable_, stream);
    }
    function emitReadable_(stream) {
      let state = stream._readableState;
      if (debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
        stream.emit("readable"), state.emittedReadable = false;
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed)
        state.readingMore = true, process2.nextTick(maybeReadMore_, stream, state);
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        let len2 = state.length;
        if (debug("maybeReadMore read 0"), stream.read(0), len2 === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      let src = this, state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain)
          state.multiAwaitDrain = true, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
      state.pipes.push(dest), debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      let endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        if (debug("onunpipe"), readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false)
            unpipeInfo.hasUnpiped = true, cleanup();
        }
      }
      function onend() {
        debug("onend"), dest.end();
      }
      let ondrain, cleanedUp = false;
      function cleanup() {
        if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
          dest.removeListener("drain", ondrain);
        if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest)
            debug("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = false;
          else if (state.pipes.length > 1 && state.pipes.includes(dest))
            debug("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
          src.pause();
        }
        if (!ondrain)
          ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        let ret = dest.write(chunk);
        if (debug("dest.write", ret), ret === false)
          pause();
      }
      function onerror(er) {
        if (debug("onerror", er), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
          let s3 = dest._writableState || dest._readableState;
          if (s3 && !s3.errorEmitted)
            errorOrDestroy(dest, er);
          else
            dest.emit("error", er);
        }
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      if (dest.emit("pipe", src), dest.writableNeedDrain === true)
        pause();
      else if (!state.flowing)
        debug("pipe resume"), src.resume();
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        let state = src._readableState;
        if (state.awaitDrainWriters === dest)
          debug("pipeOnDrain", 1), state.awaitDrainWriters = null;
        else if (state.multiAwaitDrain)
          debug("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
          src.resume();
      };
    }
    Readable.prototype.unpipe = function(dest) {
      let state = this._readableState, unpipeInfo = { hasUnpiped: false };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        let dests = state.pipes;
        state.pipes = [], this.pause();
        for (let i4 = 0;i4 < dests.length; i4++)
          dests[i4].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      if (state.pipes.splice(index, 1), state.pipes.length === 0)
        this.pause();
      return dest.emit("unpipe", this, unpipeInfo), this;
    };
    Readable.prototype.on = function(ev, fn2) {
      let res = Stream.prototype.on.call(this, ev, fn2), state = this._readableState;
      if (ev === "data") {
        if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug("on readable", state.length, state.reading), state.length)
            emitReadable(this);
          else if (!state.reading)
            process2.nextTick(nReadingNextTick, this);
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      let res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable")
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      let res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === undefined)
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    function updateReadableListening(self2) {
      let state = self2._readableState;
      if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === false)
        state.flowing = true;
      else if (self2.listenerCount("data") > 0)
        self2.resume();
      else if (!state.readableListening)
        state.flowing = null;
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      let state = this._readableState;
      if (!state.flowing)
        debug("resume"), state.flowing = !state.readableListening, resume(this, state);
      return state[kPaused] = false, this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled)
        state.resumeScheduled = true, process2.nextTick(resume_, stream, state);
    }
    function resume_(stream, state) {
      if (debug("resume", state.reading), !state.reading)
        stream.read(0);
      if (state.resumeScheduled = false, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
        debug("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[kPaused] = true, this;
    };
    function flow(stream) {
      let state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause)
          paused = true, stream.pause();
      }), stream.on("end", () => {
        this.push(null);
      }), stream.on("error", (err2) => {
        errorOrDestroy(this, err2);
      }), stream.on("close", () => {
        this.destroy();
      }), stream.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (paused && stream.resume)
          paused = false, stream.resume();
      };
      let streamKeys = ObjectKeys(stream);
      for (let j2 = 1;j2 < streamKeys.length; j2++) {
        let i4 = streamKeys[j2];
        if (this[i4] === undefined && typeof stream[i4] === "function")
          this[i4] = stream[i4].bind(stream);
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== undefined)
        validateObject(options, "options");
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function")
        stream = Readable.wrap(stream, { objectMode: true });
      let iter = createAsyncIterator(stream, options);
      return iter.stream = stream, iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream)
          callback(), callback = nop;
        else
          callback = resolve;
      }
      stream.on("readable", next);
      let error, cleanup = eos(stream, { writable: false }, (err2) => {
        error = err2 ? aggregateTwoErrors(error, err2) : null, callback(), callback = nop;
      });
      try {
        while (true) {
          let chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null)
            yield chunk;
          else if (error)
            throw error;
          else if (error === null)
            return;
          else
            await new Promise2(next);
        }
      } catch (err2) {
        throw error = aggregateTwoErrors(error, err2), error;
      } finally {
        if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy))
          destroyImpl.destroyer(stream, null);
        else
          stream.off("readable", next), cleanup();
      }
    }
    ObjectDefineProperties(Readable.prototype, { readable: { __proto__: null, get() {
      let r2 = this._readableState;
      return !!r2 && r2.readable !== false && !r2.destroyed && !r2.errorEmitted && !r2.endEmitted;
    }, set(val) {
      if (this._readableState)
        this._readableState.readable = !!val;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(state) {
      if (this._readableState)
        this._readableState.flowing = state;
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(value) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    ObjectDefineProperties(ReadableState.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[kPaused] !== false;
    }, set(value) {
      this[kPaused] = !!value;
    } } });
    Readable._fromList = fromList;
    function fromList(n2, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else
        ret = state.buffer.consume(n2, state.decoder);
      return ret;
    }
    function endReadable(stream) {
      let state = stream._readableState;
      if (debug("endReadable", state.endEmitted), !state.endEmitted)
        state.ended = true, process2.nextTick(endReadableNT, state, stream);
    }
    function endReadableNT(state, stream) {
      if (debug("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        if (state.endEmitted = true, stream.emit("end"), stream.writable && stream.allowHalfOpen === false)
          process2.nextTick(endWritableNT, stream);
        else if (state.autoDestroy) {
          let wState = stream._writableState;
          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false))
            stream.destroy();
        }
      }
    }
    function endWritableNT(stream) {
      if (stream.writable && !stream.writableEnded && !stream.destroyed)
        stream.end();
    }
    Readable.from = function(iterable, opts) {
      return from2(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({ objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true, ...options, destroy(err2, callback) {
        destroyImpl.destroyer(src, err2), callback(err2);
      } }).wrap(src);
    };
  });
  var require_writable = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { ArrayPrototypeSlice: ArrayPrototypeSlice2, Error: Error2, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol2, SymbolHasInstance } = require_primordials();
    module22.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), Stream = require_legacy().Stream, { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors2().codes, { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {}
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.objectMode = !!(options && options.objectMode), isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = onwrite.bind(undefined, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !options || options.emitClose !== false, this.autoDestroy = !options || options.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = true, state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice2(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function Writable(options) {
      let isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      if (this._writableState = new WritableState(options, this, isDuplex), options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        let state = this._writableState;
        if (!state.writing)
          clearBuffer(this, state);
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, { __proto__: null, value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    } });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
    };
    function _write2(stream, chunk, encoding, cb) {
      let state = stream._writableState;
      if (typeof encoding === "function")
        cb = encoding, encoding = state.defaultEncoding;
      else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null)
        throw new ERR_STREAM_NULL_VALUES;
      else if (!state.objectMode)
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false)
            chunk = Buffer3.from(chunk, encoding), encoding = "buffer";
        } else if (chunk instanceof Buffer3)
          encoding = "buffer";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "buffer";
        else
          throw new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      let err2;
      if (state.ending)
        err2 = new ERR_STREAM_WRITE_AFTER_END;
      else if (state.destroyed)
        err2 = new ERR_STREAM_DESTROYED("write");
      if (err2)
        return process2.nextTick(cb, err2), errorOrDestroy(stream, err2, true), err2;
      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write2(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      let state = this._writableState;
      if (state.corked) {
        if (state.corked--, !state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      let len2 = state.objectMode ? 1 : chunk.length;
      state.length += len2;
      let ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        if (state.buffered.push({ chunk, encoding, callback }), state.allBuffers && encoding !== "buffer")
          state.allBuffers = false;
        if (state.allNoop && callback !== nop)
          state.allNoop = false;
      } else
        state.writelen = len2, state.writecb = callback, state.writing = true, state.sync = true, stream._write(chunk, encoding, state.onwrite), state.sync = false;
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len2, chunk, encoding, cb) {
      if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      let state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
        return;
      }
      if (state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {
        if (er.stack, !state.errored)
          state.errored = er;
        if (stream._readableState && !stream._readableState.errored)
          stream._readableState.errored = er;
        if (sync)
          process2.nextTick(onwriteError, stream, state, er, cb);
        else
          onwriteError(stream, state, er, cb);
      } else {
        if (state.buffered.length > state.bufferedIndex)
          clearBuffer(stream, state);
        if (sync)
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
            state.afterWriteTickInfo.count++;
          else
            state.afterWriteTickInfo = { count: 1, cb, stream, state }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        else
          afterWrite(stream, state, 1, cb);
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)
        state.needDrain = false, stream.emit("drain");
      while (count-- > 0)
        state.pendingcb--, cb();
      if (state.destroyed)
        errorBuffer(state);
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing)
        return;
      for (let n2 = state.bufferedIndex;n2 < state.buffered.length; ++n2) {
        var _state$errored;
        let { chunk, callback } = state.buffered[n2], len2 = state.objectMode ? 1 : chunk.length;
        state.length -= len2, callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0;i4 < onfinishCallbacks.length; i4++) {
        var _state$errored2;
        onfinishCallbacks[i4]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
        return;
      let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength)
        return;
      let i4 = bufferedIndex;
      if (state.bufferProcessing = true, bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        let callback = state.allNoop ? nop : (err2) => {
          for (let n2 = i4;n2 < buffered.length; ++n2)
            buffered[n2].callback(err2);
        }, chunks = state.allNoop && i4 === 0 ? buffered : ArrayPrototypeSlice2(buffered, i4);
        chunks.allBuffers = state.allBuffers, doWrite(stream, state, true, state.length, chunks, "", callback), resetBuffer(state);
      } else {
        do {
          let { chunk, encoding, callback } = buffered[i4];
          buffered[i4++] = null;
          let len2 = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len2, chunk, encoding, callback);
        } while (i4 < buffered.length && !state.writing);
        if (i4 === buffered.length)
          resetBuffer(state);
        else if (i4 > 256)
          buffered.splice(0, i4), state.bufferedIndex = 0;
        else
          state.bufferedIndex = i4;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev)
        this._writev([{ chunk, encoding }], cb);
      else
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      let state = this._writableState;
      if (typeof chunk === "function")
        cb = chunk, chunk = null, encoding = null;
      else if (typeof encoding === "function")
        cb = encoding, encoding = null;
      let err2;
      if (chunk !== null && chunk !== undefined) {
        let ret = _write2(this, chunk, encoding);
        if (ret instanceof Error2)
          err2 = ret;
      }
      if (state.corked)
        state.corked = 1, this.uncork();
      if (err2)
        ;
      else if (!state.errored && !state.ending)
        state.ending = true, finishMaybe(this, state, true), state.ended = true;
      else if (state.finished)
        err2 = new ERR_STREAM_ALREADY_FINISHED("end");
      else if (state.destroyed)
        err2 = new ERR_STREAM_DESTROYED("end");
      if (typeof cb === "function")
        if (err2 || state.finished)
          process2.nextTick(cb, err2);
        else
          state[kOnFinished].push(cb);
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err2) {
        if (called) {
          errorOrDestroy(stream, err2 !== null && err2 !== undefined ? err2 : ERR_MULTIPLE_CALLBACK());
          return;
        }
        if (called = true, state.pendingcb--, err2) {
          let onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i4 = 0;i4 < onfinishCallbacks.length; i4++)
            onfinishCallbacks[i4](err2);
          errorOrDestroy(stream, err2, state.sync);
        } else if (needFinish(state))
          state.prefinished = true, stream.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream, state);
      }
      state.sync = true, state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err2) {
        onFinish(err2);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled)
        if (typeof stream._final === "function" && !state.destroyed)
          state.finalCalled = true, callFinal(stream, state);
        else
          state.prefinished = true, stream.emit("prefinish");
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        if (prefinish(stream, state), state.pendingcb === 0) {
          if (sync)
            state.pendingcb++, process2.nextTick((stream2, state2) => {
              if (needFinish(state2))
                finish(stream2, state2);
              else
                state2.pendingcb--;
            }, stream, state);
          else if (needFinish(state))
            state.pendingcb++, finish(stream, state);
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--, state.finished = true;
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0;i4 < onfinishCallbacks.length; i4++)
        onfinishCallbacks[i4]();
      if (stream.emit("finish"), state.autoDestroy) {
        let rState = stream._readableState;
        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false))
          stream.destroy();
      }
    }
    ObjectDefineProperties(Writable.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(value) {
      if (this._writableState)
        this._writableState.destroyed = value;
    } }, writable: { __proto__: null, get() {
      let w2 = this._writableState;
      return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
    }, set(val) {
      if (this._writableState)
        this._writableState.writable = !!val;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err2, cb) {
      let state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
        process2.nextTick(errorBuffer, state);
      return destroy.call(this, err2, cb), this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err2) {
      this.destroy(err2);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  });
  var require_duplexify = __commonJS3((exports2, module22) => {
    var process2 = require_process(), bufferModule = (init_buffer(), __toCommonJS(exports_buffer2)), { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils(), eos = require_end_of_stream(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE } } = require_errors2(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), Writable = require_writable(), { createDeferredPromise } = require_util2(), from2 = require_from(), Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b3) {
      return b3 instanceof Blob3;
    } : function isBlob(b3) {
      return false;
    }, AbortController = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

    class Duplexify extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === undefined ? undefined : options.readable) === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((options === null || options === undefined ? undefined : options.writable) === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    }
    module22.exports = function duplexify(body2, name2) {
      if (isDuplexNodeStream(body2))
        return body2;
      if (isReadableNodeStream(body2))
        return _duplexify({ readable: body2 });
      if (isWritableNodeStream(body2))
        return _duplexify({ writable: body2 });
      if (isNodeStream(body2))
        return _duplexify({ writable: false, readable: false });
      if (isReadableStream(body2))
        return _duplexify({ readable: Readable.fromWeb(body2) });
      if (isWritableStream(body2))
        return _duplexify({ writable: Writable.fromWeb(body2) });
      if (typeof body2 === "function") {
        let { value, write: write3, final, destroy } = fromAsyncGen(body2);
        if (isIterable(value))
          return from2(Duplexify, value, { objectMode: true, write: write3, final, destroy });
        let then2 = value === null || value === undefined ? undefined : value.then;
        if (typeof then2 === "function") {
          let d3, promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null)
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }, (err2) => {
            destroyer(d3, err2);
          });
          return d3 = new Duplexify({ objectMode: true, readable: false, write: write3, final(cb) {
            final(async () => {
              try {
                await promise, process2.nextTick(cb, null);
              } catch (err2) {
                process2.nextTick(cb, err2);
              }
            });
          }, destroy });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
      }
      if (isBlob(body2))
        return duplexify(body2.arrayBuffer());
      if (isIterable(body2))
        return from2(Duplexify, body2, { objectMode: true, writable: false });
      if (isReadableStream(body2 === null || body2 === undefined ? undefined : body2.readable) && isWritableStream(body2 === null || body2 === undefined ? undefined : body2.writable))
        return Duplexify.fromWeb(body2);
      if (typeof (body2 === null || body2 === undefined ? undefined : body2.writable) === "object" || typeof (body2 === null || body2 === undefined ? undefined : body2.readable) === "object") {
        let readable = body2 !== null && body2 !== undefined && body2.readable ? isReadableNodeStream(body2 === null || body2 === undefined ? undefined : body2.readable) ? body2 === null || body2 === undefined ? undefined : body2.readable : duplexify(body2.readable) : undefined, writable = body2 !== null && body2 !== undefined && body2.writable ? isWritableNodeStream(body2 === null || body2 === undefined ? undefined : body2.writable) ? body2 === null || body2 === undefined ? undefined : body2.writable : duplexify(body2.writable) : undefined;
        return _duplexify({ readable, writable });
      }
      let then = body2 === null || body2 === undefined ? undefined : body2.then;
      if (typeof then === "function") {
        let d3;
        return FunctionPrototypeCall(then, body2, (val) => {
          if (val != null)
            d3.push(val);
          d3.push(null);
        }, (err2) => {
          destroyer(d3, err2);
        }), d3 = new Duplexify({ objectMode: true, writable: false, read() {} });
      }
      throw new ERR_INVALID_ARG_TYPE3(name2, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body2);
    };
    function fromAsyncGen(fn2) {
      let { promise, resolve } = createDeferredPromise(), ac = new AbortController, signal = ac.signal;
      return { value: fn2(async function* () {
        while (true) {
          let _promise = promise;
          promise = null;
          let { chunk, done, cb } = await _promise;
          if (process2.nextTick(cb), done)
            return;
          if (signal.aborted)
            throw new AbortError2(undefined, { cause: signal.reason });
          ({ promise, resolve } = createDeferredPromise()), yield chunk;
        }
      }(), { signal }), write(chunk, encoding, cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ chunk, done: false, cb });
      }, final(cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ done: true, cb });
      }, destroy(err2, cb) {
        ac.abort(), cb(err2);
      } };
    }
    function _duplexify(pair) {
      let r2 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w2 = pair.writable, readable = !!isReadable(r2), writable = !!isWritable(w2), ondrain, onfinish, onreadable, onclose, d3;
      function onfinished(err2) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err2);
        else if (err2)
          d3.destroy(err2);
      }
      if (d3 = new Duplexify({ readableObjectMode: !!(r2 !== null && r2 !== undefined && r2.readableObjectMode), writableObjectMode: !!(w2 !== null && w2 !== undefined && w2.writableObjectMode), readable, writable }), writable)
        eos(w2, (err2) => {
          if (writable = false, err2)
            destroyer(r2, err2);
          onfinished(err2);
        }), d3._write = function(chunk, encoding, callback) {
          if (w2.write(chunk, encoding))
            callback();
          else
            ondrain = callback;
        }, d3._final = function(callback) {
          w2.end(), onfinish = callback;
        }, w2.on("drain", function() {
          if (ondrain) {
            let cb = ondrain;
            ondrain = null, cb();
          }
        }), w2.on("finish", function() {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      if (readable)
        eos(r2, (err2) => {
          if (readable = false, err2)
            destroyer(r2, err2);
          onfinished(err2);
        }), r2.on("readable", function() {
          if (onreadable) {
            let cb = onreadable;
            onreadable = null, cb();
          }
        }), r2.on("end", function() {
          d3.push(null);
        }), d3._read = function() {
          while (true) {
            let buf = r2.read();
            if (buf === null) {
              onreadable = d3._read;
              return;
            }
            if (!d3.push(buf))
              return;
          }
        };
      return d3._destroy = function(err2, callback) {
        if (!err2 && onclose !== null)
          err2 = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err2);
        else
          onclose = callback, destroyer(w2, err2), destroyer(r2, err2);
      }, d3;
    }
  });
  var require_duplex = __commonJS3((exports2, module22) => {
    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
    module22.exports = Duplex;
    var Readable = require_readable(), Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      let keys = ObjectKeys(Writable.prototype);
      for (let i4 = 0;i4 < keys.length; i4++) {
        let method = keys[i4];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      if (Readable.call(this, options), Writable.call(this, options), options) {
        if (this.allowHalfOpen = options.allowHalfOpen !== false, options.readable === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (options.writable === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else
        this.allowHalfOpen = true;
    }
    ObjectDefineProperties(Duplex.prototype, { writable: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === undefined || this._writableState === undefined)
        return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(value) {
      if (this._readableState && this._writableState)
        this._readableState.destroyed = value, this._writableState.destroyed = value;
    } } });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body2) {
      if (!duplexify)
        duplexify = require_duplexify();
      return duplexify(body2, "body");
    };
  });
  var require_transform = __commonJS3((exports2, module22) => {
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module22.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      let readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0)
        options = { ...options, highWaterMark: null, readableHighWaterMark, writableHighWaterMark: options.writableHighWaterMark || 0 };
      if (Duplex.call(this, options), this._readableState.sync = false, this[kCallback] = null, options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed)
        this._flush((er, data) => {
          if (er) {
            if (cb)
              cb(er);
            else
              this.destroy(er);
            return;
          }
          if (data != null)
            this.push(data);
          if (this.push(null), cb)
            cb();
        });
      else if (this.push(null), cb)
        cb();
    }
    function prefinish() {
      if (this._final !== final)
        final.call(this);
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      let rState = this._readableState, wState = this._writableState, length = rState.length;
      this._transform(chunk, encoding, (err2, val) => {
        if (err2) {
          callback(err2);
          return;
        }
        if (val != null)
          this.push(val);
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark)
          callback();
        else
          this[kCallback] = callback;
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        let callback = this[kCallback];
        this[kCallback] = null, callback();
      }
    };
  });
  var require_passthrough = __commonJS3((exports2, module22) => {
    var { ObjectSetPrototypeOf } = require_primordials();
    module22.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });
  var require_pipeline = __commonJS3((exports2, module22) => {
    var process2 = require_process(), { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once: once4 } = require_util2(), destroyImpl = require_destroy(), Duplex = require_duplex(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors2(), { validateFunction, validateAbortSignal: validateAbortSignal2 } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils(), AbortController = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener2;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      let cleanup = eos(stream, { readable: reading, writable: writing }, (err2) => {
        finished = !err2;
      });
      return { destroy: (err2) => {
        if (finished)
          return;
        finished = true, destroyImpl.destroyer(stream, err2 || new ERR_STREAM_DESTROYED("pipe"));
      }, cleanup };
    }
    function popCallback(streams) {
      return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val))
        return val;
      else if (isReadableNodeStream(val))
        return fromReadable(val);
      throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable)
        Readable = require_readable();
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error, onresolve = null, resume = (err2) => {
        if (err2)
          error = err2;
        if (onresolve) {
          let callback = onresolve;
          onresolve = null, callback();
        }
      }, wait = () => new Promise2((resolve, reject) => {
        if (error)
          reject(error);
        else
          onresolve = () => {
            if (error)
              reject(error);
            else
              resolve();
          };
      });
      writable.on("drain", resume);
      let cleanup = eos(writable, { readable: false }, resume);
      try {
        if (writable.writableNeedDrain)
          await wait();
        for await (let chunk of iterable)
          if (!writable.write(chunk))
            await wait();
        if (end)
          writable.end(), await wait();
        finish();
      } catch (err2) {
        finish(error !== err2 ? aggregateTwoErrors(error, err2) : err2);
      } finally {
        cleanup(), writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable))
        writable = writable.writable;
      let writer = writable.getWriter();
      try {
        for await (let chunk of readable)
          await writer.ready, writer.write(chunk).catch(() => {});
        if (await writer.ready, end)
          await writer.close();
        finish();
      } catch (err2) {
        try {
          await writer.abort(err2), finish(err2);
        } catch (err22) {
          finish(err22);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once4(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      let ac = new AbortController, signal = ac.signal, outerSignal = opts === null || opts === undefined ? undefined : opts.signal, lastStreamCleanup = [];
      validateAbortSignal2(outerSignal, "options.signal");
      function abort2() {
        finishImpl(new AbortError2);
      }
      addAbortListener2 = addAbortListener2 || require_util2().addAbortListener;
      let disposable;
      if (outerSignal)
        disposable = addAbortListener2(outerSignal, abort2);
      let error, value, destroys = [], finishCount = 0;
      function finish(err2) {
        finishImpl(err2, --finishCount === 0);
      }
      function finishImpl(err2, final) {
        var _disposable;
        if (err2 && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE"))
          error = err2;
        if (!error && !final)
          return;
        while (destroys.length)
          destroys.shift()(error);
        if ((_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose](), ac.abort(), final) {
          if (!error)
            lastStreamCleanup.forEach((fn2) => fn2());
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i4 = 0;i4 < streams.length; i4++) {
        let stream = streams[i4], reading = i4 < streams.length - 1, writing = i4 > 0, end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false, isLastStream = i4 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err2) {
            if (err2 && err2.name !== "AbortError" && err2.code !== "ERR_STREAM_PREMATURE_CLOSE")
              finish(err2);
          };
          var onError = onError2;
          if (end) {
            let { destroy, cleanup } = destroyer(stream, reading, writing);
            if (destroys.push(destroy), isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          }
          if (stream.on("error", onError2), isReadable(stream) && isLastStream)
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
        }
        if (i4 === 0)
          if (typeof stream === "function") {
            if (ret = stream({ signal }), !isIterable(ret))
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream))
            ret = stream;
          else
            ret = Duplex.from(stream);
        else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
          } else
            ret = makeAsyncIterable(ret);
          if (ret = stream(ret, { signal }), reading) {
            if (!isIterable(ret, true))
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i4 - 1}]`, ret);
          } else {
            var _ret2;
            if (!PassThrough)
              PassThrough = require_passthrough();
            let pt2 = new PassThrough({ objectMode: true }), then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
            if (typeof then === "function")
              finishCount++, then.call(ret, (val) => {
                if (value = val, val != null)
                  pt2.write(val);
                if (end)
                  pt2.end();
                process2.nextTick(finish);
              }, (err2) => {
                pt2.destroy(err2), process2.nextTick(finish, err2);
              });
            else if (isIterable(ret, true))
              finishCount++, pumpToNode(ret, pt2, finish, { end });
            else if (isReadableStream(ret) || isTransformStream(ret)) {
              let toRead = ret.readable || ret;
              finishCount++, pumpToNode(toRead, pt2, finish, { end });
            } else
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            ret = pt2;
            let { destroy, cleanup } = destroyer(ret, false, true);
            if (destroys.push(destroy), isLastStream)
              lastStreamCleanup.push(cleanup);
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            let cleanup = pipe(ret, stream, finish, { end });
            if (isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            let toRead = ret.readable || ret;
            finishCount++, pumpToNode(toRead, stream, finish, { end });
          } else if (isIterable(ret))
            finishCount++, pumpToNode(ret, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret))
            finishCount++, pumpToWeb(makeAsyncIterable(ret), stream, finish, { end });
          else if (isReadableStream(ret) || isIterable(ret))
            finishCount++, pumpToWeb(ret, stream, finish, { end });
          else if (isTransformStream(ret))
            finishCount++, pumpToWeb(ret.readable, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else
          ret = Duplex.from(stream);
      }
      if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
        process2.nextTick(abort2);
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      if (dst.on("close", () => {
        if (!ended)
          finish(new ERR_STREAM_PREMATURE_CLOSE);
      }), src.pipe(dst, { end: false }), end) {
        let endFn2 = function() {
          ended = true, dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src))
          process2.nextTick(endFn2);
        else
          src.once("end", endFn2);
      } else
        finish();
      return eos(src, { readable: true, writable: false }, (err2) => {
        let rState = src._readableState;
        if (err2 && err2.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
          src.once("end", finish).once("error", finish);
        else
          finish(err2);
      }), eos(dst, { readable: false, writable: true }, finish);
    }
    module22.exports = { pipelineImpl, pipeline };
  });
  var require_compose = __commonJS3((exports2, module22) => {
    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors2(), eos = require_end_of_stream();
    module22.exports = function compose(...streams) {
      if (streams.length === 0)
        throw new ERR_MISSING_ARGS("streams");
      if (streams.length === 1)
        return Duplex.from(streams[0]);
      let orgStreams = [...streams];
      if (typeof streams[0] === "function")
        streams[0] = Duplex.from(streams[0]);
      if (typeof streams[streams.length - 1] === "function") {
        let idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n2 = 0;n2 < streams.length; ++n2) {
        if (!isNodeStream(streams[n2]) && !isWebStream(streams[n2]))
          continue;
        if (n2 < streams.length - 1 && !(isReadable(streams[n2]) || isReadableStream(streams[n2]) || isTransformStream(streams[n2])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be readable");
        if (n2 > 0 && !(isWritable(streams[n2]) || isWritableStream(streams[n2]) || isTransformStream(streams[n2])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be writable");
      }
      let ondrain, onfinish, onreadable, onclose, d3;
      function onfinished(err2) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err2);
        else if (err2)
          d3.destroy(err2);
        else if (!readable && !writable)
          d3.destroy();
      }
      let head = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      if (d3 = new Duplex({ writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode), readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode), writable, readable }), writable) {
        if (isNodeStream(head))
          d3._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding))
              callback();
            else
              ondrain = callback;
          }, d3._final = function(callback) {
            head.end(), onfinish = callback;
          }, head.on("drain", function() {
            if (ondrain) {
              let cb = ondrain;
              ondrain = null, cb();
            }
          });
        else if (isWebStream(head)) {
          let writer = (isTransformStream(head) ? head.writable : head).getWriter();
          d3._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready, writer.write(chunk).catch(() => {}), callback();
            } catch (err2) {
              callback(err2);
            }
          }, d3._final = async function(callback) {
            try {
              await writer.ready, writer.close().catch(() => {}), onfinish = callback;
            } catch (err2) {
              callback(err2);
            }
          };
        }
        let toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail))
          tail.on("readable", function() {
            if (onreadable) {
              let cb = onreadable;
              onreadable = null, cb();
            }
          }), tail.on("end", function() {
            d3.push(null);
          }), d3._read = function() {
            while (true) {
              let buf = tail.read();
              if (buf === null) {
                onreadable = d3._read;
                return;
              }
              if (!d3.push(buf))
                return;
            }
          };
        else if (isWebStream(tail)) {
          let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
          d3._read = async function() {
            while (true)
              try {
                let { value, done } = await reader.read();
                if (!d3.push(value))
                  return;
                if (done) {
                  d3.push(null);
                  return;
                }
              } catch {
                return;
              }
          };
        }
      }
      return d3._destroy = function(err2, callback) {
        if (!err2 && onclose !== null)
          err2 = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err2);
        else if (onclose = callback, isNodeStream(tail))
          destroyer(tail, err2);
      }, d3;
    };
  });
  var require_operators = __commonJS3((exports2, module22) => {
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController, { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3 }, AbortError: AbortError2 } = require_errors2(), { validateAbortSignal: validateAbortSignal2, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils(), { deprecate: deprecate2 } = require_util2(), { ArrayPrototypePush, Boolean: Boolean2, MathFloor, Number: Number2, NumberIsNaN, Promise: Promise2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol2 } = require_primordials(), kEmpty = Symbol2("kEmpty"), kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      if (isNodeStream(stream) && !isWritable(stream))
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      let composedStream = staticCompose(this, stream);
      if (options !== null && options !== undefined && options.signal)
        addAbortSignalNoValidate(options.signal, composedStream);
      return composedStream;
    }
    function map(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let concurrency = 1;
      if ((options === null || options === undefined ? undefined : options.concurrency) != null)
        concurrency = MathFloor(options.concurrency);
      let highWaterMark = concurrency - 1;
      if ((options === null || options === undefined ? undefined : options.highWaterMark) != null)
        highWaterMark = MathFloor(options.highWaterMark);
      return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* map() {
        let signal = require_util2().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2)), stream = this, queue2 = [], signalOpt = { signal }, next, resume, done = false, cnt = 0;
        function onCatch() {
          done = true, afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1, maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue2.length < highWaterMark)
            resume(), resume = null;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done)
                return;
              if (signal.aborted)
                throw new AbortError2;
              try {
                if (val = fn2(val, signalOpt), val === kEmpty)
                  continue;
                val = PromiseResolve(val);
              } catch (err2) {
                val = PromiseReject(err2);
              }
              if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue2.push(val), next)
                next(), next = null;
              if (!done && (queue2.length >= highWaterMark || cnt >= concurrency))
                await new Promise2((resolve) => {
                  resume = resolve;
                });
            }
            queue2.push(kEof);
          } catch (err2) {
            let val = PromiseReject(err2);
            PromisePrototypeThen(val, afterItemProcessed, onCatch), queue2.push(val);
          } finally {
            if (done = true, next)
              next(), next = null;
          }
        }
        pump();
        try {
          while (true) {
            while (queue2.length > 0) {
              let val = await queue2[0];
              if (val === kEof)
                return;
              if (signal.aborted)
                throw new AbortError2;
              if (val !== kEmpty)
                yield val;
              queue2.shift(), maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          if (done = true, resume)
            resume(), resume = null;
        }
      }.call(this);
    }
    function asIndexedPairs(options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return async function* asIndexedPairs() {
        let index = 0;
        for await (let val of this) {
          var _options$signal;
          if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted)
            throw new AbortError2({ cause: options.signal.reason });
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn2, options = undefined) {
      for await (let unused of filter.call(this, fn2, options))
        return true;
      return false;
    }
    async function every(fn2, options = undefined) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      return !await some.call(this, async (...args2) => {
        return !await fn2(...args2);
      }, options);
    }
    async function find(fn2, options) {
      for await (let result of filter.call(this, fn2, options))
        return result;
      return;
    }
    async function forEach(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      async function forEachFn(value, options2) {
        return await fn2(value, options2), kEmpty;
      }
      for await (let unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      async function filterFn(value, options2) {
        if (await fn2(value, options2))
          return value;
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }

    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function")
        throw new ERR_INVALID_ARG_TYPE3("reducer", ["Function", "AsyncFunction"], reducer);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
        let err2 = new AbortError2(undefined, { cause: options.signal.reason });
        throw this.once("error", () => {}), await finished(this.destroy(err2)), err2;
      }
      let ac = new AbortController, signal = ac.signal;
      if (options !== null && options !== undefined && options.signal) {
        let opts = { once: true, [kWeakHandler]: this, [kResistStopPropagation]: true };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (let value of this) {
          var _options$signal3;
          if (gotAnyItemFromStream = true, options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted)
            throw new AbortError2;
          if (!hasInitialValue)
            initialValue = value, hasInitialValue = true;
          else
            initialValue = await reducer(initialValue, value, { signal });
        }
        if (!gotAnyItemFromStream && !hasInitialValue)
          throw new ReduceAwareErrMissingArgs;
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let result = [];
      for await (let val of this) {
        var _options$signal4;
        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted)
          throw new AbortError2(undefined, { cause: options.signal.reason });
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn2, options) {
      let values = map.call(this, fn2, options);
      return async function* flatMap() {
        for await (let val of values)
          yield* val;
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      if (number = Number2(number), NumberIsNaN(number))
        return 0;
      if (number < 0)
        throw new ERR_OUT_OF_RANGE3("number", ">= 0", number);
      return number;
    }
    function drop(number, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* drop() {
        var _options$signal5;
        if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal6;
          if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted)
            throw new AbortError2;
          if (number-- <= 0)
            yield val;
        }
      }.call(this);
    }
    function take(number, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* take() {
        var _options$signal7;
        if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal8;
          if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted)
            throw new AbortError2;
          if (number-- > 0)
            yield val;
          if (number <= 0)
            return;
        }
      }.call(this);
    }
    module22.exports.streamReturningOperators = { asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."), drop, filter, flatMap, map, take, compose };
    module22.exports.promiseReturningOperators = { every, forEach, reduce, toArray, some, find };
  });
  var require_promises = __commonJS3((exports2, module22) => {
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream, isWebStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal, end, lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          let options = ArrayPrototypePop(streams);
          signal = options.signal, end = options.end;
        }
        pl(streams, (err2, value) => {
          if (err2)
            reject(err2);
          else
            resolve(value);
        }, { signal, end });
      });
    }
    module22.exports = { finished, pipeline };
  });
  var require_stream2 = __commonJS3((exports2, module22) => {
    var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), { promisify: { custom: customPromisify } } = require_util2(), { streamReturningOperators, promiseReturningOperators } = require_operators(), { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors2(), compose = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module22.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (let key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args2) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return Stream.Readable.from(ReflectApply(op, this, args2));
      }, op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
    }
    for (let key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args2) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return ReflectApply(op, this, args2);
      }, op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return promises;
    } });
    ObjectDefineProperty(pipeline, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.pipeline;
    } });
    ObjectDefineProperty(eos, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.finished;
    } });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  });
  var require_ours = __commonJS3((exports2, module22) => {
    var Stream = require_stream();
    if (Stream && process.env.READABLE_STREAM === "disable") {
      let promises = Stream.promises;
      module22.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer, module22.exports._isUint8Array = Stream._isUint8Array, module22.exports.isDisturbed = Stream.isDisturbed, module22.exports.isErrored = Stream.isErrored, module22.exports.isReadable = Stream.isReadable, module22.exports.Readable = Stream.Readable, module22.exports.Writable = Stream.Writable, module22.exports.Duplex = Stream.Duplex, module22.exports.Transform = Stream.Transform, module22.exports.PassThrough = Stream.PassThrough, module22.exports.addAbortSignal = Stream.addAbortSignal, module22.exports.finished = Stream.finished, module22.exports.destroy = Stream.destroy, module22.exports.pipeline = Stream.pipeline, module22.exports.compose = Stream.compose, Object.defineProperty(Stream, "promises", { configurable: true, enumerable: true, get() {
        return promises;
      } }), module22.exports.Stream = Stream.Stream;
    } else {
      let CustomStream = require_stream2(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
      module22.exports = CustomStream.Readable, module22.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module22.exports._isUint8Array = CustomStream._isUint8Array, module22.exports.isDisturbed = CustomStream.isDisturbed, module22.exports.isErrored = CustomStream.isErrored, module22.exports.isReadable = CustomStream.isReadable, module22.exports.Readable = CustomStream.Readable, module22.exports.Writable = CustomStream.Writable, module22.exports.Duplex = CustomStream.Duplex, module22.exports.Transform = CustomStream.Transform, module22.exports.PassThrough = CustomStream.PassThrough, module22.exports.addAbortSignal = CustomStream.addAbortSignal, module22.exports.finished = CustomStream.finished, module22.exports.destroy = CustomStream.destroy, module22.exports.destroy = originalDestroy, module22.exports.pipeline = CustomStream.pipeline, module22.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", { configurable: true, enumerable: true, get() {
        return promises;
      } }), module22.exports.Stream = CustomStream.Stream;
    }
    module22.exports.default = module22.exports;
  });
  module2.exports = require_ours();
});

// node:zlib
var exports_zlib = {};
__export(exports_zlib, {
  default: () => export_default
});
var __create3, __getProtoOf3, __defProp3, __getOwnPropNames3, __hasOwnProp3, __reExport = (target, mod, secondTarget) => {
  for (let key of __getOwnPropNames3(mod))
    if (!__hasOwnProp3.call(target, key) && key !== "default")
      __defProp3(target, key, { get: () => mod[key], enumerable: true });
  if (secondTarget) {
    for (let key of __getOwnPropNames3(mod))
      if (!__hasOwnProp3.call(secondTarget, key) && key !== "default")
        __defProp3(secondTarget, key, { get: () => mod[key], enumerable: true });
    return secondTarget;
  }
}, __toESM3 = (mod, isNodeMode, target) => {
  target = mod != null ? __create3(__getProtoOf3(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames3(mod))
    if (!__hasOwnProp3.call(to, key))
      __defProp3(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS3 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), __export2 = (target, all) => {
  for (var name2 in all)
    __defProp3(target, name2, { get: all[name2], enumerable: true, configurable: true, set: (newValue) => all[name2] = () => newValue });
}, require_zstream, require_common, require_trees, require_adler32, require_crc32, require_messages, require_deflate, require_inffast, require_inftrees, require_inflate, require_constants, require_binding, require_lib, exports_zlib2, import_browserify_zlib, export_default;
var init_zlib = __esm(() => {
  __create3 = Object.create;
  ({ getPrototypeOf: __getProtoOf3, defineProperty: __defProp3, getOwnPropertyNames: __getOwnPropNames3 } = Object);
  __hasOwnProp3 = Object.prototype.hasOwnProperty;
  require_zstream = __commonJS3((exports, module2) => {
    function ZStream() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    }
    module2.exports = ZStream;
  });
  require_common = __commonJS3((exports) => {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source)
          continue;
        if (typeof source !== "object")
          throw new TypeError(source + "must be non-object");
        for (var p2 in source)
          if (_has(source, p2))
            obj[p2] = source[p2];
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size)
        return buf;
      if (buf.subarray)
        return buf.subarray(0, size);
      return buf.length = size, buf;
    };
    var fnTyped = { arraySet: function(dest, src, src_offs, len2, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i4 = 0;i4 < len2; i4++)
        dest[dest_offs + i4] = src[src_offs + i4];
    }, flattenChunks: function(chunks) {
      var i4, l4, len2, pos, chunk, result;
      len2 = 0;
      for (i4 = 0, l4 = chunks.length;i4 < l4; i4++)
        len2 += chunks[i4].length;
      result = new Uint8Array(len2), pos = 0;
      for (i4 = 0, l4 = chunks.length;i4 < l4; i4++)
        chunk = chunks[i4], result.set(chunk, pos), pos += chunk.length;
      return result;
    } }, fnUntyped = { arraySet: function(dest, src, src_offs, len2, dest_offs) {
      for (var i4 = 0;i4 < len2; i4++)
        dest[dest_offs + i4] = src[src_offs + i4];
    }, flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    } };
    exports.setTyped = function(on3) {
      if (on3)
        exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, exports.assign(exports, fnTyped);
      else
        exports.Buf8 = Array, exports.Buf16 = Array, exports.Buf32 = Array, exports.assign(exports, fnUntyped);
    };
    exports.setTyped(TYPED_OK);
  });
  require_trees = __commonJS3((exports) => {
    var utils = require_common(), Z_FIXED = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN = 2;
    function zero(buf) {
      var len2 = buf.length;
      while (--len2 >= 0)
        buf[len2] = 0;
    }
    var STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH = 3, MAX_MATCH = 258, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc, static_d_desc, static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s3, w2) {
      s3.pending_buf[s3.pending++] = w2 & 255, s3.pending_buf[s3.pending++] = w2 >>> 8 & 255;
    }
    function send_bits(s3, value, length) {
      if (s3.bi_valid > Buf_size - length)
        s3.bi_buf |= value << s3.bi_valid & 65535, put_short(s3, s3.bi_buf), s3.bi_buf = value >> Buf_size - s3.bi_valid, s3.bi_valid += length - Buf_size;
      else
        s3.bi_buf |= value << s3.bi_valid & 65535, s3.bi_valid += length;
    }
    function send_code(s3, c2, tree) {
      send_bits(s3, tree[c2 * 2], tree[c2 * 2 + 1]);
    }
    function bi_reverse(code2, len2) {
      var res = 0;
      do
        res |= code2 & 1, code2 >>>= 1, res <<= 1;
      while (--len2 > 0);
      return res >>> 1;
    }
    function bi_flush(s3) {
      if (s3.bi_valid === 16)
        put_short(s3, s3.bi_buf), s3.bi_buf = 0, s3.bi_valid = 0;
      else if (s3.bi_valid >= 8)
        s3.pending_buf[s3.pending++] = s3.bi_buf & 255, s3.bi_buf >>= 8, s3.bi_valid -= 8;
    }
    function gen_bitlen(s3, desc) {
      var { dyn_tree: tree, max_code } = desc, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, h3, n2, m2, bits, xbits, f2, overflow = 0;
      for (bits = 0;bits <= MAX_BITS; bits++)
        s3.bl_count[bits] = 0;
      tree[s3.heap[s3.heap_max] * 2 + 1] = 0;
      for (h3 = s3.heap_max + 1;h3 < HEAP_SIZE; h3++) {
        if (n2 = s3.heap[h3], bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1, bits > max_length)
          bits = max_length, overflow++;
        if (tree[n2 * 2 + 1] = bits, n2 > max_code)
          continue;
        if (s3.bl_count[bits]++, xbits = 0, n2 >= base)
          xbits = extra[n2 - base];
        if (f2 = tree[n2 * 2], s3.opt_len += f2 * (bits + xbits), has_stree)
          s3.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
      }
      if (overflow === 0)
        return;
      do {
        bits = max_length - 1;
        while (s3.bl_count[bits] === 0)
          bits--;
        s3.bl_count[bits]--, s3.bl_count[bits + 1] += 2, s3.bl_count[max_length]--, overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length;bits !== 0; bits--) {
        n2 = s3.bl_count[bits];
        while (n2 !== 0) {
          if (m2 = s3.heap[--h3], m2 > max_code)
            continue;
          if (tree[m2 * 2 + 1] !== bits)
            s3.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2], tree[m2 * 2 + 1] = bits;
          n2--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1), code2 = 0, bits, n2;
      for (bits = 1;bits <= MAX_BITS; bits++)
        next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
      for (n2 = 0;n2 <= max_code; n2++) {
        var len2 = tree[n2 * 2 + 1];
        if (len2 === 0)
          continue;
        tree[n2 * 2] = bi_reverse(next_code[len2]++, len2);
      }
    }
    function tr_static_init() {
      var n2, bits, length, code2, dist, bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code2 = 0;code2 < LENGTH_CODES - 1; code2++) {
        base_length[code2] = length;
        for (n2 = 0;n2 < 1 << extra_lbits[code2]; n2++)
          _length_code[length++] = code2;
      }
      _length_code[length - 1] = code2, dist = 0;
      for (code2 = 0;code2 < 16; code2++) {
        base_dist[code2] = dist;
        for (n2 = 0;n2 < 1 << extra_dbits[code2]; n2++)
          _dist_code[dist++] = code2;
      }
      dist >>= 7;
      for (;code2 < D_CODES; code2++) {
        base_dist[code2] = dist << 7;
        for (n2 = 0;n2 < 1 << extra_dbits[code2] - 7; n2++)
          _dist_code[256 + dist++] = code2;
      }
      for (bits = 0;bits <= MAX_BITS; bits++)
        bl_count[bits] = 0;
      n2 = 0;
      while (n2 <= 143)
        static_ltree[n2 * 2 + 1] = 8, n2++, bl_count[8]++;
      while (n2 <= 255)
        static_ltree[n2 * 2 + 1] = 9, n2++, bl_count[9]++;
      while (n2 <= 279)
        static_ltree[n2 * 2 + 1] = 7, n2++, bl_count[7]++;
      while (n2 <= 287)
        static_ltree[n2 * 2 + 1] = 8, n2++, bl_count[8]++;
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n2 = 0;n2 < D_CODES; n2++)
        static_dtree[n2 * 2 + 1] = 5, static_dtree[n2 * 2] = bi_reverse(n2, 5);
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s3) {
      var n2;
      for (n2 = 0;n2 < L_CODES; n2++)
        s3.dyn_ltree[n2 * 2] = 0;
      for (n2 = 0;n2 < D_CODES; n2++)
        s3.dyn_dtree[n2 * 2] = 0;
      for (n2 = 0;n2 < BL_CODES; n2++)
        s3.bl_tree[n2 * 2] = 0;
      s3.dyn_ltree[END_BLOCK * 2] = 1, s3.opt_len = s3.static_len = 0, s3.last_lit = s3.matches = 0;
    }
    function bi_windup(s3) {
      if (s3.bi_valid > 8)
        put_short(s3, s3.bi_buf);
      else if (s3.bi_valid > 0)
        s3.pending_buf[s3.pending++] = s3.bi_buf;
      s3.bi_buf = 0, s3.bi_valid = 0;
    }
    function copy_block(s3, buf, len2, header) {
      if (bi_windup(s3), header)
        put_short(s3, len2), put_short(s3, ~len2);
      utils.arraySet(s3.pending_buf, s3.window, buf, len2, s3.pending), s3.pending += len2;
    }
    function smaller(tree, n2, m2, depth) {
      var _n2 = n2 * 2, _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
    }
    function pqdownheap(s3, tree, k2) {
      var v2 = s3.heap[k2], j2 = k2 << 1;
      while (j2 <= s3.heap_len) {
        if (j2 < s3.heap_len && smaller(tree, s3.heap[j2 + 1], s3.heap[j2], s3.depth))
          j2++;
        if (smaller(tree, v2, s3.heap[j2], s3.depth))
          break;
        s3.heap[k2] = s3.heap[j2], k2 = j2, j2 <<= 1;
      }
      s3.heap[k2] = v2;
    }
    function compress_block(s3, ltree, dtree) {
      var dist, lc, lx = 0, code2, extra;
      if (s3.last_lit !== 0)
        do
          if (dist = s3.pending_buf[s3.d_buf + lx * 2] << 8 | s3.pending_buf[s3.d_buf + lx * 2 + 1], lc = s3.pending_buf[s3.l_buf + lx], lx++, dist === 0)
            send_code(s3, lc, ltree);
          else {
            if (code2 = _length_code[lc], send_code(s3, code2 + LITERALS + 1, ltree), extra = extra_lbits[code2], extra !== 0)
              lc -= base_length[code2], send_bits(s3, lc, extra);
            if (dist--, code2 = d_code(dist), send_code(s3, code2, dtree), extra = extra_dbits[code2], extra !== 0)
              dist -= base_dist[code2], send_bits(s3, dist, extra);
          }
        while (lx < s3.last_lit);
      send_code(s3, END_BLOCK, ltree);
    }
    function build_tree(s3, desc) {
      var tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, n2, m2, max_code = -1, node;
      s3.heap_len = 0, s3.heap_max = HEAP_SIZE;
      for (n2 = 0;n2 < elems; n2++)
        if (tree[n2 * 2] !== 0)
          s3.heap[++s3.heap_len] = max_code = n2, s3.depth[n2] = 0;
        else
          tree[n2 * 2 + 1] = 0;
      while (s3.heap_len < 2)
        if (node = s3.heap[++s3.heap_len] = max_code < 2 ? ++max_code : 0, tree[node * 2] = 1, s3.depth[node] = 0, s3.opt_len--, has_stree)
          s3.static_len -= stree[node * 2 + 1];
      desc.max_code = max_code;
      for (n2 = s3.heap_len >> 1;n2 >= 1; n2--)
        pqdownheap(s3, tree, n2);
      node = elems;
      do
        n2 = s3.heap[1], s3.heap[1] = s3.heap[s3.heap_len--], pqdownheap(s3, tree, 1), m2 = s3.heap[1], s3.heap[--s3.heap_max] = n2, s3.heap[--s3.heap_max] = m2, tree[node * 2] = tree[n2 * 2] + tree[m2 * 2], s3.depth[node] = (s3.depth[n2] >= s3.depth[m2] ? s3.depth[n2] : s3.depth[m2]) + 1, tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node, s3.heap[1] = node++, pqdownheap(s3, tree, 1);
      while (s3.heap_len >= 2);
      s3.heap[--s3.heap_max] = s3.heap[1], gen_bitlen(s3, desc), gen_codes(tree, max_code, s3.bl_count);
    }
    function scan_tree(s3, tree, max_code) {
      var n2, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
      if (nextlen === 0)
        max_count = 138, min_count = 3;
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0;n2 <= max_code; n2++) {
        if (curlen = nextlen, nextlen = tree[(n2 + 1) * 2 + 1], ++count < max_count && curlen === nextlen)
          continue;
        else if (count < min_count)
          s3.bl_tree[curlen * 2] += count;
        else if (curlen !== 0) {
          if (curlen !== prevlen)
            s3.bl_tree[curlen * 2]++;
          s3.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10)
          s3.bl_tree[REPZ_3_10 * 2]++;
        else
          s3.bl_tree[REPZ_11_138 * 2]++;
        if (count = 0, prevlen = curlen, nextlen === 0)
          max_count = 138, min_count = 3;
        else if (curlen === nextlen)
          max_count = 6, min_count = 3;
        else
          max_count = 7, min_count = 4;
      }
    }
    function send_tree(s3, tree, max_code) {
      var n2, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
      if (nextlen === 0)
        max_count = 138, min_count = 3;
      for (n2 = 0;n2 <= max_code; n2++) {
        if (curlen = nextlen, nextlen = tree[(n2 + 1) * 2 + 1], ++count < max_count && curlen === nextlen)
          continue;
        else if (count < min_count)
          do
            send_code(s3, curlen, s3.bl_tree);
          while (--count !== 0);
        else if (curlen !== 0) {
          if (curlen !== prevlen)
            send_code(s3, curlen, s3.bl_tree), count--;
          send_code(s3, REP_3_6, s3.bl_tree), send_bits(s3, count - 3, 2);
        } else if (count <= 10)
          send_code(s3, REPZ_3_10, s3.bl_tree), send_bits(s3, count - 3, 3);
        else
          send_code(s3, REPZ_11_138, s3.bl_tree), send_bits(s3, count - 11, 7);
        if (count = 0, prevlen = curlen, nextlen === 0)
          max_count = 138, min_count = 3;
        else if (curlen === nextlen)
          max_count = 6, min_count = 3;
        else
          max_count = 7, min_count = 4;
      }
    }
    function build_bl_tree(s3) {
      var max_blindex;
      scan_tree(s3, s3.dyn_ltree, s3.l_desc.max_code), scan_tree(s3, s3.dyn_dtree, s3.d_desc.max_code), build_tree(s3, s3.bl_desc);
      for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--)
        if (s3.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)
          break;
      return s3.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;
    }
    function send_all_trees(s3, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s3, lcodes - 257, 5), send_bits(s3, dcodes - 1, 5), send_bits(s3, blcodes - 4, 4);
      for (rank = 0;rank < blcodes; rank++)
        send_bits(s3, s3.bl_tree[bl_order[rank] * 2 + 1], 3);
      send_tree(s3, s3.dyn_ltree, lcodes - 1), send_tree(s3, s3.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s3) {
      var black_mask = 4093624447, n2;
      for (n2 = 0;n2 <= 31; n2++, black_mask >>>= 1)
        if (black_mask & 1 && s3.dyn_ltree[n2 * 2] !== 0)
          return Z_BINARY;
      if (s3.dyn_ltree[18] !== 0 || s3.dyn_ltree[20] !== 0 || s3.dyn_ltree[26] !== 0)
        return Z_TEXT;
      for (n2 = 32;n2 < LITERALS; n2++)
        if (s3.dyn_ltree[n2 * 2] !== 0)
          return Z_TEXT;
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s3) {
      if (!static_init_done)
        tr_static_init(), static_init_done = true;
      s3.l_desc = new TreeDesc(s3.dyn_ltree, static_l_desc), s3.d_desc = new TreeDesc(s3.dyn_dtree, static_d_desc), s3.bl_desc = new TreeDesc(s3.bl_tree, static_bl_desc), s3.bi_buf = 0, s3.bi_valid = 0, init_block(s3);
    }
    function _tr_stored_block(s3, buf, stored_len, last) {
      send_bits(s3, (STORED_BLOCK << 1) + (last ? 1 : 0), 3), copy_block(s3, buf, stored_len, true);
    }
    function _tr_align(s3) {
      send_bits(s3, STATIC_TREES << 1, 3), send_code(s3, END_BLOCK, static_ltree), bi_flush(s3);
    }
    function _tr_flush_block(s3, buf, stored_len, last) {
      var opt_lenb, static_lenb, max_blindex = 0;
      if (s3.level > 0) {
        if (s3.strm.data_type === Z_UNKNOWN)
          s3.strm.data_type = detect_data_type(s3);
        if (build_tree(s3, s3.l_desc), build_tree(s3, s3.d_desc), max_blindex = build_bl_tree(s3), opt_lenb = s3.opt_len + 3 + 7 >>> 3, static_lenb = s3.static_len + 3 + 7 >>> 3, static_lenb <= opt_lenb)
          opt_lenb = static_lenb;
      } else
        opt_lenb = static_lenb = stored_len + 5;
      if (stored_len + 4 <= opt_lenb && buf !== -1)
        _tr_stored_block(s3, buf, stored_len, last);
      else if (s3.strategy === Z_FIXED || static_lenb === opt_lenb)
        send_bits(s3, (STATIC_TREES << 1) + (last ? 1 : 0), 3), compress_block(s3, static_ltree, static_dtree);
      else
        send_bits(s3, (DYN_TREES << 1) + (last ? 1 : 0), 3), send_all_trees(s3, s3.l_desc.max_code + 1, s3.d_desc.max_code + 1, max_blindex + 1), compress_block(s3, s3.dyn_ltree, s3.dyn_dtree);
      if (init_block(s3), last)
        bi_windup(s3);
    }
    function _tr_tally(s3, dist, lc) {
      if (s3.pending_buf[s3.d_buf + s3.last_lit * 2] = dist >>> 8 & 255, s3.pending_buf[s3.d_buf + s3.last_lit * 2 + 1] = dist & 255, s3.pending_buf[s3.l_buf + s3.last_lit] = lc & 255, s3.last_lit++, dist === 0)
        s3.dyn_ltree[lc * 2]++;
      else
        s3.matches++, dist--, s3.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++, s3.dyn_dtree[d_code(dist) * 2]++;
      return s3.last_lit === s3.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  });
  require_adler32 = __commonJS3((exports, module2) => {
    function adler32(adler, buf, len2, pos) {
      var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len2 !== 0) {
        n2 = len2 > 2000 ? 2000 : len2, len2 -= n2;
        do
          s1 = s1 + buf[pos++] | 0, s22 = s22 + s1 | 0;
        while (--n2);
        s1 %= 65521, s22 %= 65521;
      }
      return s1 | s22 << 16 | 0;
    }
    module2.exports = adler32;
  });
  require_crc32 = __commonJS3((exports, module2) => {
    function makeTable() {
      var c2, table = [];
      for (var n2 = 0;n2 < 256; n2++) {
        c2 = n2;
        for (var k2 = 0;k2 < 8; k2++)
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        table[n2] = c2;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len2, pos) {
      var t = crcTable, end = pos + len2;
      crc ^= -1;
      for (var i4 = pos;i4 < end; i4++)
        crc = crc >>> 8 ^ t[(crc ^ buf[i4]) & 255];
      return crc ^ -1;
    }
    module2.exports = crc32;
  });
  require_messages = __commonJS3((exports, module2) => {
    module2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  });
  require_deflate = __commonJS3((exports) => {
    var utils = require_common(), trees = require_trees(), adler32 = require_adler32(), crc32 = require_crc32(), msg = require_messages(), Z_NO_FLUSH = 0, Z_PARTIAL_FLUSH = 1, Z_FULL_FLUSH = 3, Z_FINISH = 4, Z_BLOCK = 5, Z_OK = 0, Z_STREAM_END = 1, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_BUF_ERROR = -5, Z_DEFAULT_COMPRESSION = -1, Z_FILTERED = 1, Z_HUFFMAN_ONLY = 2, Z_RLE = 3, Z_FIXED = 4, Z_DEFAULT_STRATEGY = 0, Z_UNKNOWN = 2, Z_DEFLATED = 8, MAX_MEM_LEVEL = 9, MAX_WBITS = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3;
    function err2(strm, errorCode) {
      return strm.msg = msg[errorCode], errorCode;
    }
    function rank(f2) {
      return (f2 << 1) - (f2 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len2 = buf.length;
      while (--len2 >= 0)
        buf[len2] = 0;
    }
    function flush_pending(strm) {
      var s3 = strm.state, len2 = s3.pending;
      if (len2 > strm.avail_out)
        len2 = strm.avail_out;
      if (len2 === 0)
        return;
      if (utils.arraySet(strm.output, s3.pending_buf, s3.pending_out, len2, strm.next_out), strm.next_out += len2, s3.pending_out += len2, strm.total_out += len2, strm.avail_out -= len2, s3.pending -= len2, s3.pending === 0)
        s3.pending_out = 0;
    }
    function flush_block_only(s3, last) {
      trees._tr_flush_block(s3, s3.block_start >= 0 ? s3.block_start : -1, s3.strstart - s3.block_start, last), s3.block_start = s3.strstart, flush_pending(s3.strm);
    }
    function put_byte(s3, b3) {
      s3.pending_buf[s3.pending++] = b3;
    }
    function putShortMSB(s3, b3) {
      s3.pending_buf[s3.pending++] = b3 >>> 8 & 255, s3.pending_buf[s3.pending++] = b3 & 255;
    }
    function read_buf(strm, buf, start2, size) {
      var len2 = strm.avail_in;
      if (len2 > size)
        len2 = size;
      if (len2 === 0)
        return 0;
      if (strm.avail_in -= len2, utils.arraySet(buf, strm.input, strm.next_in, len2, start2), strm.state.wrap === 1)
        strm.adler = adler32(strm.adler, buf, len2, start2);
      else if (strm.state.wrap === 2)
        strm.adler = crc32(strm.adler, buf, len2, start2);
      return strm.next_in += len2, strm.total_in += len2, len2;
    }
    function longest_match(s3, cur_match) {
      var { max_chain_length: chain_length, strstart: scan } = s3, match2, len2, best_len = s3.prev_length, nice_match = s3.nice_match, limit = s3.strstart > s3.w_size - MIN_LOOKAHEAD ? s3.strstart - (s3.w_size - MIN_LOOKAHEAD) : 0, _win = s3.window, wmask = s3.w_mask, prev = s3.prev, strend = s3.strstart + MAX_MATCH, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
      if (s3.prev_length >= s3.good_match)
        chain_length >>= 2;
      if (nice_match > s3.lookahead)
        nice_match = s3.lookahead;
      do {
        if (match2 = cur_match, _win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1])
          continue;
        scan += 2, match2++;
        do
          ;
        while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
        if (len2 = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, len2 > best_len) {
          if (s3.match_start = cur_match, best_len = len2, len2 >= nice_match)
            break;
          scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s3.lookahead)
        return best_len;
      return s3.lookahead;
    }
    function fill_window(s3) {
      var _w_size = s3.w_size, p2, n2, m2, more, str;
      do {
        if (more = s3.window_size - s3.lookahead - s3.strstart, s3.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s3.window, s3.window, _w_size, _w_size, 0), s3.match_start -= _w_size, s3.strstart -= _w_size, s3.block_start -= _w_size, n2 = s3.hash_size, p2 = n2;
          do
            m2 = s3.head[--p2], s3.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          while (--n2);
          n2 = _w_size, p2 = n2;
          do
            m2 = s3.prev[--p2], s3.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          while (--n2);
          more += _w_size;
        }
        if (s3.strm.avail_in === 0)
          break;
        if (n2 = read_buf(s3.strm, s3.window, s3.strstart + s3.lookahead, more), s3.lookahead += n2, s3.lookahead + s3.insert >= MIN_MATCH) {
          str = s3.strstart - s3.insert, s3.ins_h = s3.window[str], s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + 1]) & s3.hash_mask;
          while (s3.insert)
            if (s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + MIN_MATCH - 1]) & s3.hash_mask, s3.prev[str & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = str, str++, s3.insert--, s3.lookahead + s3.insert < MIN_MATCH)
              break;
        }
      } while (s3.lookahead < MIN_LOOKAHEAD && s3.strm.avail_in !== 0);
    }
    function deflate_stored(s3, flush) {
      var max_block_size = 65535;
      if (max_block_size > s3.pending_buf_size - 5)
        max_block_size = s3.pending_buf_size - 5;
      for (;; ) {
        if (s3.lookahead <= 1) {
          if (fill_window(s3), s3.lookahead === 0 && flush === Z_NO_FLUSH)
            return BS_NEED_MORE;
          if (s3.lookahead === 0)
            break;
        }
        s3.strstart += s3.lookahead, s3.lookahead = 0;
        var max_start = s3.block_start + max_block_size;
        if (s3.strstart === 0 || s3.strstart >= max_start) {
          if (s3.lookahead = s3.strstart - max_start, s3.strstart = max_start, flush_block_only(s3, false), s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        }
        if (s3.strstart - s3.block_start >= s3.w_size - MIN_LOOKAHEAD) {
          if (flush_block_only(s3, false), s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        }
      }
      if (s3.insert = 0, flush === Z_FINISH) {
        if (flush_block_only(s3, true), s3.strm.avail_out === 0)
          return BS_FINISH_STARTED;
        return BS_FINISH_DONE;
      }
      if (s3.strstart > s3.block_start) {
        if (flush_block_only(s3, false), s3.strm.avail_out === 0)
          return BS_NEED_MORE;
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s3, flush) {
      var hash_head, bflush;
      for (;; ) {
        if (s3.lookahead < MIN_LOOKAHEAD) {
          if (fill_window(s3), s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
            return BS_NEED_MORE;
          if (s3.lookahead === 0)
            break;
        }
        if (hash_head = 0, s3.lookahead >= MIN_MATCH)
          s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask, hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = s3.strstart;
        if (hash_head !== 0 && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD)
          s3.match_length = longest_match(s3, hash_head);
        if (s3.match_length >= MIN_MATCH)
          if (bflush = trees._tr_tally(s3, s3.strstart - s3.match_start, s3.match_length - MIN_MATCH), s3.lookahead -= s3.match_length, s3.match_length <= s3.max_lazy_match && s3.lookahead >= MIN_MATCH) {
            s3.match_length--;
            do
              s3.strstart++, s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask, hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = s3.strstart;
            while (--s3.match_length !== 0);
            s3.strstart++;
          } else
            s3.strstart += s3.match_length, s3.match_length = 0, s3.ins_h = s3.window[s3.strstart], s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + 1]) & s3.hash_mask;
        else
          bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]), s3.lookahead--, s3.strstart++;
        if (bflush) {
          if (flush_block_only(s3, false), s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        }
      }
      if (s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1, flush === Z_FINISH) {
        if (flush_block_only(s3, true), s3.strm.avail_out === 0)
          return BS_FINISH_STARTED;
        return BS_FINISH_DONE;
      }
      if (s3.last_lit) {
        if (flush_block_only(s3, false), s3.strm.avail_out === 0)
          return BS_NEED_MORE;
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s3, flush) {
      var hash_head, bflush, max_insert;
      for (;; ) {
        if (s3.lookahead < MIN_LOOKAHEAD) {
          if (fill_window(s3), s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
            return BS_NEED_MORE;
          if (s3.lookahead === 0)
            break;
        }
        if (hash_head = 0, s3.lookahead >= MIN_MATCH)
          s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask, hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = s3.strstart;
        if (s3.prev_length = s3.match_length, s3.prev_match = s3.match_start, s3.match_length = MIN_MATCH - 1, hash_head !== 0 && s3.prev_length < s3.max_lazy_match && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
          if (s3.match_length = longest_match(s3, hash_head), s3.match_length <= 5 && (s3.strategy === Z_FILTERED || s3.match_length === MIN_MATCH && s3.strstart - s3.match_start > 4096))
            s3.match_length = MIN_MATCH - 1;
        }
        if (s3.prev_length >= MIN_MATCH && s3.match_length <= s3.prev_length) {
          max_insert = s3.strstart + s3.lookahead - MIN_MATCH, bflush = trees._tr_tally(s3, s3.strstart - 1 - s3.prev_match, s3.prev_length - MIN_MATCH), s3.lookahead -= s3.prev_length - 1, s3.prev_length -= 2;
          do
            if (++s3.strstart <= max_insert)
              s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask, hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = s3.strstart;
          while (--s3.prev_length !== 0);
          if (s3.match_available = 0, s3.match_length = MIN_MATCH - 1, s3.strstart++, bflush) {
            if (flush_block_only(s3, false), s3.strm.avail_out === 0)
              return BS_NEED_MORE;
          }
        } else if (s3.match_available) {
          if (bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart - 1]), bflush)
            flush_block_only(s3, false);
          if (s3.strstart++, s3.lookahead--, s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        } else
          s3.match_available = 1, s3.strstart++, s3.lookahead--;
      }
      if (s3.match_available)
        bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart - 1]), s3.match_available = 0;
      if (s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1, flush === Z_FINISH) {
        if (flush_block_only(s3, true), s3.strm.avail_out === 0)
          return BS_FINISH_STARTED;
        return BS_FINISH_DONE;
      }
      if (s3.last_lit) {
        if (flush_block_only(s3, false), s3.strm.avail_out === 0)
          return BS_NEED_MORE;
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s3, flush) {
      var bflush, prev, scan, strend, _win = s3.window;
      for (;; ) {
        if (s3.lookahead <= MAX_MATCH) {
          if (fill_window(s3), s3.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)
            return BS_NEED_MORE;
          if (s3.lookahead === 0)
            break;
        }
        if (s3.match_length = 0, s3.lookahead >= MIN_MATCH && s3.strstart > 0) {
          if (scan = s3.strstart - 1, prev = _win[scan], prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s3.strstart + MAX_MATCH;
            do
              ;
            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            if (s3.match_length = MAX_MATCH - (strend - scan), s3.match_length > s3.lookahead)
              s3.match_length = s3.lookahead;
          }
        }
        if (s3.match_length >= MIN_MATCH)
          bflush = trees._tr_tally(s3, 1, s3.match_length - MIN_MATCH), s3.lookahead -= s3.match_length, s3.strstart += s3.match_length, s3.match_length = 0;
        else
          bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]), s3.lookahead--, s3.strstart++;
        if (bflush) {
          if (flush_block_only(s3, false), s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        }
      }
      if (s3.insert = 0, flush === Z_FINISH) {
        if (flush_block_only(s3, true), s3.strm.avail_out === 0)
          return BS_FINISH_STARTED;
        return BS_FINISH_DONE;
      }
      if (s3.last_lit) {
        if (flush_block_only(s3, false), s3.strm.avail_out === 0)
          return BS_NEED_MORE;
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s3, flush) {
      var bflush;
      for (;; ) {
        if (s3.lookahead === 0) {
          if (fill_window(s3), s3.lookahead === 0) {
            if (flush === Z_NO_FLUSH)
              return BS_NEED_MORE;
            break;
          }
        }
        if (s3.match_length = 0, bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]), s3.lookahead--, s3.strstart++, bflush) {
          if (flush_block_only(s3, false), s3.strm.avail_out === 0)
            return BS_NEED_MORE;
        }
      }
      if (s3.insert = 0, flush === Z_FINISH) {
        if (flush_block_only(s3, true), s3.strm.avail_out === 0)
          return BS_FINISH_STARTED;
        return BS_FINISH_DONE;
      }
      if (s3.last_lit) {
        if (flush_block_only(s3, false), s3.strm.avail_out === 0)
          return BS_NEED_MORE;
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func2) {
      this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, this.max_chain = max_chain, this.func = func2;
    }
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s3) {
      s3.window_size = 2 * s3.w_size, zero(s3.head), s3.max_lazy_match = configuration_table[s3.level].max_lazy, s3.good_match = configuration_table[s3.level].good_length, s3.nice_match = configuration_table[s3.level].nice_length, s3.max_chain_length = configuration_table[s3.level].max_chain, s3.strstart = 0, s3.block_start = 0, s3.lookahead = 0, s3.insert = 0, s3.match_length = s3.prev_length = MIN_MATCH - 1, s3.match_available = 0, s3.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2), this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2), this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s3;
      if (!strm || !strm.state)
        return err2(strm, Z_STREAM_ERROR);
      if (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, s3 = strm.state, s3.pending = 0, s3.pending_out = 0, s3.wrap < 0)
        s3.wrap = -s3.wrap;
      return s3.status = s3.wrap ? INIT_STATE : BUSY_STATE, strm.adler = s3.wrap === 2 ? 0 : 1, s3.last_flush = Z_NO_FLUSH, trees._tr_init(s3), Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK)
        lm_init(strm.state);
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (strm.state.wrap !== 2)
        return Z_STREAM_ERROR;
      return strm.state.gzhead = head, Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm)
        return Z_STREAM_ERROR;
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION)
        level = 6;
      if (windowBits < 0)
        wrap = 0, windowBits = -windowBits;
      else if (windowBits > 15)
        wrap = 2, windowBits -= 16;
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)
        return err2(strm, Z_STREAM_ERROR);
      if (windowBits === 8)
        windowBits = 9;
      var s3 = new DeflateState;
      return strm.state = s3, s3.strm = strm, s3.wrap = wrap, s3.gzhead = null, s3.w_bits = windowBits, s3.w_size = 1 << s3.w_bits, s3.w_mask = s3.w_size - 1, s3.hash_bits = memLevel + 7, s3.hash_size = 1 << s3.hash_bits, s3.hash_mask = s3.hash_size - 1, s3.hash_shift = ~~((s3.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s3.window = new utils.Buf8(s3.w_size * 2), s3.head = new utils.Buf16(s3.hash_size), s3.prev = new utils.Buf16(s3.w_size), s3.lit_bufsize = 1 << memLevel + 6, s3.pending_buf_size = s3.lit_bufsize * 4, s3.pending_buf = new utils.Buf8(s3.pending_buf_size), s3.d_buf = 1 * s3.lit_bufsize, s3.l_buf = 3 * s3.lit_bufsize, s3.level = level, s3.strategy = strategy, s3.method = method, deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s3, beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)
        return strm ? err2(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      if (s3 = strm.state, !strm.output || !strm.input && strm.avail_in !== 0 || s3.status === FINISH_STATE && flush !== Z_FINISH)
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      if (s3.strm = strm, old_flush = s3.last_flush, s3.last_flush = flush, s3.status === INIT_STATE)
        if (s3.wrap === 2)
          if (strm.adler = 0, put_byte(s3, 31), put_byte(s3, 139), put_byte(s3, 8), !s3.gzhead)
            put_byte(s3, 0), put_byte(s3, 0), put_byte(s3, 0), put_byte(s3, 0), put_byte(s3, 0), put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0), put_byte(s3, OS_CODE), s3.status = BUSY_STATE;
          else {
            if (put_byte(s3, (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (!s3.gzhead.extra ? 0 : 4) + (!s3.gzhead.name ? 0 : 8) + (!s3.gzhead.comment ? 0 : 16)), put_byte(s3, s3.gzhead.time & 255), put_byte(s3, s3.gzhead.time >> 8 & 255), put_byte(s3, s3.gzhead.time >> 16 & 255), put_byte(s3, s3.gzhead.time >> 24 & 255), put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0), put_byte(s3, s3.gzhead.os & 255), s3.gzhead.extra && s3.gzhead.extra.length)
              put_byte(s3, s3.gzhead.extra.length & 255), put_byte(s3, s3.gzhead.extra.length >> 8 & 255);
            if (s3.gzhead.hcrc)
              strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending, 0);
            s3.gzindex = 0, s3.status = EXTRA_STATE;
          }
        else {
          var header = Z_DEFLATED + (s3.w_bits - 8 << 4) << 8, level_flags = -1;
          if (s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2)
            level_flags = 0;
          else if (s3.level < 6)
            level_flags = 1;
          else if (s3.level === 6)
            level_flags = 2;
          else
            level_flags = 3;
          if (header |= level_flags << 6, s3.strstart !== 0)
            header |= PRESET_DICT;
          if (header += 31 - header % 31, s3.status = BUSY_STATE, putShortMSB(s3, header), s3.strstart !== 0)
            putShortMSB(s3, strm.adler >>> 16), putShortMSB(s3, strm.adler & 65535);
          strm.adler = 1;
        }
      if (s3.status === EXTRA_STATE)
        if (s3.gzhead.extra) {
          beg = s3.pending;
          while (s3.gzindex < (s3.gzhead.extra.length & 65535)) {
            if (s3.pending === s3.pending_buf_size) {
              if (s3.gzhead.hcrc && s3.pending > beg)
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              if (flush_pending(strm), beg = s3.pending, s3.pending === s3.pending_buf_size)
                break;
            }
            put_byte(s3, s3.gzhead.extra[s3.gzindex] & 255), s3.gzindex++;
          }
          if (s3.gzhead.hcrc && s3.pending > beg)
            strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          if (s3.gzindex === s3.gzhead.extra.length)
            s3.gzindex = 0, s3.status = NAME_STATE;
        } else
          s3.status = NAME_STATE;
      if (s3.status === NAME_STATE)
        if (s3.gzhead.name) {
          beg = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size) {
              if (s3.gzhead.hcrc && s3.pending > beg)
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              if (flush_pending(strm), beg = s3.pending, s3.pending === s3.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s3.gzindex < s3.gzhead.name.length)
              val = s3.gzhead.name.charCodeAt(s3.gzindex++) & 255;
            else
              val = 0;
            put_byte(s3, val);
          } while (val !== 0);
          if (s3.gzhead.hcrc && s3.pending > beg)
            strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          if (val === 0)
            s3.gzindex = 0, s3.status = COMMENT_STATE;
        } else
          s3.status = COMMENT_STATE;
      if (s3.status === COMMENT_STATE)
        if (s3.gzhead.comment) {
          beg = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size) {
              if (s3.gzhead.hcrc && s3.pending > beg)
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              if (flush_pending(strm), beg = s3.pending, s3.pending === s3.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s3.gzindex < s3.gzhead.comment.length)
              val = s3.gzhead.comment.charCodeAt(s3.gzindex++) & 255;
            else
              val = 0;
            put_byte(s3, val);
          } while (val !== 0);
          if (s3.gzhead.hcrc && s3.pending > beg)
            strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          if (val === 0)
            s3.status = HCRC_STATE;
        } else
          s3.status = HCRC_STATE;
      if (s3.status === HCRC_STATE)
        if (s3.gzhead.hcrc) {
          if (s3.pending + 2 > s3.pending_buf_size)
            flush_pending(strm);
          if (s3.pending + 2 <= s3.pending_buf_size)
            put_byte(s3, strm.adler & 255), put_byte(s3, strm.adler >> 8 & 255), strm.adler = 0, s3.status = BUSY_STATE;
        } else
          s3.status = BUSY_STATE;
      if (s3.pending !== 0) {
        if (flush_pending(strm), strm.avail_out === 0)
          return s3.last_flush = -1, Z_OK;
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)
        return err2(strm, Z_BUF_ERROR);
      if (s3.status === FINISH_STATE && strm.avail_in !== 0)
        return err2(strm, Z_BUF_ERROR);
      if (strm.avail_in !== 0 || s3.lookahead !== 0 || flush !== Z_NO_FLUSH && s3.status !== FINISH_STATE) {
        var bstate = s3.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s3, flush) : s3.strategy === Z_RLE ? deflate_rle(s3, flush) : configuration_table[s3.level].func(s3, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)
          s3.status = FINISH_STATE;
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0)
            s3.last_flush = -1;
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH)
            trees._tr_align(s3);
          else if (flush !== Z_BLOCK) {
            if (trees._tr_stored_block(s3, 0, 0, false), flush === Z_FULL_FLUSH) {
              if (zero(s3.head), s3.lookahead === 0)
                s3.strstart = 0, s3.block_start = 0, s3.insert = 0;
            }
          }
          if (flush_pending(strm), strm.avail_out === 0)
            return s3.last_flush = -1, Z_OK;
        }
      }
      if (flush !== Z_FINISH)
        return Z_OK;
      if (s3.wrap <= 0)
        return Z_STREAM_END;
      if (s3.wrap === 2)
        put_byte(s3, strm.adler & 255), put_byte(s3, strm.adler >> 8 & 255), put_byte(s3, strm.adler >> 16 & 255), put_byte(s3, strm.adler >> 24 & 255), put_byte(s3, strm.total_in & 255), put_byte(s3, strm.total_in >> 8 & 255), put_byte(s3, strm.total_in >> 16 & 255), put_byte(s3, strm.total_in >> 24 & 255);
      else
        putShortMSB(s3, strm.adler >>> 16), putShortMSB(s3, strm.adler & 65535);
      if (flush_pending(strm), s3.wrap > 0)
        s3.wrap = -s3.wrap;
      return s3.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (status = strm.state.status, status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)
        return err2(strm, Z_STREAM_ERROR);
      return strm.state = null, status === BUSY_STATE ? err2(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length, s3, str, n2, wrap, avail, next, input, tmpDict;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (s3 = strm.state, wrap = s3.wrap, wrap === 2 || wrap === 1 && s3.status !== INIT_STATE || s3.lookahead)
        return Z_STREAM_ERROR;
      if (wrap === 1)
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      if (s3.wrap = 0, dictLength >= s3.w_size) {
        if (wrap === 0)
          zero(s3.head), s3.strstart = 0, s3.block_start = 0, s3.insert = 0;
        tmpDict = new utils.Buf8(s3.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s3.w_size, s3.w_size, 0), dictionary = tmpDict, dictLength = s3.w_size;
      }
      avail = strm.avail_in, next = strm.next_in, input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, fill_window(s3);
      while (s3.lookahead >= MIN_MATCH) {
        str = s3.strstart, n2 = s3.lookahead - (MIN_MATCH - 1);
        do
          s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + MIN_MATCH - 1]) & s3.hash_mask, s3.prev[str & s3.w_mask] = s3.head[s3.ins_h], s3.head[s3.ins_h] = str, str++;
        while (--n2);
        s3.strstart = str, s3.lookahead = MIN_MATCH - 1, fill_window(s3);
      }
      return s3.strstart += s3.lookahead, s3.block_start = s3.strstart, s3.insert = s3.lookahead, s3.lookahead = 0, s3.match_length = s3.prev_length = MIN_MATCH - 1, s3.match_available = 0, strm.next_in = next, strm.input = input, strm.avail_in = avail, s3.wrap = wrap, Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  });
  require_inffast = __commonJS3((exports, module2) => {
    var BAD = 30, TYPE = 12;
    module2.exports = function inflate_fast(strm, start2) {
      var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len2, dist, from2, from_source, input, output;
      state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), _out = strm.next_out, output = strm.output, beg = _out - (start2 - strm.avail_out), end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15)
            hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;
          here = lcode[hold & lmask];
          dolen:
            for (;; ) {
              if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op === 0)
                output[_out++] = here & 65535;
              else if (op & 16) {
                if (len2 = here & 65535, op &= 15, op) {
                  if (bits < op)
                    hold += input[_in++] << bits, bits += 8;
                  len2 += hold & (1 << op) - 1, hold >>>= op, bits -= op;
                }
                if (bits < 15)
                  hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;
                here = dcode[hold & dmask];
                dodist:
                  for (;; ) {
                    if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op & 16) {
                      if (dist = here & 65535, op &= 15, bits < op) {
                        if (hold += input[_in++] << bits, bits += 8, bits < op)
                          hold += input[_in++] << bits, bits += 8;
                      }
                      if (dist += hold & (1 << op) - 1, dist > dmax) {
                        strm.msg = "invalid distance too far back", state.mode = BAD;
                        break top;
                      }
                      if (hold >>>= op, bits -= op, op = _out - beg, dist > op) {
                        if (op = dist - op, op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back", state.mode = BAD;
                            break top;
                          }
                        }
                        if (from2 = 0, from_source = s_window, wnext === 0) {
                          if (from2 += wsize - op, op < len2) {
                            len2 -= op;
                            do
                              output[_out++] = s_window[from2++];
                            while (--op);
                            from2 = _out - dist, from_source = output;
                          }
                        } else if (wnext < op) {
                          if (from2 += wsize + wnext - op, op -= wnext, op < len2) {
                            len2 -= op;
                            do
                              output[_out++] = s_window[from2++];
                            while (--op);
                            if (from2 = 0, wnext < len2) {
                              op = wnext, len2 -= op;
                              do
                                output[_out++] = s_window[from2++];
                              while (--op);
                              from2 = _out - dist, from_source = output;
                            }
                          }
                        } else if (from2 += wnext - op, op < len2) {
                          len2 -= op;
                          do
                            output[_out++] = s_window[from2++];
                          while (--op);
                          from2 = _out - dist, from_source = output;
                        }
                        while (len2 > 2)
                          output[_out++] = from_source[from2++], output[_out++] = from_source[from2++], output[_out++] = from_source[from2++], len2 -= 3;
                        if (len2) {
                          if (output[_out++] = from_source[from2++], len2 > 1)
                            output[_out++] = from_source[from2++];
                        }
                      } else {
                        from2 = _out - dist;
                        do
                          output[_out++] = output[from2++], output[_out++] = output[from2++], output[_out++] = output[from2++], len2 -= 3;
                        while (len2 > 2);
                        if (len2) {
                          if (output[_out++] = output[from2++], len2 > 1)
                            output[_out++] = output[from2++];
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code", state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code", state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len2 = bits >> 3, _in -= len2, bits -= len2 << 3, hold &= (1 << bits) - 1, strm.next_in = _in, strm.next_out = _out, strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last), strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end), state.hold = hold, state.bits = bits;
      return;
    };
  });
  require_inftrees = __commonJS3((exports, module2) => {
    var utils = require_common(), MAXBITS = 15, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, CODES = 0, LENS = 1, DISTS = 2, lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits, len2 = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, incr, fill2, low, mask, next, base = null, base_index = 0, end, count = new utils.Buf16(MAXBITS + 1), offs = new utils.Buf16(MAXBITS + 1), extra = null, extra_index = 0, here_bits, here_op, here_val;
      for (len2 = 0;len2 <= MAXBITS; len2++)
        count[len2] = 0;
      for (sym = 0;sym < codes; sym++)
        count[lens[lens_index + sym]]++;
      root = bits;
      for (max = MAXBITS;max >= 1; max--)
        if (count[max] !== 0)
          break;
      if (root > max)
        root = max;
      if (max === 0)
        return table[table_index++] = 20971520, table[table_index++] = 20971520, opts.bits = 1, 0;
      for (min = 1;min < max; min++)
        if (count[min] !== 0)
          break;
      if (root < min)
        root = min;
      left = 1;
      for (len2 = 1;len2 <= MAXBITS; len2++)
        if (left <<= 1, left -= count[len2], left < 0)
          return -1;
      if (left > 0 && (type === CODES || max !== 1))
        return -1;
      offs[1] = 0;
      for (len2 = 1;len2 < MAXBITS; len2++)
        offs[len2 + 1] = offs[len2] + count[len2];
      for (sym = 0;sym < codes; sym++)
        if (lens[lens_index + sym] !== 0)
          work[offs[lens[lens_index + sym]]++] = sym;
      if (type === CODES)
        base = extra = work, end = 19;
      else if (type === LENS)
        base = lbase, base_index -= 257, extra = lext, extra_index -= 257, end = 256;
      else
        base = dbase, extra = dext, end = -1;
      if (huff = 0, sym = 0, len2 = min, next = table_index, curr = root, drop = 0, low = -1, used = 1 << root, mask = used - 1, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)
        return 1;
      for (;; ) {
        if (here_bits = len2 - drop, work[sym] < end)
          here_op = 0, here_val = work[sym];
        else if (work[sym] > end)
          here_op = extra[extra_index + work[sym]], here_val = base[base_index + work[sym]];
        else
          here_op = 96, here_val = 0;
        incr = 1 << len2 - drop, fill2 = 1 << curr, min = fill2;
        do
          fill2 -= incr, table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
        while (fill2 !== 0);
        incr = 1 << len2 - 1;
        while (huff & incr)
          incr >>= 1;
        if (incr !== 0)
          huff &= incr - 1, huff += incr;
        else
          huff = 0;
        if (sym++, --count[len2] === 0) {
          if (len2 === max)
            break;
          len2 = lens[lens_index + work[sym]];
        }
        if (len2 > root && (huff & mask) !== low) {
          if (drop === 0)
            drop = root;
          next += min, curr = len2 - drop, left = 1 << curr;
          while (curr + drop < max) {
            if (left -= count[curr + drop], left <= 0)
              break;
            curr++, left <<= 1;
          }
          if (used += 1 << curr, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)
            return 1;
          low = huff & mask, table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0)
        table[next + huff] = len2 - drop << 24 | 4194304 | 0;
      return opts.bits = root, 0;
    };
  });
  require_inflate = __commonJS3((exports) => {
    var utils = require_common(), adler32 = require_adler32(), crc32 = require_crc32(), inflate_fast = require_inffast(), inflate_table = require_inftrees(), CODES = 0, LENS = 1, DISTS = 2, Z_FINISH = 4, Z_BLOCK = 5, Z_TREES = 6, Z_OK = 0, Z_STREAM_END = 1, Z_NEED_DICT = 2, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_MEM_ERROR = -4, Z_BUF_ERROR = -5, Z_DEFLATED = 8, HEAD = 1, FLAGS = 2, TIME = 3, OS = 4, EXLEN = 5, EXTRA = 6, NAME = 7, COMMENT = 8, HCRC = 9, DICTID = 10, DICT = 11, TYPE = 12, TYPEDO = 13, STORED = 14, COPY_ = 15, COPY = 16, TABLE = 17, LENLENS = 18, CODELENS = 19, LEN_ = 20, LEN = 21, LENEXT = 22, DIST = 23, DISTEXT = 24, MATCH = 25, LIT = 26, CHECK = 27, LENGTH = 28, DONE = 29, BAD = 30, MEM = 31, SYNC = 32, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS;
    function zswap32(q2) {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    }
    function InflateState() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (state = strm.state, strm.total_in = strm.total_out = state.total = 0, strm.msg = "", state.wrap)
        strm.adler = state.wrap & 1;
      return state.mode = HEAD, state.last = 0, state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), state.sane = 1, state.back = -1, Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      return state = strm.state, state.wsize = 0, state.whave = 0, state.wnext = 0, inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap, state;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (state = strm.state, windowBits < 0)
        wrap = 0, windowBits = -windowBits;
      else if (wrap = (windowBits >> 4) + 1, windowBits < 48)
        windowBits &= 15;
      if (windowBits && (windowBits < 8 || windowBits > 15))
        return Z_STREAM_ERROR;
      if (state.window !== null && state.wbits !== windowBits)
        state.window = null;
      return state.wrap = wrap, state.wbits = windowBits, inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret, state;
      if (!strm)
        return Z_STREAM_ERROR;
      if (state = new InflateState, strm.state = state, state.window = null, ret = inflateReset2(strm, windowBits), ret !== Z_OK)
        strm.state = null;
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true, lenfix, distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0;
        while (sym < 144)
          state.lens[sym++] = 8;
        while (sym < 256)
          state.lens[sym++] = 9;
        while (sym < 280)
          state.lens[sym++] = 7;
        while (sym < 288)
          state.lens[sym++] = 8;
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 }), sym = 0;
        while (sym < 32)
          state.lens[sym++] = 5;
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 }), virgin = false;
      }
      state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy2) {
      var dist, state = strm.state;
      if (state.window === null)
        state.wsize = 1 << state.wbits, state.wnext = 0, state.whave = 0, state.window = new utils.Buf8(state.wsize);
      if (copy2 >= state.wsize)
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), state.wnext = 0, state.whave = state.wsize;
      else {
        if (dist = state.wsize - state.wnext, dist > copy2)
          dist = copy2;
        if (utils.arraySet(state.window, src, end - copy2, dist, state.wnext), copy2 -= dist, copy2)
          utils.arraySet(state.window, src, end - copy2, copy2, 0), state.wnext = copy2, state.whave = state.wsize;
        else {
          if (state.wnext += dist, state.wnext === state.wsize)
            state.wnext = 0;
          if (state.whave < state.wsize)
            state.whave += dist;
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state, input, output, next, put, have, left, hold, bits, _in, _out, copy2, from2, from_source, here = 0, here_bits, here_op, here_val, last_bits, last_op, last_val, len2, ret, hbuf = new utils.Buf8(4), opts, n2, order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)
        return Z_STREAM_ERROR;
      if (state = strm.state, state.mode === TYPE)
        state.mode = TYPEDO;
      put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;
      inf_leave:
        for (;; )
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0, hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), hold = 0, bits = 0, state.mode = FLAGS;
                break;
              }
              if (state.flags = 0, state.head)
                state.head.done = false;
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check", state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method", state.mode = BAD;
                break;
              }
              if (hold >>>= 4, bits -= 4, len2 = (hold & 15) + 8, state.wbits === 0)
                state.wbits = len2;
              else if (len2 > state.wbits) {
                strm.msg = "invalid window size", state.mode = BAD;
                break;
              }
              state.dmax = 1 << len2, strm.adler = state.check = 1, state.mode = hold & 512 ? DICTID : TYPE, hold = 0, bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (state.flags = hold, (state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method", state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set", state.mode = BAD;
                break;
              }
              if (state.head)
                state.head.text = hold >> 8 & 1;
              if (state.flags & 512)
                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0, bits = 0, state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (state.head)
                state.head.time = hold;
              if (state.flags & 512)
                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, state.check = crc32(state.check, hbuf, 4, 0);
              hold = 0, bits = 0, state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (state.head)
                state.head.xflags = hold & 255, state.head.os = hold >> 8;
              if (state.flags & 512)
                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0, bits = 0, state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                if (state.length = hold, state.head)
                  state.head.extra_len = hold;
                if (state.flags & 512)
                  hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0, bits = 0;
              } else if (state.head)
                state.head.extra = null;
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                if (copy2 = state.length, copy2 > have)
                  copy2 = have;
                if (copy2) {
                  if (state.head) {
                    if (len2 = state.head.extra_len - state.length, !state.head.extra)
                      state.head.extra = new Array(state.head.extra_len);
                    utils.arraySet(state.head.extra, input, next, copy2, len2);
                  }
                  if (state.flags & 512)
                    state.check = crc32(state.check, input, copy2, next);
                  have -= copy2, next += copy2, state.length -= copy2;
                }
                if (state.length)
                  break inf_leave;
              }
              state.length = 0, state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0)
                  break inf_leave;
                copy2 = 0;
                do
                  if (len2 = input[next + copy2++], state.head && len2 && state.length < 65536)
                    state.head.name += String.fromCharCode(len2);
                while (len2 && copy2 < have);
                if (state.flags & 512)
                  state.check = crc32(state.check, input, copy2, next);
                if (have -= copy2, next += copy2, len2)
                  break inf_leave;
              } else if (state.head)
                state.head.name = null;
              state.length = 0, state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0)
                  break inf_leave;
                copy2 = 0;
                do
                  if (len2 = input[next + copy2++], state.head && len2 && state.length < 65536)
                    state.head.comment += String.fromCharCode(len2);
                while (len2 && copy2 < have);
                if (state.flags & 512)
                  state.check = crc32(state.check, input, copy2, next);
                if (have -= copy2, next += copy2, len2)
                  break inf_leave;
              } else if (state.head)
                state.head.comment = null;
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch", state.mode = BAD;
                  break;
                }
                hold = 0, bits = 0;
              }
              if (state.head)
                state.head.hcrc = state.flags >> 9 & 1, state.head.done = true;
              strm.adler = state.check = 0, state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = DICT;
            case DICT:
              if (state.havedict === 0)
                return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, Z_NEED_DICT;
              strm.adler = state.check = 1, state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES)
                break inf_leave;
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7, bits -= bits & 7, state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              switch (state.last = hold & 1, hold >>>= 1, bits -= 1, hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  if (fixedtables(state), state.mode = LEN_, flush === Z_TREES) {
                    hold >>>= 2, bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type", state.mode = BAD;
              }
              hold >>>= 2, bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7, bits -= bits & 7;
              while (bits < 32) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths", state.mode = BAD;
                break;
              }
              if (state.length = hold & 65535, hold = 0, bits = 0, state.mode = COPY_, flush === Z_TREES)
                break inf_leave;
            case COPY_:
              state.mode = COPY;
            case COPY:
              if (copy2 = state.length, copy2) {
                if (copy2 > have)
                  copy2 = have;
                if (copy2 > left)
                  copy2 = left;
                if (copy2 === 0)
                  break inf_leave;
                utils.arraySet(output, input, next, copy2, put), have -= copy2, next += copy2, left -= copy2, put += copy2, state.length -= copy2;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (state.nlen = (hold & 31) + 257, hold >>>= 5, bits -= 5, state.ndist = (hold & 31) + 1, hold >>>= 5, bits -= 5, state.ncode = (hold & 15) + 4, hold >>>= 4, bits -= 4, state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols", state.mode = BAD;
                break;
              }
              state.have = 0, state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7, hold >>>= 3, bits -= 3;
              }
              while (state.have < 19)
                state.lens[order[state.have++]] = 0;
              if (state.lencode = state.lendyn, state.lenbits = 7, opts = { bits: state.lenbits }, ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {
                strm.msg = "invalid code lengths set", state.mode = BAD;
                break;
              }
              state.have = 0, state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;; ) {
                  if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)
                    break;
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                if (here_val < 16)
                  hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val;
                else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0)
                        break inf_leave;
                      have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (hold >>>= here_bits, bits -= here_bits, state.have === 0) {
                      strm.msg = "invalid bit length repeat", state.mode = BAD;
                      break;
                    }
                    len2 = state.lens[state.have - 1], copy2 = 3 + (hold & 3), hold >>>= 2, bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0)
                        break inf_leave;
                      have--, hold += input[next++] << bits, bits += 8;
                    }
                    hold >>>= here_bits, bits -= here_bits, len2 = 0, copy2 = 3 + (hold & 7), hold >>>= 3, bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0)
                        break inf_leave;
                      have--, hold += input[next++] << bits, bits += 8;
                    }
                    hold >>>= here_bits, bits -= here_bits, len2 = 0, copy2 = 11 + (hold & 127), hold >>>= 7, bits -= 7;
                  }
                  if (state.have + copy2 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat", state.mode = BAD;
                    break;
                  }
                  while (copy2--)
                    state.lens[state.have++] = len2;
                }
              }
              if (state.mode === BAD)
                break;
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block", state.mode = BAD;
                break;
              }
              if (state.lenbits = 9, opts = { bits: state.lenbits }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {
                strm.msg = "invalid literal/lengths set", state.mode = BAD;
                break;
              }
              if (state.distbits = 6, state.distcode = state.distdyn, opts = { bits: state.distbits }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), state.distbits = opts.bits, ret) {
                strm.msg = "invalid distances set", state.mode = BAD;
                break;
              }
              if (state.mode = LEN_, flush === Z_TREES)
                break inf_leave;
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, state.mode === TYPE)
                  state.back = -1;
                break;
              }
              state.back = 0;
              for (;; ) {
                if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)
                  break;
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits, last_op = here_op, last_val = here_val;
                for (;; ) {
                  if (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)
                    break;
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
              }
              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1, state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code", state.mode = BAD;
                break;
              }
              state.extra = here_op & 15, state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;
              }
              state.was = state.length, state.mode = DIST;
            case DIST:
              for (;; ) {
                if (here = state.distcode[hold & (1 << state.distbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)
                  break;
                if (have === 0)
                  break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits, last_op = here_op, last_val = here_val;
                for (;; ) {
                  if (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)
                    break;
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
              }
              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, here_op & 64) {
                strm.msg = "invalid distance code", state.mode = BAD;
                break;
              }
              state.offset = here_val, state.extra = here_op & 15, state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back", state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0)
                break inf_leave;
              if (copy2 = _out - left, state.offset > copy2) {
                if (copy2 = state.offset - copy2, copy2 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back", state.mode = BAD;
                    break;
                  }
                }
                if (copy2 > state.wnext)
                  copy2 -= state.wnext, from2 = state.wsize - copy2;
                else
                  from2 = state.wnext - copy2;
                if (copy2 > state.length)
                  copy2 = state.length;
                from_source = state.window;
              } else
                from_source = output, from2 = put - state.offset, copy2 = state.length;
              if (copy2 > left)
                copy2 = left;
              left -= copy2, state.length -= copy2;
              do
                output[put++] = from_source[from2++];
              while (--copy2);
              if (state.length === 0)
                state.mode = LEN;
              break;
            case LIT:
              if (left === 0)
                break inf_leave;
              output[put++] = state.length, left--, state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold |= input[next++] << bits, bits += 8;
                }
                if (_out -= left, strm.total_out += _out, state.total += _out, _out)
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                if (_out = left, (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check", state.mode = BAD;
                  break;
                }
                hold = 0, bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0)
                    break inf_leave;
                  have--, hold += input[next++] << bits, bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check", state.mode = BAD;
                  break;
                }
                hold = 0, bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
      if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
          return state.mode = MEM, Z_MEM_ERROR;
      }
      if (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, state.total += _out, state.wrap && _out)
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      if (strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0), (_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)
        ret = Z_BUF_ERROR;
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      var state = strm.state;
      if (state.window)
        state.window = null;
      return strm.state = null, Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (state = strm.state, (state.wrap & 2) === 0)
        return Z_STREAM_ERROR;
      return state.head = head, head.done = false, Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length, state, dictid, ret;
      if (!strm || !strm.state)
        return Z_STREAM_ERROR;
      if (state = strm.state, state.wrap !== 0 && state.mode !== DICT)
        return Z_STREAM_ERROR;
      if (state.mode === DICT) {
        if (dictid = 1, dictid = adler32(dictid, dictionary, dictLength, 0), dictid !== state.check)
          return Z_DATA_ERROR;
      }
      if (ret = updatewindow(strm, dictionary, dictLength, dictLength), ret)
        return state.mode = MEM, Z_MEM_ERROR;
      return state.havedict = 1, Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  });
  require_constants = __commonJS3((exports, module2) => {
    module2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  });
  require_binding = __commonJS3((exports) => {
    var assert3 = (init_assert(), __toCommonJS(exports_assert)), Zstream = require_zstream(), zlib_deflate = require_deflate(), zlib_inflate = require_inflate(), constants2 = require_constants();
    for (key in constants2)
      exports[key] = constants2[key];
    var key;
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31, GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      if (this.pending_close = false, assert3(this.init_done, "close before init"), assert3(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW)
        zlib_deflate.deflateEnd(this.strm);
      else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP)
        zlib_inflate.inflateEnd(this.strm);
      this.mode = exports.NONE, this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out2, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out2, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out2, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out2, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out2, out_off, out_len) {
      if (assert3.equal(arguments.length, 8), assert3(this.init_done, "write before init"), assert3(this.mode !== exports.NONE, "already finalized"), assert3.equal(false, this.write_in_progress, "write already in progress"), assert3.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, assert3.equal(false, flush === undefined, "must provide flush value"), this.write_in_progress = true, flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (input == null)
        input = Buffer.alloc(0), in_len = 0, in_off = 0;
      if (this.strm.avail_in = in_len, this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, this.strm.output = out2, this.strm.next_out = out_off, this.flush = flush, !async) {
        if (this._process(), this._checkError())
          return this._afterSync();
        return;
      }
      var self2 = this;
      return process.nextTick(function() {
        self2._process(), self2._after();
      }), this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
      return this.write_in_progress = false, [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0)
            next_expected_header_byte = this.strm.next_in;
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null)
                break;
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                if (this.gzip_id_bytes_read = 1, next_expected_header_byte++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            case 1:
              if (next_expected_header_byte === null)
                break;
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2)
                this.gzip_id_bytes_read = 2, this.mode = exports.GUNZIP;
              else
                this.mode = exports.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          if (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary) {
            if (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), this.err === exports.Z_OK)
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            else if (this.err === exports.Z_DATA_ERROR)
              this.err = exports.Z_NEED_DICT;
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0)
            this.reset(), this.err = zlib_inflate.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH)
            return this._error("unexpected end of file"), false;
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null)
            this._error("Missing dictionary");
          else
            this._error("Bad dictionary");
          return false;
        default:
          return this._error("Zlib error"), false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError())
        return;
      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
      if (this.write_in_progress = false, this.callback(avail_in, avail_out), this.pending_close)
        this.close();
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg)
        message = this.strm.msg;
      if (this.onerror(message, this.err), this.write_in_progress = false, this.pending_close)
        this.close();
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits"), assert3(level >= -1 && level <= 9, "invalid compression level"), assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel"), assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset(), this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      if (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, this.mode === exports.GZIP || this.mode === exports.GUNZIP)
        this.windowBits += 16;
      if (this.mode === exports.UNZIP)
        this.windowBits += 32;
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
        this.windowBits = -1 * this.windowBits;
      switch (this.strm = new Zstream, this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK)
        this._error("Init error");
      this.dictionary = dictionary, this.write_in_progress = false, this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null)
        return;
      switch (this.err = exports.Z_OK, this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK)
        this._error("Failed to set dictionary");
    };
    Zlib.prototype._reset = function() {
      switch (this.err = exports.Z_OK, this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK)
        this._error("Failed to reset stream");
    };
    exports.Zlib = Zlib;
  });
  require_lib = __commonJS3((exports) => {
    var Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer, Transform = require_stream().Transform, binding2 = require_binding(), util = (init_util(), __toCommonJS(exports_util)), assert3 = (init_assert(), __toCommonJS(exports_assert)).ok, kMaxLength2 = (init_buffer(), __toCommonJS(exports_buffer2)).kMaxLength, kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength2.toString(16) + " bytes";
    binding2.Z_MIN_WINDOWBITS = 8;
    binding2.Z_MAX_WINDOWBITS = 15;
    binding2.Z_DEFAULT_WINDOWBITS = 15;
    binding2.Z_MIN_CHUNK = 64;
    binding2.Z_MAX_CHUNK = 1 / 0;
    binding2.Z_DEFAULT_CHUNK = 16384;
    binding2.Z_MIN_MEMLEVEL = 1;
    binding2.Z_MAX_MEMLEVEL = 9;
    binding2.Z_DEFAULT_MEMLEVEL = 8;
    binding2.Z_MIN_LEVEL = -1;
    binding2.Z_MAX_LEVEL = 9;
    binding2.Z_DEFAULT_LEVEL = binding2.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding2);
    for (bk = 0;bk < bkeys.length; bk++)
      if (bkey = bkeys[bk], bkey.match(/^Z/))
        Object.defineProperty(exports, bkey, { enumerable: true, value: binding2[bkey], writable: false });
    var bkey, bk, codes = { Z_OK: binding2.Z_OK, Z_STREAM_END: binding2.Z_STREAM_END, Z_NEED_DICT: binding2.Z_NEED_DICT, Z_ERRNO: binding2.Z_ERRNO, Z_STREAM_ERROR: binding2.Z_STREAM_ERROR, Z_DATA_ERROR: binding2.Z_DATA_ERROR, Z_MEM_ERROR: binding2.Z_MEM_ERROR, Z_BUF_ERROR: binding2.Z_BUF_ERROR, Z_VERSION_ERROR: binding2.Z_VERSION_ERROR }, ckeys = Object.keys(codes);
    for (ck = 0;ck < ckeys.length; ck++)
      ckey = ckeys[ck], codes[codes[ckey]] = ckey;
    var ckey, ck;
    Object.defineProperty(exports, "codes", { enumerable: true, value: Object.freeze(codes), writable: false });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o3) {
      return new Deflate(o3);
    };
    exports.createInflate = function(o3) {
      return new Inflate(o3);
    };
    exports.createDeflateRaw = function(o3) {
      return new DeflateRaw(o3);
    };
    exports.createInflateRaw = function(o3) {
      return new InflateRaw(o3);
    };
    exports.createGzip = function(o3) {
      return new Gzip(o3);
    };
    exports.createGunzip = function(o3) {
      return new Gunzip(o3);
    };
    exports.createUnzip = function(o3) {
      return new Unzip(o3);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [], nread = 0;
      engine.on("error", onError), engine.on("end", onEnd), engine.end(buffer), flow();
      function flow() {
        var chunk;
        while ((chunk = engine.read()) !== null)
          buffers.push(chunk), nread += chunk.length;
        engine.once("readable", flow);
      }
      function onError(err2) {
        engine.removeListener("end", onEnd), engine.removeListener("readable", flow), callback(err2);
      }
      function onEnd() {
        var buf, err2 = null;
        if (nread >= kMaxLength2)
          err2 = new RangeError(kRangeErrorMessage);
        else
          buf = Buffer22.concat(buffers, nread);
        buffers = [], engine.close(), callback(err2, buf);
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string")
        buffer = Buffer22.from(buffer);
      if (!Buffer22.isBuffer(buffer))
        throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate))
        return new Deflate(opts);
      Zlib.call(this, opts, binding2.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate))
        return new Inflate(opts);
      Zlib.call(this, opts, binding2.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip))
        return new Gzip(opts);
      Zlib.call(this, opts, binding2.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip))
        return new Gunzip(opts);
      Zlib.call(this, opts, binding2.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw))
        return new DeflateRaw(opts);
      Zlib.call(this, opts, binding2.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw))
        return new InflateRaw(opts);
      Zlib.call(this, opts, binding2.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip))
        return new Unzip(opts);
      Zlib.call(this, opts, binding2.UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === binding2.Z_NO_FLUSH || flag === binding2.Z_PARTIAL_FLUSH || flag === binding2.Z_SYNC_FLUSH || flag === binding2.Z_FULL_FLUSH || flag === binding2.Z_FINISH || flag === binding2.Z_BLOCK;
    }
    function Zlib(opts, mode) {
      var _this = this;
      if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush))
        throw new Error("Invalid flush flag: " + opts.flush);
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush))
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      if (this._flushFlag = opts.flush || binding2.Z_NO_FLUSH, this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding2.Z_FINISH, opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)
          throw new Error("Invalid chunk size: " + opts.chunkSize);
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)
          throw new Error("Invalid windowBits: " + opts.windowBits);
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)
          throw new Error("Invalid compression level: " + opts.level);
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)
          throw new Error("Invalid memLevel: " + opts.memLevel);
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY)
          throw new Error("Invalid strategy: " + opts.strategy);
      }
      if (opts.dictionary) {
        if (!Buffer22.isBuffer(opts.dictionary))
          throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
      this._handle = new binding2.Zlib(mode);
      var self2 = this;
      this._hadError = false, this._handle.onerror = function(message, errno) {
        _close2(self2), self2._hadError = true;
        var error = new Error(message);
        error.errno = errno, error.code = exports.codes[errno], self2.emit("error", error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number")
        level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number")
        strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), this._buffer = Buffer22.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, this._strategy = strategy, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
        return !_this._handle;
      }, configurable: true, enumerable: true });
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + level);
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + strategy);
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding2.Z_SYNC_FLUSH, function() {
          if (assert3(self2._handle, "zlib binding closed"), self2._handle.params(level, strategy), !self2._hadError) {
            if (self2._level = level, self2._strategy = strategy, callback)
              callback();
          }
        });
      } else
        process.nextTick(callback);
    };
    Zlib.prototype.reset = function() {
      return assert3(this._handle, "zlib binding closed"), this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer22.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this, ws = this._writableState;
      if (typeof kind === "function" || kind === undefined && !callback)
        callback = kind, kind = binding2.Z_FULL_FLUSH;
      if (ws.ended) {
        if (callback)
          process.nextTick(callback);
      } else if (ws.ending) {
        if (callback)
          this.once("end", callback);
      } else if (ws.needDrain) {
        if (callback)
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
      } else
        this._flushFlag = kind, this.write(Buffer22.alloc(0), "", callback);
    };
    Zlib.prototype.close = function(callback) {
      _close2(this, callback), process.nextTick(emitCloseNT, this);
    };
    function _close2(engine, callback) {
      if (callback)
        process.nextTick(callback);
      if (!engine._handle)
        return;
      engine._handle.close(), engine._handle = null;
    }
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag, ws = this._writableState, ending = ws.ending || ws.ended, last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer22.isBuffer(chunk))
        return cb(new Error("invalid input"));
      if (!this._handle)
        return cb(new Error("zlib binding closed"));
      if (last)
        flushFlag = this._finishFlushFlag;
      else if (flushFlag = this._flushFlag, chunk.length >= ws.length)
        this._flushFlag = this._opts.flush || binding2.Z_NO_FLUSH;
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self2 = this, async = typeof cb === "function";
      if (!async) {
        var buffers = [], nread = 0, error;
        this.on("error", function(er) {
          error = er;
        }), assert3(this._handle, "zlib binding closed");
        do
          var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError)
          throw error;
        if (nread >= kMaxLength2)
          throw _close2(this), new RangeError(kRangeErrorMessage);
        var buf = Buffer22.concat(buffers, nread);
        return _close2(this), buf;
      }
      assert3(this._handle, "zlib binding closed");
      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      req.buffer = chunk, req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this)
          this.buffer = null, this.callback = null;
        if (self2._hadError)
          return;
        var have = availOutBefore - availOutAfter;
        if (assert3(have >= 0, "have should not go down"), have > 0) {
          var out2 = self2._buffer.slice(self2._offset, self2._offset + have);
          if (self2._offset += have, async)
            self2.push(out2);
          else
            buffers.push(out2), nread += out2.length;
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize)
          availOutBefore = self2._chunkSize, self2._offset = 0, self2._buffer = Buffer22.allocUnsafe(self2._chunkSize);
        if (availOutAfter === 0) {
          if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async)
            return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback, newReq.buffer = chunk;
          return;
        }
        if (!async)
          return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  });
  exports_zlib2 = {};
  __export2(exports_zlib2, { default: () => import_browserify_zlib.default });
  __reExport(exports_zlib2, __toESM3(require_lib(), 1));
  import_browserify_zlib = __toESM3(require_lib(), 1);
  export_default = import_browserify_zlib.default;
});

// node_modules/@electric-sql/pglite/dist/chunk-WGR4JCLS.js
async function H2(r2, e, t = "pgdata", s3 = "auto") {
  let a2 = Br(r2, e), [n2, o3] = await qr(a2, s3), i4 = t + (o3 ? ".tar.gz" : ".tar"), u3 = o3 ? "application/x-gzip" : "application/x-tar";
  return typeof File < "u" ? new File([n2], i4, { type: u3 }) : new Blob([n2], { type: u3 });
}
async function ce2(r2, e, t) {
  let s3 = new Uint8Array(await e.arrayBuffer()), a2 = typeof File < "u" && e instanceof File ? e.name : undefined;
  (Hr.includes(e.type) || a2?.endsWith(".tgz") || a2?.endsWith(".tar.gz")) && (s3 = await ar(s3));
  let o3;
  try {
    o3 = (0, g4.untar)(s3);
  } catch (i4) {
    if (i4 instanceof Error && i4.message.includes("File is corrupted"))
      s3 = await ar(s3), o3 = (0, g4.untar)(s3);
    else
      throw i4;
  }
  for (let i4 of o3) {
    let u3 = t + i4.name, c2 = u3.split("/").slice(0, -1);
    for (let m2 = 1;m2 <= c2.length; m2++) {
      let y2 = c2.slice(0, m2).join("/");
      r2.analyzePath(y2).exists || r2.mkdir(y2);
    }
    i4.type === g4.REGTYPE ? (r2.writeFile(u3, i4.data), r2.utime(u3, sr(i4.modifyTime), sr(i4.modifyTime))) : i4.type === g4.DIRTYPE && r2.mkdir(u3);
  }
}
function jr(r2, e) {
  let t = [], s3 = (a2) => {
    r2.readdir(a2).forEach((o3) => {
      if (o3 === "." || o3 === "..")
        return;
      let i4 = a2 + "/" + o3, u3 = r2.stat(i4), c2 = r2.isFile(u3.mode) ? r2.readFile(i4, { encoding: "binary" }) : new Uint8Array(0);
      t.push({ name: i4.substring(e.length), mode: u3.mode, size: u3.size, type: r2.isFile(u3.mode) ? g4.REGTYPE : g4.DIRTYPE, modifyTime: u3.mtime, data: c2 }), r2.isDir(u3.mode) && s3(i4);
    });
  };
  return s3(e), t;
}
function Br(r2, e) {
  let t = jr(r2, e);
  return (0, g4.tar)(t);
}
async function qr(r2, e = "auto") {
  if (e === "none")
    return [r2, false];
  if (typeof CompressionStream < "u")
    return [await Yr(r2), true];
  if (typeof process < "u" && process.versions && process.versions.node)
    return [await Wr(r2), true];
  if (e === "auto")
    return [r2, false];
  throw new Error("Compression not supported in this environment");
}
async function Yr(r2) {
  let e = new CompressionStream("gzip"), t = e.writable.getWriter(), s3 = e.readable.getReader();
  t.write(r2), t.close();
  let a2 = [];
  for (;; ) {
    let { value: i4, done: u3 } = await s3.read();
    if (u3)
      break;
    i4 && a2.push(i4);
  }
  let n2 = new Uint8Array(a2.reduce((i4, u3) => i4 + u3.length, 0)), o3 = 0;
  return a2.forEach((i4) => {
    n2.set(i4, o3), o3 += i4.length;
  }), n2;
}
async function Wr(r2) {
  let { promisify: e } = await Promise.resolve().then(() => (init_util(), exports_util)), { gzip: t } = await Promise.resolve().then(() => (init_zlib(), exports_zlib));
  return await e(t)(r2);
}
async function ar(r2) {
  if (typeof CompressionStream < "u")
    return await Xr(r2);
  if (typeof process < "u" && process.versions && process.versions.node)
    return await Kr(r2);
  throw new Error("Unsupported environment for decompression");
}
async function Xr(r2) {
  let e = new DecompressionStream("gzip"), t = e.writable.getWriter(), s3 = e.readable.getReader();
  t.write(r2), t.close();
  let a2 = [];
  for (;; ) {
    let { value: i4, done: u3 } = await s3.read();
    if (u3)
      break;
    i4 && a2.push(i4);
  }
  let n2 = new Uint8Array(a2.reduce((i4, u3) => i4 + u3.length, 0)), o3 = 0;
  return a2.forEach((i4) => {
    n2.set(i4, o3), o3 += i4.length;
  }), n2;
}
async function Kr(r2) {
  let { promisify: e } = await Promise.resolve().then(() => (init_util(), exports_util)), { gunzip: t } = await Promise.resolve().then(() => (init_zlib(), exports_zlib));
  return await e(t)(r2);
}
function sr(r2) {
  return r2 ? typeof r2 == "number" ? r2 : Math.floor(r2.getTime() / 1000) : Math.floor(Date.now() / 1000);
}
var w2, x3, L3, er, nr, or, g4, Hr, Vr = "/tmp/pglite", C2, ur = class {
  constructor(e) {
    this.dataDir = e;
  }
  async init(e, t) {
    return this.pg = e, { emscriptenOpts: t };
  }
  async syncToFs(e) {}
  async initialSyncFs() {}
  async closeFs() {}
  async dumpTar(e, t) {
    return H2(this.pg.Module.FS, C2, e, t);
  }
}, cr = class {
  constructor(e, { debug: t = false } = {}) {
    this.dataDir = e, this.debug = t;
  }
  async syncToFs(e) {}
  async initialSyncFs() {}
  async closeFs() {}
  async dumpTar(e, t) {
    return H2(this.pg.Module.FS, C2, e, t);
  }
  async init(e, t) {
    return this.pg = e, { emscriptenOpts: { ...t, preRun: [...t.preRun || [], (a2) => {
      let n2 = Zr(a2, this);
      a2.FS.mkdir(C2), a2.FS.mount(n2, {}, C2);
    }] } };
  }
}, pr, Zr = (r2, e) => {
  let t = r2.FS, s3 = e.debug ? console.log : null, a2 = { tryFSOperation(n2) {
    try {
      return n2();
    } catch (o3) {
      throw o3.code ? o3.code === "UNKNOWN" ? new t.ErrnoError(pr.EINVAL) : new t.ErrnoError(o3.code) : o3;
    }
  }, mount(n2) {
    return a2.createNode(null, "/", 16895, 0);
  }, syncfs(n2, o3, i4) {}, createNode(n2, o3, i4, u3) {
    if (!t.isDir(i4) && !t.isFile(i4))
      throw new t.ErrnoError(28);
    let c2 = t.createNode(n2, o3, i4);
    return c2.node_ops = a2.node_ops, c2.stream_ops = a2.stream_ops, c2;
  }, getMode: function(n2) {
    return s3?.("getMode", n2), a2.tryFSOperation(() => e.lstat(n2).mode);
  }, realPath: function(n2) {
    let o3 = [];
    for (;n2.parent !== n2; )
      o3.push(n2.name), n2 = n2.parent;
    return o3.push(n2.mount.opts.root), o3.reverse(), o3.join("/");
  }, node_ops: { getattr(n2) {
    s3?.("getattr", a2.realPath(n2));
    let o3 = a2.realPath(n2);
    return a2.tryFSOperation(() => {
      let i4 = e.lstat(o3);
      return { ...i4, dev: 0, ino: n2.id, nlink: 1, rdev: n2.rdev, atime: new Date(i4.atime), mtime: new Date(i4.mtime), ctime: new Date(i4.ctime) };
    });
  }, setattr(n2, o3) {
    s3?.("setattr", a2.realPath(n2), o3);
    let i4 = a2.realPath(n2);
    a2.tryFSOperation(() => {
      o3.mode !== undefined && e.chmod(i4, o3.mode), o3.size !== undefined && e.truncate(i4, o3.size), o3.timestamp !== undefined && e.utimes(i4, o3.timestamp, o3.timestamp), o3.size !== undefined && e.truncate(i4, o3.size);
    });
  }, lookup(n2, o3) {
    s3?.("lookup", a2.realPath(n2), o3);
    let i4 = [a2.realPath(n2), o3].join("/"), u3 = a2.getMode(i4);
    return a2.createNode(n2, o3, u3);
  }, mknod(n2, o3, i4, u3) {
    s3?.("mknod", a2.realPath(n2), o3, i4, u3);
    let c2 = a2.createNode(n2, o3, i4, u3), m2 = a2.realPath(c2);
    return a2.tryFSOperation(() => (t.isDir(c2.mode) ? e.mkdir(m2, { mode: i4 }) : e.writeFile(m2, "", { mode: i4 }), c2));
  }, rename(n2, o3, i4) {
    s3?.("rename", a2.realPath(n2), a2.realPath(o3), i4);
    let u3 = a2.realPath(n2), c2 = [a2.realPath(o3), i4].join("/");
    a2.tryFSOperation(() => {
      e.rename(u3, c2);
    }), n2.name = i4;
  }, unlink(n2, o3) {
    s3?.("unlink", a2.realPath(n2), o3);
    let i4 = [a2.realPath(n2), o3].join("/");
    try {
      e.unlink(i4);
    } catch {}
  }, rmdir(n2, o3) {
    s3?.("rmdir", a2.realPath(n2), o3);
    let i4 = [a2.realPath(n2), o3].join("/");
    return a2.tryFSOperation(() => {
      e.rmdir(i4);
    });
  }, readdir(n2) {
    s3?.("readdir", a2.realPath(n2));
    let o3 = a2.realPath(n2);
    return a2.tryFSOperation(() => e.readdir(o3));
  }, symlink(n2, o3, i4) {
    throw s3?.("symlink", a2.realPath(n2), o3, i4), new t.ErrnoError(63);
  }, readlink(n2) {
    throw s3?.("readlink", a2.realPath(n2)), new t.ErrnoError(63);
  } }, stream_ops: { open(n2) {
    s3?.("open stream", a2.realPath(n2.node));
    let o3 = a2.realPath(n2.node);
    return a2.tryFSOperation(() => {
      t.isFile(n2.node.mode) && (n2.shared.refcount = 1, n2.nfd = e.open(o3));
    });
  }, close(n2) {
    return s3?.("close stream", a2.realPath(n2.node)), a2.tryFSOperation(() => {
      t.isFile(n2.node.mode) && n2.nfd && --n2.shared.refcount === 0 && e.close(n2.nfd);
    });
  }, dup(n2) {
    s3?.("dup stream", a2.realPath(n2.node)), n2.shared.refcount++;
  }, read(n2, o3, i4, u3, c2) {
    return s3?.("read stream", a2.realPath(n2.node), i4, u3, c2), u3 === 0 ? 0 : a2.tryFSOperation(() => e.read(n2.nfd, o3, i4, u3, c2));
  }, write(n2, o3, i4, u3, c2) {
    return s3?.("write stream", a2.realPath(n2.node), i4, u3, c2), a2.tryFSOperation(() => e.write(n2.nfd, o3.buffer, i4, u3, c2));
  }, llseek(n2, o3, i4) {
    s3?.("llseek stream", a2.realPath(n2.node), o3, i4);
    let u3 = o3;
    if (i4 === 1 ? u3 += n2.position : i4 === 2 && t.isFile(n2.node.mode) && a2.tryFSOperation(() => {
      let c2 = e.fstat(n2.nfd);
      u3 += c2.size;
    }), u3 < 0)
      throw new t.ErrnoError(28);
    return u3;
  }, mmap(n2, o3, i4, u3, c2) {
    if (s3?.("mmap stream", a2.realPath(n2.node), o3, i4, u3, c2), !t.isFile(n2.node.mode))
      throw new t.ErrnoError(pr.ENODEV);
    let m2 = r2.mmapAlloc(o3);
    return a2.stream_ops.read(n2, r2.HEAP8, m2, o3, i4), { ptr: m2, allocated: true };
  }, msync(n2, o3, i4, u3, c2) {
    return s3?.("msync stream", a2.realPath(n2.node), i4, u3, c2), a2.stream_ops.write(n2, o3, 0, u3, i4), 0;
  } } };
  return a2;
};
var init_chunk_WGR4JCLS = __esm(() => {
  init_chunk_BTBUZ646();
  w2 = D(($r, l4) => {
    u();
    var j2 = 9007199254740991, B = function(r2) {
      return r2;
    }();
    function mr(r2) {
      return r2 === B;
    }
    function q2(r2) {
      return typeof r2 == "string" || Object.prototype.toString.call(r2) == "[object String]";
    }
    function lr(r2) {
      return Object.prototype.toString.call(r2) == "[object Date]";
    }
    function N2(r2) {
      return r2 !== null && typeof r2 == "object";
    }
    function U3(r2) {
      return typeof r2 == "function";
    }
    function fr(r2) {
      return typeof r2 == "number" && r2 > -1 && r2 % 1 == 0 && r2 <= j2;
    }
    function yr(r2) {
      return Object.prototype.toString.call(r2) == "[object Array]";
    }
    function Y2(r2) {
      return N2(r2) && !U3(r2) && fr(r2.length);
    }
    function D3(r2) {
      return Object.prototype.toString.call(r2) == "[object ArrayBuffer]";
    }
    function gr(r2, e) {
      return Array.prototype.map.call(r2, e);
    }
    function hr(r2, e) {
      var t = B;
      return U3(e) && Array.prototype.every.call(r2, function(s3, a2, n2) {
        var o3 = e(s3, a2, n2);
        return o3 && (t = s3), !o3;
      }), t;
    }
    function Sr(r2) {
      return Object.assign.apply(null, arguments);
    }
    function W2(r2) {
      var e, t, s3;
      if (q2(r2)) {
        for (t = r2.length, s3 = new Uint8Array(t), e = 0;e < t; e++)
          s3[e] = r2.charCodeAt(e) & 255;
        return s3;
      }
      return D3(r2) ? new Uint8Array(r2) : N2(r2) && D3(r2.buffer) ? new Uint8Array(r2.buffer) : Y2(r2) ? new Uint8Array(r2) : N2(r2) && U3(r2.toString) ? W2(r2.toString()) : new Uint8Array;
    }
    l4.exports.MAX_SAFE_INTEGER = j2;
    l4.exports.isUndefined = mr;
    l4.exports.isString = q2;
    l4.exports.isObject = N2;
    l4.exports.isDateTime = lr;
    l4.exports.isFunction = U3;
    l4.exports.isArray = yr;
    l4.exports.isArrayLike = Y2;
    l4.exports.isArrayBuffer = D3;
    l4.exports.map = gr;
    l4.exports.find = hr;
    l4.exports.extend = Sr;
    l4.exports.toUint8Array = W2;
  });
  x3 = D((Qr, X2) => {
    u();
    var M2 = "\x00";
    X2.exports = { NULL_CHAR: M2, TMAGIC: "ustar" + M2 + "00", OLDGNU_MAGIC: "ustar  " + M2, REGTYPE: 0, LNKTYPE: 1, SYMTYPE: 2, CHRTYPE: 3, BLKTYPE: 4, DIRTYPE: 5, FIFOTYPE: 6, CONTTYPE: 7, TSUID: parseInt("4000", 8), TSGID: parseInt("2000", 8), TSVTX: parseInt("1000", 8), TUREAD: parseInt("0400", 8), TUWRITE: parseInt("0200", 8), TUEXEC: parseInt("0100", 8), TGREAD: parseInt("0040", 8), TGWRITE: parseInt("0020", 8), TGEXEC: parseInt("0010", 8), TOREAD: parseInt("0004", 8), TOWRITE: parseInt("0002", 8), TOEXEC: parseInt("0001", 8), TPERMALL: parseInt("0777", 8), TPERMMASK: parseInt("0777", 8) };
  });
  L3 = D((ee2, f2) => {
    u();
    var K2 = w2(), p2 = x3(), Fr = 512, I = p2.TPERMALL, V = 0, Z2 = 0, _3 = [["name", 100, 0, function(r2, e) {
      return v2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return A2(r2.slice(e, e + t[1]));
    }], ["mode", 8, 100, function(r2, e) {
      var t = r2[e[0]] || I;
      return t = t & p2.TPERMMASK, P3(t, e[1], I);
    }, function(r2, e, t) {
      var s3 = S2(r2.slice(e, e + t[1]));
      return s3 &= p2.TPERMMASK, s3;
    }], ["uid", 8, 108, function(r2, e) {
      return P3(r2[e[0]], e[1], V);
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["gid", 8, 116, function(r2, e) {
      return P3(r2[e[0]], e[1], Z2);
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["size", 12, 124, function(r2, e) {
      return P3(r2.data.length, e[1]);
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["modifyTime", 12, 136, function(r2, e) {
      return k2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return z3(r2.slice(e, e + t[1]));
    }], ["checksum", 8, 148, function(r2, e) {
      return "        ";
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["type", 1, 156, function(r2, e) {
      return "" + (parseInt(r2[e[0]], 10) || 0) % 8;
    }, function(r2, e, t) {
      return (parseInt(String.fromCharCode(r2[e]), 10) || 0) % 8;
    }], ["linkName", 100, 157, function(r2, e) {
      return "";
    }, function(r2, e, t) {
      return A2(r2.slice(e, e + t[1]));
    }], ["ustar", 8, 257, function(r2, e) {
      return p2.TMAGIC;
    }, function(r2, e, t) {
      return br(A2(r2.slice(e, e + t[1]), true));
    }, function(r2, e) {
      return r2[e[0]] == p2.TMAGIC || r2[e[0]] == p2.OLDGNU_MAGIC;
    }], ["owner", 32, 265, function(r2, e) {
      return v2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return A2(r2.slice(e, e + t[1]));
    }], ["group", 32, 297, function(r2, e) {
      return v2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return A2(r2.slice(e, e + t[1]));
    }], ["majorNumber", 8, 329, function(r2, e) {
      return "";
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["minorNumber", 8, 337, function(r2, e) {
      return "";
    }, function(r2, e, t) {
      return S2(r2.slice(e, e + t[1]));
    }], ["prefix", 131, 345, function(r2, e) {
      return v2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return A2(r2.slice(e, e + t[1]));
    }], ["accessTime", 12, 476, function(r2, e) {
      return k2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return z3(r2.slice(e, e + t[1]));
    }], ["createTime", 12, 488, function(r2, e) {
      return k2(r2[e[0]], e[1]);
    }, function(r2, e, t) {
      return z3(r2.slice(e, e + t[1]));
    }]], $2 = function(r2) {
      var e = r2[r2.length - 1];
      return e[2] + e[1];
    }(_3);
    function br(r2) {
      if (r2.length == 8) {
        var e = r2.split("");
        if (e[5] == p2.NULL_CHAR)
          return (e[6] == " " || e[6] == p2.NULL_CHAR) && (e[6] = "0"), (e[7] == " " || e[7] == p2.NULL_CHAR) && (e[7] = "0"), e = e.join(""), e == p2.TMAGIC ? e : r2;
        if (e[7] == p2.NULL_CHAR)
          return e[5] == p2.NULL_CHAR && (e[5] = " "), e[6] == p2.NULL_CHAR && (e[6] = " "), e == p2.OLDGNU_MAGIC ? e : r2;
      }
      return r2;
    }
    function v2(r2, e) {
      return e -= 1, K2.isUndefined(r2) && (r2 = ""), r2 = ("" + r2).substr(0, e), r2 + p2.NULL_CHAR;
    }
    function P3(r2, e, t) {
      for (t = parseInt(t) || 0, e -= 1, r2 = (parseInt(r2) || t).toString(8).substr(-e, e);r2.length < e; )
        r2 = "0" + r2;
      return r2 + p2.NULL_CHAR;
    }
    function k2(r2, e) {
      if (K2.isDateTime(r2))
        r2 = Math.floor(1 * r2 / 1000);
      else if (r2 = parseInt(r2, 10), isFinite(r2)) {
        if (r2 <= 0)
          return "";
      } else
        r2 = Math.floor(1 * new Date / 1000);
      return P3(r2, e, 0);
    }
    function A2(r2, e) {
      var t = String.fromCharCode.apply(null, r2);
      if (e)
        return t;
      var s3 = t.indexOf(p2.NULL_CHAR);
      return s3 >= 0 ? t.substr(0, s3) : t;
    }
    function S2(r2) {
      var e = String.fromCharCode.apply(null, r2);
      return parseInt(e.replace(/^0+$/g, ""), 8) || 0;
    }
    function z3(r2) {
      return r2.length == 0 || r2[0] == 0 ? null : new Date(1000 * S2(r2));
    }
    function Tr2(r2, e, t) {
      var s3 = parseInt(e, 10) || 0, a2 = Math.min(s3 + $2, r2.length), n2 = 0, o3 = 0, i4 = 0;
      t && _3.every(function(y2) {
        return y2[0] == "checksum" ? (o3 = s3 + y2[2], i4 = o3 + y2[1], false) : true;
      });
      for (var u3 = 32, c2 = s3;c2 < a2; c2++) {
        var m2 = c2 >= o3 && c2 < i4 ? u3 : r2[c2];
        n2 = (n2 + m2) % 262144;
      }
      return n2;
    }
    f2.exports.recordSize = Fr;
    f2.exports.defaultFileMode = I;
    f2.exports.defaultUid = V;
    f2.exports.defaultGid = Z2;
    f2.exports.posixHeader = _3;
    f2.exports.effectiveHeaderSize = $2;
    f2.exports.calculateChecksum = Tr2;
    f2.exports.formatTarString = v2;
    f2.exports.formatTarNumber = P3;
    f2.exports.formatTarDateTime = k2;
    f2.exports.parseTarString = A2;
    f2.exports.parseTarNumber = S2;
    f2.exports.parseTarDateTime = z3;
  });
  er = D((ne2, rr) => {
    u();
    var Ar = x3(), O2 = w2(), F3 = L3();
    function J2(r2) {
      return F3.recordSize;
    }
    function Q2(r2) {
      return Math.ceil(r2.data.length / F3.recordSize) * F3.recordSize;
    }
    function Er2(r2) {
      var e = 0;
      return r2.forEach(function(t) {
        e += J2(t) + Q2(t);
      }), e += F3.recordSize * 2, new Uint8Array(e);
    }
    function Pr(r2, e, t) {
      t = parseInt(t) || 0;
      var s3 = t;
      F3.posixHeader.forEach(function(u3) {
        for (var c2 = u3[3](e, u3), m2 = c2.length, y2 = 0;y2 < m2; y2 += 1)
          r2[s3 + y2] = c2.charCodeAt(y2) & 255;
        s3 += u3[1];
      });
      var a2 = O2.find(F3.posixHeader, function(u3) {
        return u3[0] == "checksum";
      });
      if (a2) {
        var n2 = F3.calculateChecksum(r2, t, true), o3 = F3.formatTarNumber(n2, a2[1] - 2) + Ar.NULL_CHAR + " ";
        s3 = t + a2[2];
        for (var i4 = 0;i4 < o3.length; i4 += 1)
          r2[s3] = o3.charCodeAt(i4) & 255, s3++;
      }
      return t + J2(e);
    }
    function wr(r2, e, t) {
      return t = parseInt(t, 10) || 0, r2.set(e.data, t), t + Q2(e);
    }
    function xr(r2) {
      r2 = O2.map(r2, function(s3) {
        return O2.extend({}, s3, { data: O2.toUint8Array(s3.data) });
      });
      var e = Er2(r2), t = 0;
      return r2.forEach(function(s3) {
        t = Pr(e, s3, t), t = wr(e, s3, t);
      }), e;
    }
    rr.exports.tar = xr;
  });
  nr = D((oe, tr) => {
    u();
    var vr = x3(), G2 = w2(), h3 = L3(), Nr2 = { extractData: true, checkHeader: true, checkChecksum: true, checkFileSize: true }, Ur = { size: true, checksum: true, ustar: true }, R4 = { unexpectedEndOfFile: "Unexpected end of file.", fileCorrupted: "File is corrupted.", checksumCheckFailed: "Checksum check failed." };
    function kr(r2) {
      return h3.recordSize;
    }
    function zr(r2) {
      return Math.ceil(r2 / h3.recordSize) * h3.recordSize;
    }
    function Or(r2, e) {
      for (var t = e, s3 = Math.min(r2.length, e + h3.recordSize * 2), a2 = t;a2 < s3; a2++)
        if (r2[a2] != 0)
          return false;
      return true;
    }
    function Cr2(r2, e, t) {
      if (r2.length - e < h3.recordSize) {
        if (t.checkFileSize)
          throw new Error(R4.unexpectedEndOfFile);
        return null;
      }
      e = parseInt(e) || 0;
      var s3 = {}, a2 = e;
      if (h3.posixHeader.forEach(function(i4) {
        s3[i4[0]] = i4[4](r2, a2, i4), a2 += i4[1];
      }), s3.type != 0 && (s3.size = 0), t.checkHeader && h3.posixHeader.forEach(function(i4) {
        if (G2.isFunction(i4[5]) && !i4[5](s3, i4)) {
          var u3 = new Error(R4.fileCorrupted);
          throw u3.data = { offset: e + i4[2], field: i4[0] }, u3;
        }
      }), t.checkChecksum) {
        var n2 = h3.calculateChecksum(r2, e, true);
        if (n2 != s3.checksum) {
          var o3 = new Error(R4.checksumCheckFailed);
          throw o3.data = { offset: e, header: s3, checksum: n2 }, o3;
        }
      }
      return s3;
    }
    function Dr(r2, e, t, s3) {
      return s3.extractData ? t.size <= 0 ? new Uint8Array : r2.slice(e, e + t.size) : null;
    }
    function Mr(r2, e) {
      var t = {};
      return h3.posixHeader.forEach(function(s3) {
        var a2 = s3[0];
        Ur[a2] || (t[a2] = r2[a2]);
      }), t.isOldGNUFormat = r2.ustar == vr.OLDGNU_MAGIC, e && (t.data = e), t;
    }
    function Ir(r2, e) {
      e = G2.extend({}, Nr2, e);
      for (var t = [], s3 = 0, a2 = r2.length;a2 - s3 >= h3.recordSize; ) {
        r2 = G2.toUint8Array(r2);
        var n2 = Cr2(r2, s3, e);
        if (!n2)
          break;
        s3 += kr(n2);
        var o3 = Dr(r2, s3, n2, e);
        if (t.push(Mr(n2, o3)), s3 += zr(n2.size), Or(r2, s3))
          break;
      }
      return t;
    }
    tr.exports.untar = Ir;
  });
  or = D((se2, ir) => {
    u();
    var _r = w2(), Lr = x3(), Rr2 = er(), Gr = nr();
    _r.extend(ir.exports, Rr2, Gr, Lr);
  });
  u();
  u();
  g4 = L(or(), 1);
  Hr = ["application/x-gtar", "application/x-tar+gzip", "application/x-gzip", "application/gzip"];
  C2 = Vr + "/base";
  pr = { EBADF: 8, EBADFD: 127, EEXIST: 20, EINVAL: 28, EISDIR: 31, ENODEV: 43, ENOENT: 44, ENOTDIR: 54, ENOTEMPTY: 55 };
});

// node:path
function assertPath(path) {
  if (typeof path !== "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
function normalizeStringPosix(path, allowAboveRoot) {
  var res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code2;
  for (var i4 = 0;i4 <= path.length; ++i4) {
    if (i4 < path.length)
      code2 = path.charCodeAt(i4);
    else if (code2 === 47)
      break;
    else
      code2 = 47;
    if (code2 === 47) {
      if (lastSlash === i4 - 1 || dots === 1)
        ;
      else if (lastSlash !== i4 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1)
                res = "", lastSegmentLength = 0;
              else
                res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              lastSlash = i4, dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "", lastSegmentLength = 0, lastSlash = i4, dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += "/..";
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path.slice(lastSlash + 1, i4);
        else
          res = path.slice(lastSlash + 1, i4);
        lastSegmentLength = i4 - lastSlash - 1;
      }
      lastSlash = i4, dots = 0;
    } else if (code2 === 46 && dots !== -1)
      ++dots;
    else
      dots = -1;
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root, base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep + base;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false, cwd2;
  for (var i4 = arguments.length - 1;i4 >= -1 && !resolvedAbsolute; i4--) {
    var path;
    if (i4 >= 0)
      path = arguments[i4];
    else {
      if (cwd2 === undefined)
        cwd2 = process.cwd();
      path = cwd2;
    }
    if (assertPath(path), path.length === 0)
      continue;
    resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  if (resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute), resolvedAbsolute)
    if (resolvedPath.length > 0)
      return "/" + resolvedPath;
    else
      return "/";
  else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var isAbsolute = path.charCodeAt(0) === 47, trailingSeparator = path.charCodeAt(path.length - 1) === 47;
  if (path = normalizeStringPosix(path, !isAbsolute), path.length === 0 && !isAbsolute)
    path = ".";
  if (path.length > 0 && trailingSeparator)
    path += "/";
  if (isAbsolute)
    return "/" + path;
  return path;
}
function isAbsolute(path) {
  return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
}
function join() {
  if (arguments.length === 0)
    return ".";
  var joined;
  for (var i4 = 0;i4 < arguments.length; ++i4) {
    var arg = arguments[i4];
    if (assertPath(arg), arg.length > 0)
      if (joined === undefined)
        joined = arg;
      else
        joined += "/" + arg;
  }
  if (joined === undefined)
    return ".";
  return normalize(joined);
}
function relative(from2, to) {
  if (assertPath(from2), assertPath(to), from2 === to)
    return "";
  if (from2 = resolve(from2), to = resolve(to), from2 === to)
    return "";
  var fromStart = 1;
  for (;fromStart < from2.length; ++fromStart)
    if (from2.charCodeAt(fromStart) !== 47)
      break;
  var fromEnd = from2.length, fromLen = fromEnd - fromStart, toStart = 1;
  for (;toStart < to.length; ++toStart)
    if (to.charCodeAt(toStart) !== 47)
      break;
  var toEnd = to.length, toLen = toEnd - toStart, length = fromLen < toLen ? fromLen : toLen, lastCommonSep = -1, i4 = 0;
  for (;i4 <= length; ++i4) {
    if (i4 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i4) === 47)
          return to.slice(toStart + i4 + 1);
        else if (i4 === 0)
          return to.slice(toStart + i4);
      } else if (fromLen > length) {
        if (from2.charCodeAt(fromStart + i4) === 47)
          lastCommonSep = i4;
        else if (i4 === 0)
          lastCommonSep = 0;
      }
      break;
    }
    var fromCode = from2.charCodeAt(fromStart + i4), toCode = to.charCodeAt(toStart + i4);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i4;
  }
  var out2 = "";
  for (i4 = fromStart + lastCommonSep + 1;i4 <= fromEnd; ++i4)
    if (i4 === fromEnd || from2.charCodeAt(i4) === 47)
      if (out2.length === 0)
        out2 += "..";
      else
        out2 += "/..";
  if (out2.length > 0)
    return out2 + to.slice(toStart + lastCommonSep);
  else {
    if (toStart += lastCommonSep, to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function _makeLong(path) {
  return path;
}
function dirname(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var code2 = path.charCodeAt(0), hasRoot = code2 === 47, end = -1, matchedSlash = true;
  for (var i4 = path.length - 1;i4 >= 1; --i4)
    if (code2 = path.charCodeAt(i4), code2 === 47) {
      if (!matchedSlash) {
        end = i4;
        break;
      }
    } else
      matchedSlash = false;
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path.slice(0, end);
}
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath(path);
  var start2 = 0, end = -1, matchedSlash = true, i4;
  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
    if (ext.length === path.length && ext === path)
      return "";
    var extIdx = ext.length - 1, firstNonSlashEnd = -1;
    for (i4 = path.length - 1;i4 >= 0; --i4) {
      var code2 = path.charCodeAt(i4);
      if (code2 === 47) {
        if (!matchedSlash) {
          start2 = i4 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1)
          matchedSlash = false, firstNonSlashEnd = i4 + 1;
        if (extIdx >= 0)
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1)
              end = i4;
          } else
            extIdx = -1, end = firstNonSlashEnd;
      }
    }
    if (start2 === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path.length;
    return path.slice(start2, end);
  } else {
    for (i4 = path.length - 1;i4 >= 0; --i4)
      if (path.charCodeAt(i4) === 47) {
        if (!matchedSlash) {
          start2 = i4 + 1;
          break;
        }
      } else if (end === -1)
        matchedSlash = false, end = i4 + 1;
    if (end === -1)
      return "";
    return path.slice(start2, end);
  }
}
function extname(path) {
  assertPath(path);
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
  for (var i4 = path.length - 1;i4 >= 0; --i4) {
    var code2 = path.charCodeAt(i4);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i4 + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i4 + 1;
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i4;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
    return "";
  return path.slice(startDot, end);
}
function format2(pathObject) {
  if (pathObject === null || typeof pathObject !== "object")
    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
  return _format("/", pathObject);
}
function parse(path) {
  assertPath(path);
  var ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path.length === 0)
    return ret;
  var code2 = path.charCodeAt(0), isAbsolute2 = code2 === 47, start2;
  if (isAbsolute2)
    ret.root = "/", start2 = 1;
  else
    start2 = 0;
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, i4 = path.length - 1, preDotState = 0;
  for (;i4 >= start2; --i4) {
    if (code2 = path.charCodeAt(i4), code2 === 47) {
      if (!matchedSlash) {
        startPart = i4 + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i4 + 1;
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i4;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1)
      if (startPart === 0 && isAbsolute2)
        ret.base = ret.name = path.slice(1, end);
      else
        ret.base = ret.name = path.slice(startPart, end);
  } else {
    if (startPart === 0 && isAbsolute2)
      ret.name = path.slice(1, startDot), ret.base = path.slice(1, end);
    else
      ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end);
    ret.ext = path.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path.slice(0, startPart - 1);
  else if (isAbsolute2)
    ret.dir = "/";
  return ret;
}
var sep = "/", delimiter = ":", posix;
var init_path = __esm(() => {
  posix = ((p2) => (p2.posix = p2, p2))({ resolve, normalize, isAbsolute, join, relative, _makeLong, dirname, basename, extname, format: format2, parse, sep, delimiter, win32: null, posix: null });
});

// node_modules/@electric-sql/pglite/dist/fs/nodefs.js
var exports_nodefs = {};
__export(exports_nodefs, {
  NodeFS: () => m2
});
var s3 = (() => ({}));
var m2;
var init_nodefs = __esm(() => {
  init_chunk_WGR4JCLS();
  init_chunk_BTBUZ646();
  init_path();
  u();
  m2 = class extends ur {
    constructor(t) {
      super(t), this.rootDir = resolve(t), s3.existsSync(join(this.rootDir)) || s3.mkdirSync(this.rootDir);
    }
    async init(t, e) {
      return this.pg = t, { emscriptenOpts: { ...e, preRun: [...e.preRun || [], (r2) => {
        let c2 = r2.FS.filesystems.NODEFS;
        r2.FS.mkdir(C2), r2.FS.mount(c2, { root: this.rootDir }, C2);
      }] } };
    }
    async closeFs() {
      this.pg.Module.FS.quit();
    }
  };
});

// node_modules/@electric-sql/pglite/dist/fs/opfs-ahp.js
var exports_opfs_ahp = {};
__export(exports_opfs_ahp, {
  OpfsAhpFS: () => L4
});
var $2 = "state.txt", G2 = "data", T2, H3, v2, F3, M2, y2, b3, m3, x4, P3, D3, S2, n2, C3, O2, k2, w3, f2, I, W2, j2, L4, p2;
var init_opfs_ahp = __esm(() => {
  init_chunk_WGR4JCLS();
  init_chunk_BTBUZ646();
  u();
  T2 = { DIR: 16384, FILE: 32768 };
  L4 = class extends cr {
    constructor(e, { initialPoolSize: t = 1000, maintainedPoolSize: o3 = 100, debug: i4 = false } = {}) {
      super(e, { debug: i4 });
      R(this, n2);
      R(this, H3);
      R(this, v2);
      R(this, F3);
      R(this, M2);
      R(this, y2);
      R(this, b3, new Map);
      R(this, m3, new Map);
      R(this, x4, 0);
      R(this, P3, new Map);
      R(this, D3, new Map);
      this.lastCheckpoint = 0;
      this.checkpointInterval = 1000 * 60;
      this.poolCounter = 0;
      R(this, S2, new Set);
      this.initialPoolSize = t, this.maintainedPoolSize = o3;
    }
    async init(e, t) {
      return await T(this, n2, C3).call(this), super.init(e, t);
    }
    async syncToFs(e = false) {
      await this.maybeCheckpointState(), await this.maintainPool(), e || this.flush();
    }
    async closeFs() {
      for (let e of h(this, m3).values())
        e.close();
      h(this, y2).flush(), h(this, y2).close(), this.pg.Module.FS.quit();
    }
    async maintainPool(e) {
      e = e || this.maintainedPoolSize;
      let t = e - this.state.pool.length, o3 = [];
      for (let i4 = 0;i4 < t; i4++)
        o3.push(new Promise(async (c2) => {
          ++this.poolCounter;
          let a2 = `${(Date.now() - 1704063600).toString(16).padStart(8, "0")}-${this.poolCounter.toString(16).padStart(8, "0")}`, h3 = await h(this, F3).getFileHandle(a2, { create: true }), d3 = await h3.createSyncAccessHandle();
          h(this, b3).set(a2, h3), h(this, m3).set(a2, d3), T(this, n2, k2).call(this, { opp: "createPoolFile", args: [a2] }), this.state.pool.push(a2), c2();
        }));
      for (let i4 = 0;i4 > t; i4--)
        o3.push(new Promise(async (c2) => {
          let a2 = this.state.pool.pop();
          T(this, n2, k2).call(this, { opp: "deletePoolFile", args: [a2] });
          let h3 = h(this, b3).get(a2);
          h(this, m3).get(a2)?.close(), await h(this, F3).removeEntry(h3.name), h(this, b3).delete(a2), h(this, m3).delete(a2), c2();
        }));
      await Promise.all(o3);
    }
    _createPoolFileState(e) {
      this.state.pool.push(e);
    }
    _deletePoolFileState(e) {
      let t = this.state.pool.indexOf(e);
      t > -1 && this.state.pool.splice(t, 1);
    }
    async maybeCheckpointState() {
      Date.now() - this.lastCheckpoint > this.checkpointInterval && await this.checkpointState();
    }
    async checkpointState() {
      let e = new TextEncoder().encode(JSON.stringify(this.state));
      h(this, y2).truncate(0), h(this, y2).write(e, { at: 0 }), h(this, y2).flush(), this.lastCheckpoint = Date.now();
    }
    flush() {
      for (let e of h(this, S2))
        try {
          e.flush();
        } catch {}
      h(this, S2).clear();
    }
    chmod(e, t) {
      T(this, n2, O2).call(this, { opp: "chmod", args: [e, t] }, () => {
        this._chmodState(e, t);
      });
    }
    _chmodState(e, t) {
      let o3 = T(this, n2, f2).call(this, e);
      o3.mode = t;
    }
    close(e) {
      let t = T(this, n2, I).call(this, e);
      h(this, P3).delete(e), h(this, D3).delete(t);
    }
    fstat(e) {
      let t = T(this, n2, I).call(this, e);
      return this.lstat(t);
    }
    lstat(e) {
      let t = T(this, n2, f2).call(this, e), o3 = t.type === "file" ? h(this, m3).get(t.backingFilename).getSize() : 0, i4 = 4096;
      return { dev: 0, ino: 0, mode: t.mode, nlink: 1, uid: 0, gid: 0, rdev: 0, size: o3, blksize: i4, blocks: Math.ceil(o3 / i4), atime: t.lastModified, mtime: t.lastModified, ctime: t.lastModified };
    }
    mkdir(e, t) {
      T(this, n2, O2).call(this, { opp: "mkdir", args: [e, t] }, () => {
        this._mkdirState(e, t);
      });
    }
    _mkdirState(e, t) {
      let o3 = T(this, n2, w3).call(this, e), i4 = o3.pop(), c2 = [], a2 = this.state.root;
      for (let d3 of o3) {
        if (c2.push(e), !Object.prototype.hasOwnProperty.call(a2.children, d3))
          if (t?.recursive)
            this.mkdir(c2.join("/"));
          else
            throw new p2("ENOENT", "No such file or directory");
        if (a2.children[d3].type !== "directory")
          throw new p2("ENOTDIR", "Not a directory");
        a2 = a2.children[d3];
      }
      if (Object.prototype.hasOwnProperty.call(a2.children, i4))
        throw new p2("EEXIST", "File exists");
      let h3 = { type: "directory", lastModified: Date.now(), mode: t?.mode || T2.DIR, children: {} };
      a2.children[i4] = h3;
    }
    open(e, t, o3) {
      if (T(this, n2, f2).call(this, e).type !== "file")
        throw new p2("EISDIR", "Is a directory");
      let c2 = T(this, n2, W2).call(this);
      return h(this, P3).set(c2, e), h(this, D3).set(e, c2), c2;
    }
    readdir(e) {
      let t = T(this, n2, f2).call(this, e);
      if (t.type !== "directory")
        throw new p2("ENOTDIR", "Not a directory");
      return Object.keys(t.children);
    }
    read(e, t, o3, i4, c2) {
      let a2 = T(this, n2, I).call(this, e), h3 = T(this, n2, f2).call(this, a2);
      if (h3.type !== "file")
        throw new p2("EISDIR", "Is a directory");
      return h(this, m3).get(h3.backingFilename).read(new Uint8Array(t.buffer, o3, i4), { at: c2 });
    }
    rename(e, t) {
      T(this, n2, O2).call(this, { opp: "rename", args: [e, t] }, () => {
        this._renameState(e, t, true);
      });
    }
    _renameState(e, t, o3 = false) {
      let i4 = T(this, n2, w3).call(this, e), c2 = i4.pop(), a2 = T(this, n2, f2).call(this, i4.join("/"));
      if (!Object.prototype.hasOwnProperty.call(a2.children, c2))
        throw new p2("ENOENT", "No such file or directory");
      let h3 = T(this, n2, w3).call(this, t), d3 = h3.pop(), l4 = T(this, n2, f2).call(this, h3.join("/"));
      if (o3 && Object.prototype.hasOwnProperty.call(l4.children, d3)) {
        let u3 = l4.children[d3];
        h(this, m3).get(u3.backingFilename).truncate(0), this.state.pool.push(u3.backingFilename);
      }
      l4.children[d3] = a2.children[c2], delete a2.children[c2];
    }
    rmdir(e) {
      T(this, n2, O2).call(this, { opp: "rmdir", args: [e] }, () => {
        this._rmdirState(e);
      });
    }
    _rmdirState(e) {
      let t = T(this, n2, w3).call(this, e), o3 = t.pop(), i4 = T(this, n2, f2).call(this, t.join("/"));
      if (!Object.prototype.hasOwnProperty.call(i4.children, o3))
        throw new p2("ENOENT", "No such file or directory");
      let c2 = i4.children[o3];
      if (c2.type !== "directory")
        throw new p2("ENOTDIR", "Not a directory");
      if (Object.keys(c2.children).length > 0)
        throw new p2("ENOTEMPTY", "Directory not empty");
      delete i4.children[o3];
    }
    truncate(e, t = 0) {
      let o3 = T(this, n2, f2).call(this, e);
      if (o3.type !== "file")
        throw new p2("EISDIR", "Is a directory");
      let i4 = h(this, m3).get(o3.backingFilename);
      if (!i4)
        throw new p2("ENOENT", "No such file or directory");
      i4.truncate(t), h(this, S2).add(i4);
    }
    unlink(e) {
      T(this, n2, O2).call(this, { opp: "unlink", args: [e] }, () => {
        this._unlinkState(e, true);
      });
    }
    _unlinkState(e, t = false) {
      let o3 = T(this, n2, w3).call(this, e), i4 = o3.pop(), c2 = T(this, n2, f2).call(this, o3.join("/"));
      if (!Object.prototype.hasOwnProperty.call(c2.children, i4))
        throw new p2("ENOENT", "No such file or directory");
      let a2 = c2.children[i4];
      if (a2.type !== "file")
        throw new p2("EISDIR", "Is a directory");
      if (delete c2.children[i4], t) {
        let h3 = h(this, m3).get(a2.backingFilename);
        h3?.truncate(0), h(this, S2).add(h3), h(this, D3).has(e) && (h(this, P3).delete(h(this, D3).get(e)), h(this, D3).delete(e));
      }
      this.state.pool.push(a2.backingFilename);
    }
    utimes(e, t, o3) {
      T(this, n2, O2).call(this, { opp: "utimes", args: [e, t, o3] }, () => {
        this._utimesState(e, t, o3);
      });
    }
    _utimesState(e, t, o3) {
      let i4 = T(this, n2, f2).call(this, e);
      i4.lastModified = o3;
    }
    writeFile(e, t, o3) {
      let i4 = T(this, n2, w3).call(this, e), c2 = i4.pop(), a2 = T(this, n2, f2).call(this, i4.join("/"));
      if (Object.prototype.hasOwnProperty.call(a2.children, c2)) {
        let l4 = a2.children[c2];
        l4.lastModified = Date.now(), T(this, n2, k2).call(this, { opp: "setLastModified", args: [e, l4.lastModified] });
      } else {
        if (this.state.pool.length === 0)
          throw new Error("No more file handles available in the pool");
        let l4 = { type: "file", lastModified: Date.now(), mode: o3?.mode || T2.FILE, backingFilename: this.state.pool.pop() };
        a2.children[c2] = l4, T(this, n2, k2).call(this, { opp: "createFileNode", args: [e, l4] });
      }
      let h3 = a2.children[c2], d3 = h(this, m3).get(h3.backingFilename);
      t.length > 0 && (d3.write(typeof t == "string" ? new TextEncoder().encode(t) : new Uint8Array(t), { at: 0 }), e.startsWith("/pg_wal") && h(this, S2).add(d3));
    }
    _createFileNodeState(e, t) {
      let o3 = T(this, n2, w3).call(this, e), i4 = o3.pop(), c2 = T(this, n2, f2).call(this, o3.join("/"));
      c2.children[i4] = t;
      let a2 = this.state.pool.indexOf(t.backingFilename);
      return a2 > -1 && this.state.pool.splice(a2, 1), t;
    }
    _setLastModifiedState(e, t) {
      let o3 = T(this, n2, f2).call(this, e);
      o3.lastModified = t;
    }
    write(e, t, o3, i4, c2) {
      let a2 = T(this, n2, I).call(this, e), h3 = T(this, n2, f2).call(this, a2);
      if (h3.type !== "file")
        throw new p2("EISDIR", "Is a directory");
      let d3 = h(this, m3).get(h3.backingFilename);
      if (!d3)
        throw new p2("EBADF", "Bad file descriptor");
      let l4 = d3.write(new Uint8Array(t, o3, i4), { at: c2 });
      return a2.startsWith("/pg_wal") && h(this, S2).add(d3), l4;
    }
  };
  H3 = new WeakMap, v2 = new WeakMap, F3 = new WeakMap, M2 = new WeakMap, y2 = new WeakMap, b3 = new WeakMap, m3 = new WeakMap, x4 = new WeakMap, P3 = new WeakMap, D3 = new WeakMap, S2 = new WeakMap, n2 = new WeakSet, C3 = async function() {
    x(this, H3, await navigator.storage.getDirectory()), x(this, v2, await T(this, n2, j2).call(this, this.dataDir, { create: true })), x(this, F3, await T(this, n2, j2).call(this, G2, { from: h(this, v2), create: true })), x(this, M2, await h(this, v2).getFileHandle($2, { create: true })), x(this, y2, await h(this, M2).createSyncAccessHandle());
    let e = new ArrayBuffer(h(this, y2).getSize());
    h(this, y2).read(e, { at: 0 });
    let t, o3 = new TextDecoder().decode(e).split(`
`), i4 = false;
    try {
      t = JSON.parse(o3[0]);
    } catch {
      t = { root: { type: "directory", lastModified: Date.now(), mode: T2.DIR, children: {} }, pool: [] }, h(this, y2).truncate(0), h(this, y2).write(new TextEncoder().encode(JSON.stringify(t)), { at: 0 }), i4 = true;
    }
    this.state = t;
    let c2 = o3.slice(1).filter(Boolean).map((l4) => JSON.parse(l4));
    for (let l4 of c2) {
      let u3 = `_${l4.opp}State`;
      if (typeof this[u3] == "function")
        try {
          this[u3].bind(this)(...l4.args);
        } catch (N2) {
          console.warn("Error applying OPFS AHP WAL entry", l4, N2);
        }
    }
    let a2 = [], h3 = async (l4) => {
      if (l4.type === "file")
        try {
          let u3 = await h(this, F3).getFileHandle(l4.backingFilename), N2 = await u3.createSyncAccessHandle();
          h(this, b3).set(l4.backingFilename, u3), h(this, m3).set(l4.backingFilename, N2);
        } catch (u3) {
          console.error("Error opening file handle for node", l4, u3);
        }
      else
        for (let u3 of Object.values(l4.children))
          a2.push(h3(u3));
    };
    await h3(this.state.root);
    let d3 = [];
    for (let l4 of this.state.pool)
      d3.push(new Promise(async (u3) => {
        h(this, b3).has(l4) && console.warn("File handle already exists for pool file", l4);
        let N2 = await h(this, F3).getFileHandle(l4), U3 = await N2.createSyncAccessHandle();
        h(this, b3).set(l4, N2), h(this, m3).set(l4, U3), u3();
      }));
    await Promise.all([...a2, ...d3]), await this.maintainPool(i4 ? this.initialPoolSize : this.maintainedPoolSize);
  }, O2 = function(e, t) {
    let o3 = T(this, n2, k2).call(this, e);
    try {
      t();
    } catch (i4) {
      throw h(this, y2).truncate(o3), i4;
    }
  }, k2 = function(e) {
    let t = JSON.stringify(e), o3 = new TextEncoder().encode(`
${t}`), i4 = h(this, y2).getSize();
    return h(this, y2).write(o3, { at: i4 }), h(this, S2).add(h(this, y2)), i4;
  }, w3 = function(e) {
    return e.split("/").filter(Boolean);
  }, f2 = function(e, t) {
    let o3 = T(this, n2, w3).call(this, e), i4 = t || this.state.root;
    for (let c2 of o3) {
      if (i4.type !== "directory")
        throw new p2("ENOTDIR", "Not a directory");
      if (!Object.prototype.hasOwnProperty.call(i4.children, c2))
        throw new p2("ENOENT", "No such file or directory");
      i4 = i4.children[c2];
    }
    return i4;
  }, I = function(e) {
    let t = h(this, P3).get(e);
    if (!t)
      throw new p2("EBADF", "Bad file descriptor");
    return t;
  }, W2 = function() {
    let e = ++U(this, x4)._;
    for (;h(this, P3).has(e); )
      U(this, x4)._++;
    return e;
  }, j2 = async function(e, t) {
    let o3 = T(this, n2, w3).call(this, e), i4 = t?.from || h(this, H3);
    for (let c2 of o3)
      i4 = await i4.getDirectoryHandle(c2, { create: t?.create });
    return i4;
  };
  p2 = class extends Error {
    constructor(A2, e) {
      super(e), typeof A2 == "number" ? this.code = A2 : typeof A2 == "string" && (this.code = pr[A2]);
    }
  };
});

// node_modules/@electric-sql/pglite/dist/chunk-7PRRATDV.js
init_chunk_BTBUZ646();
var hn = {};
F(hn, { ABSTIME: () => Et, ACLITEM: () => Vt, BIT: () => Wt, BOOL: () => be, BPCHAR: () => _e, BYTEA: () => ge, CHAR: () => gt, CID: () => St, CIDR: () => Tt, CIRCLE: () => Ut, DATE: () => He, FLOAT4: () => je, FLOAT8: () => Qe, GTSVECTOR: () => rn, INET: () => kt, INT2: () => ve, INT4: () => Ge, INT8: () => we, INTERVAL: () => vt, JSON: () => Ae, JSONB: () => Ye, MACADDR: () => Ot, MACADDR8: () => Nt, MONEY: () => Lt, NUMERIC: () => Qt, OID: () => We, PATH: () => Mt, PG_DEPENDENCIES: () => en, PG_LSN: () => Xt, PG_NDISTINCT: () => Zt, PG_NODE_TREE: () => Bt, POLYGON: () => Rt, REFCURSOR: () => _t, REGCLASS: () => Yt, REGCONFIG: () => sn, REGDICTIONARY: () => an, REGNAMESPACE: () => on, REGOPER: () => Ht, REGOPERATOR: () => qt, REGPROC: () => wt, REGPROCEDURE: () => zt, REGROLE: () => un, REGTYPE: () => $t, RELTIME: () => Ct, SMGR: () => It, TEXT: () => F2, TID: () => At, TIME: () => Ft, TIMESTAMP: () => qe, TIMESTAMPTZ: () => xe, TIMETZ: () => Gt, TINTERVAL: () => Pt, TSQUERY: () => nn, TSVECTOR: () => tn, TXID_SNAPSHOT: () => Jt, UUID: () => Kt, VARBIT: () => jt, VARCHAR: () => ze, XID: () => xt, XML: () => Dt, arrayParser: () => yn, arraySerializer: () => Ke, parseType: () => ue, parsers: () => ln, serializers: () => cn, types: () => $e });
u();
var ht = globalThis.JSON.parse;
var bt = globalThis.JSON.stringify;
var be = 16;
var ge = 17;
var gt = 18;
var we = 20;
var ve = 21;
var Ge = 23;
var wt = 24;
var F2 = 25;
var We = 26;
var At = 27;
var xt = 28;
var St = 29;
var Ae = 114;
var Dt = 142;
var Bt = 194;
var It = 210;
var Mt = 602;
var Rt = 604;
var Tt = 650;
var je = 700;
var Qe = 701;
var Et = 702;
var Ct = 703;
var Pt = 704;
var Ut = 718;
var Nt = 774;
var Lt = 790;
var Ot = 829;
var kt = 869;
var Vt = 1033;
var _e = 1042;
var ze = 1043;
var He = 1082;
var Ft = 1083;
var qe = 1114;
var xe = 1184;
var vt = 1186;
var Gt = 1266;
var Wt = 1560;
var jt = 1562;
var Qt = 1700;
var _t = 1790;
var zt = 2202;
var Ht = 2203;
var qt = 2204;
var Yt = 2205;
var $t = 2206;
var Kt = 2950;
var Jt = 2970;
var Xt = 3220;
var Zt = 3361;
var en = 3402;
var tn = 3614;
var nn = 3615;
var rn = 3642;
var sn = 3734;
var an = 3769;
var Ye = 3802;
var on = 4089;
var un = 4096;
var $e = { string: { to: F2, from: [F2, ze, _e], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return e.toString();
  throw new Error("Invalid input for string type");
}, parse: (e) => e }, number: { to: 0, from: [ve, Ge, We, je, Qe], serialize: (e) => e.toString(), parse: (e) => +e }, bigint: { to: we, from: [we], serialize: (e) => e.toString(), parse: (e) => {
  let t = BigInt(e);
  return t < Number.MIN_SAFE_INTEGER || t > Number.MAX_SAFE_INTEGER ? t : Number(t);
} }, json: { to: Ae, from: [Ae, Ye], serialize: (e) => typeof e == "string" ? e : bt(e), parse: (e) => ht(e) }, boolean: { to: be, from: [be], serialize: (e) => {
  if (typeof e != "boolean")
    throw new Error("Invalid input for boolean type");
  return e ? "t" : "f";
}, parse: (e) => e === "t" }, date: { to: xe, from: [He, qe, xe], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return new Date(e).toISOString();
  if (e instanceof Date)
    return e.toISOString();
  throw new Error("Invalid input for date type");
}, parse: (e) => new Date(e) }, bytea: { to: ge, from: [ge], serialize: (e) => {
  if (!(e instanceof Uint8Array))
    throw new Error("Invalid input for bytea type");
  return "\\x" + Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}, parse: (e) => {
  let t = e.slice(2);
  return Uint8Array.from({ length: t.length / 2 }, (n2, r) => parseInt(t.substring(r * 2, (r + 1) * 2), 16));
} } };
var Se = pn($e);
var ln = Se.parsers;
var cn = Se.serializers;
function ue(e, t, n2) {
  if (e === null)
    return null;
  let r = n2?.[t] ?? Se.parsers[t];
  return r ? r(e, t) : e;
}
function pn(e) {
  return Object.keys(e).reduce(({ parsers: t, serializers: n2 }, r) => {
    let { to: i3, from: a2, serialize: u2, parse: d2 } = e[r];
    return n2[i3] = u2, n2[r] = u2, t[r] = d2, Array.isArray(a2) ? a2.forEach((c2) => {
      t[c2] = d2, n2[c2] = u2;
    }) : (t[a2] = d2, n2[a2] = u2), { parsers: t, serializers: n2 };
  }, { parsers: {}, serializers: {} });
}
var dn = /\\/g;
var fn = /"/g;
function mn(e) {
  return e.replace(dn, "\\\\").replace(fn, "\\\"");
}
function Ke(e, t, n2) {
  if (Array.isArray(e) === false)
    return e;
  if (!e.length)
    return "{}";
  let r = e[0], i3 = n2 === 1020 ? ";" : ",";
  return Array.isArray(r) ? `{${e.map((a2) => Ke(a2, t, n2)).join(i3)}}` : `{${e.map((a2) => (a2 === undefined && (a2 = null), a2 === null ? "null" : '"' + mn(t ? t(a2) : a2.toString()) + '"')).join(i3)}}`;
}
var he = { i: 0, char: null, str: "", quoted: false, last: 0, p: null };
function yn(e, t, n2) {
  return he.i = he.last = 0, Je(he, e, t, n2)[0];
}
function Je(e, t, n2, r) {
  let i3 = [], a2 = r === 1020 ? ";" : ",";
  for (;e.i < t.length; e.i++) {
    if (e.char = t[e.i], e.quoted)
      e.char === "\\" ? e.str += t[++e.i] : e.char === '"' ? (i3.push(n2 ? n2(e.str) : e.str), e.str = "", e.quoted = t[e.i + 1] === '"', e.last = e.i + 2) : e.str += e.char;
    else if (e.char === '"')
      e.quoted = true;
    else if (e.char === "{")
      e.last = ++e.i, i3.push(Je(e, t, n2, r));
    else if (e.char === "}") {
      e.quoted = false, e.last < e.i && i3.push(n2 ? n2(t.slice(e.last, e.i)) : t.slice(e.last, e.i)), e.last = e.i + 1;
      break;
    } else
      e.char === a2 && e.p !== "}" && e.p !== '"' && (i3.push(n2 ? n2(t.slice(e.last, e.i)) : t.slice(e.last, e.i)), e.last = e.i + 1);
    e.p = e.char;
  }
  return e.last < e.i && i3.push(n2 ? n2(t.slice(e.last, e.i + 1)) : t.slice(e.last, e.i + 1)), i3;
}
var wn = {};
F(wn, { parseDescribeStatementResults: () => De, parseResults: () => bn });
u();
function bn(e, t, n2, r) {
  let i3 = [], a2 = { rows: [], fields: [] }, u2 = 0, d2 = { ...t, ...n2?.parsers };
  return e.forEach((c2) => {
    switch (c2.name) {
      case "rowDescription": {
        let V = c2;
        a2.fields = V.fields.map((T2) => ({ name: T2.name, dataTypeID: T2.dataTypeID }));
        break;
      }
      case "dataRow": {
        if (!a2)
          break;
        let V = c2;
        n2?.rowMode === "array" ? a2.rows.push(V.fields.map((T2, ie) => ue(T2, a2.fields[ie].dataTypeID, d2))) : a2.rows.push(Object.fromEntries(V.fields.map((T2, ie) => [a2.fields[ie].name, ue(T2, a2.fields[ie].dataTypeID, d2)])));
        break;
      }
      case "commandComplete": {
        u2 += gn(c2), i3.push({ ...a2, affectedRows: u2, ...r ? { blob: r } : {} }), a2 = { rows: [], fields: [] };
        break;
      }
    }
  }), i3.length === 0 && i3.push({ affectedRows: 0, rows: [], fields: [] }), i3;
}
function gn(e) {
  let t = e.text.split(" ");
  switch (t[0]) {
    case "INSERT":
      return parseInt(t[2], 10);
    case "UPDATE":
    case "DELETE":
    case "COPY":
      return parseInt(t[1], 10);
    default:
      return 0;
  }
}
function De(e) {
  let t = e.find((n2) => n2.name === "parameterDescription");
  return t ? t.dataTypeIDs : [];
}
var Ue = {};
F(Ue, { AuthenticationCleartextPassword: () => G, AuthenticationMD5Password: () => W, AuthenticationOk: () => v, AuthenticationSASL: () => j, AuthenticationSASLContinue: () => Q, AuthenticationSASLFinal: () => _2, BackendKeyDataMessage: () => J, CommandCompleteMessage: () => ee, CopyDataMessage: () => z, CopyResponse: () => H, DataRowMessage: () => te, DatabaseError: () => E, Field: () => q, NoticeMessage: () => ne, NotificationResponseMessage: () => X, ParameterDescriptionMessage: () => $, ParameterStatusMessage: () => K, ReadyForQueryMessage: () => Z, RowDescriptionMessage: () => Y, bindComplete: () => Ie, closeComplete: () => Me, copyDone: () => Pe, emptyQuery: () => Ce, noData: () => Re, parseComplete: () => Be, portalSuspended: () => Te, replicationStart: () => Ee });
u();
var Be = { name: "parseComplete", length: 5 };
var Ie = { name: "bindComplete", length: 5 };
var Me = { name: "closeComplete", length: 5 };
var Re = { name: "noData", length: 5 };
var Te = { name: "portalSuspended", length: 5 };
var Ee = { name: "replicationStart", length: 4 };
var Ce = { name: "emptyQuery", length: 4 };
var Pe = { name: "copyDone", length: 4 };
var v = class {
  constructor(t) {
    this.length = t;
    this.name = "authenticationOk";
  }
};
var G = class {
  constructor(t) {
    this.length = t;
    this.name = "authenticationCleartextPassword";
  }
};
var W = class {
  constructor(t, n2) {
    this.length = t;
    this.salt = n2;
    this.name = "authenticationMD5Password";
  }
};
var j = class {
  constructor(t, n2) {
    this.length = t;
    this.mechanisms = n2;
    this.name = "authenticationSASL";
  }
};
var Q = class {
  constructor(t, n2) {
    this.length = t;
    this.data = n2;
    this.name = "authenticationSASLContinue";
  }
};
var _2 = class {
  constructor(t, n2) {
    this.length = t;
    this.data = n2;
    this.name = "authenticationSASLFinal";
  }
};
var E = class extends Error {
  constructor(n2, r, i3) {
    super(n2);
    this.length = r;
    this.name = i3;
  }
};
var z = class {
  constructor(t, n2) {
    this.length = t;
    this.chunk = n2;
    this.name = "copyData";
  }
};
var H = class {
  constructor(t, n2, r, i3) {
    this.length = t;
    this.name = n2;
    this.binary = r;
    this.columnTypes = new Array(i3);
  }
};
var q = class {
  constructor(t, n2, r, i3, a2, u2, d2) {
    this.name = t;
    this.tableID = n2;
    this.columnID = r;
    this.dataTypeID = i3;
    this.dataTypeSize = a2;
    this.dataTypeModifier = u2;
    this.format = d2;
  }
};
var Y = class {
  constructor(t, n2) {
    this.length = t;
    this.fieldCount = n2;
    this.name = "rowDescription";
    this.fields = new Array(this.fieldCount);
  }
};
var $ = class {
  constructor(t, n2) {
    this.length = t;
    this.parameterCount = n2;
    this.name = "parameterDescription";
    this.dataTypeIDs = new Array(this.parameterCount);
  }
};
var K = class {
  constructor(t, n2, r) {
    this.length = t;
    this.parameterName = n2;
    this.parameterValue = r;
    this.name = "parameterStatus";
  }
};
var J = class {
  constructor(t, n2, r) {
    this.length = t;
    this.processID = n2;
    this.secretKey = r;
    this.name = "backendKeyData";
  }
};
var X = class {
  constructor(t, n2, r, i3) {
    this.length = t;
    this.processId = n2;
    this.channel = r;
    this.payload = i3;
    this.name = "notification";
  }
};
var Z = class {
  constructor(t, n2) {
    this.length = t;
    this.status = n2;
    this.name = "readyForQuery";
  }
};
var ee = class {
  constructor(t, n2) {
    this.length = t;
    this.text = n2;
    this.name = "commandComplete";
  }
};
var te = class {
  constructor(t, n2) {
    this.length = t;
    this.fields = n2;
    this.name = "dataRow";
    this.fieldCount = n2.length;
  }
};
var ne = class {
  constructor(t, n2) {
    this.length = t;
    this.message = n2;
    this.name = "notice";
  }
};
var zn = {};
F(zn, { Parser: () => ye, messages: () => Ue, serialize: () => O });
u();
u();
u();
u();
function C(e) {
  let t = e.length;
  for (let n2 = e.length - 1;n2 >= 0; n2--) {
    let r = e.charCodeAt(n2);
    r > 127 && r <= 2047 ? t++ : r > 2047 && r <= 65535 && (t += 2), r >= 56320 && r <= 57343 && n2--;
  }
  return t;
}
var b;
var g2;
var U2;
var ce;
var N;
var x2;
var le;
var P2;
var Xe;
var R2 = class {
  constructor(t = 256) {
    this.size = t;
    R(this, x2);
    R(this, b);
    R(this, g2, 5);
    R(this, U2, false);
    R(this, ce, new TextEncoder);
    R(this, N, 0);
    x(this, b, T(this, x2, le).call(this, t));
  }
  addInt32(t) {
    return T(this, x2, P2).call(this, 4), h(this, b).setInt32(h(this, g2), t, h(this, U2)), x(this, g2, h(this, g2) + 4), this;
  }
  addInt16(t) {
    return T(this, x2, P2).call(this, 2), h(this, b).setInt16(h(this, g2), t, h(this, U2)), x(this, g2, h(this, g2) + 2), this;
  }
  addCString(t) {
    return t && this.addString(t), T(this, x2, P2).call(this, 1), h(this, b).setUint8(h(this, g2), 0), U(this, g2)._++, this;
  }
  addString(t = "") {
    let n2 = C(t);
    return T(this, x2, P2).call(this, n2), h(this, ce).encodeInto(t, new Uint8Array(h(this, b).buffer, h(this, g2))), x(this, g2, h(this, g2) + n2), this;
  }
  add(t) {
    return T(this, x2, P2).call(this, t.byteLength), new Uint8Array(h(this, b).buffer).set(new Uint8Array(t), h(this, g2)), x(this, g2, h(this, g2) + t.byteLength), this;
  }
  flush(t) {
    let n2 = T(this, x2, Xe).call(this, t);
    return x(this, g2, 5), x(this, b, T(this, x2, le).call(this, this.size)), new Uint8Array(n2);
  }
};
b = new WeakMap, g2 = new WeakMap, U2 = new WeakMap, ce = new WeakMap, N = new WeakMap, x2 = new WeakSet, le = function(t) {
  return new DataView(new ArrayBuffer(t));
}, P2 = function(t) {
  if (h(this, b).byteLength - h(this, g2) < t) {
    let r = h(this, b).buffer, i3 = r.byteLength + (r.byteLength >> 1) + t;
    x(this, b, T(this, x2, le).call(this, i3)), new Uint8Array(h(this, b).buffer).set(new Uint8Array(r));
  }
}, Xe = function(t) {
  if (t) {
    h(this, b).setUint8(h(this, N), t);
    let n2 = h(this, g2) - (h(this, N) + 1);
    h(this, b).setInt32(h(this, N) + 1, n2, h(this, U2));
  }
  return h(this, b).buffer.slice(t ? 0 : 5, h(this, g2));
};
var m = new R2;
var An = (e) => {
  m.addInt16(3).addInt16(0);
  for (let r of Object.keys(e))
    m.addCString(r).addCString(e[r]);
  m.addCString("client_encoding").addCString("UTF8");
  let t = m.addCString("").flush(), n2 = t.byteLength + 4;
  return new R2().addInt32(n2).add(t).flush();
};
var xn = () => {
  let e = new DataView(new ArrayBuffer(8));
  return e.setInt32(0, 8, false), e.setInt32(4, 80877103, false), new Uint8Array(e.buffer);
};
var Sn = (e) => m.addCString(e).flush(112);
var Dn = (e, t) => (m.addCString(e).addInt32(C(t)).addString(t), m.flush(112));
var Bn = (e) => m.addString(e).flush(112);
var In = (e) => m.addCString(e).flush(81);
var Mn = [];
var Rn = (e) => {
  let t = e.name ?? "";
  t.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", t, t.length), console.error("This can cause conflicts and silent errors executing queries"));
  let n2 = m.addCString(t).addCString(e.text).addInt16(e.types?.length ?? 0);
  return e.types?.forEach((r) => n2.addInt32(r)), m.flush(80);
};
var L2 = new R2;
var Tn = (e, t) => {
  for (let n2 = 0;n2 < e.length; n2++) {
    let r = t ? t(e[n2], n2) : e[n2];
    if (r === null)
      m.addInt16(0), L2.addInt32(-1);
    else if (r instanceof ArrayBuffer || ArrayBuffer.isView(r)) {
      let i3 = ArrayBuffer.isView(r) ? r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength) : r;
      m.addInt16(1), L2.addInt32(i3.byteLength), L2.add(i3);
    } else
      m.addInt16(0), L2.addInt32(C(r)), L2.addString(r);
  }
};
var En = (e = {}) => {
  let t = e.portal ?? "", n2 = e.statement ?? "", r = e.binary ?? false, i3 = e.values ?? Mn, a2 = i3.length;
  return m.addCString(t).addCString(n2), m.addInt16(a2), Tn(i3, e.valueMapper), m.addInt16(a2), m.add(L2.flush()), m.addInt16(r ? 1 : 0), m.flush(66);
};
var Cn = new Uint8Array([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
var Pn = (e) => {
  if (!e || !e.portal && !e.rows)
    return Cn;
  let t = e.portal ?? "", n2 = e.rows ?? 0, r = C(t), i3 = 4 + r + 1 + 4, a2 = new DataView(new ArrayBuffer(1 + i3));
  return a2.setUint8(0, 69), a2.setInt32(1, i3, false), new TextEncoder().encodeInto(t, new Uint8Array(a2.buffer, 5)), a2.setUint8(r + 5, 0), a2.setUint32(a2.byteLength - 4, n2, false), new Uint8Array(a2.buffer);
};
var Un = (e, t) => {
  let n2 = new DataView(new ArrayBuffer(16));
  return n2.setInt32(0, 16, false), n2.setInt16(4, 1234, false), n2.setInt16(6, 5678, false), n2.setInt32(8, e, false), n2.setInt32(12, t, false), new Uint8Array(n2.buffer);
};
var Ne = (e, t) => {
  let n2 = new R2;
  return n2.addCString(t), n2.flush(e);
};
var Nn = m.addCString("P").flush(68);
var Ln = m.addCString("S").flush(68);
var On = (e) => e.name ? Ne(68, `${e.type}${e.name ?? ""}`) : e.type === "P" ? Nn : Ln;
var kn = (e) => {
  let t = `${e.type}${e.name ?? ""}`;
  return Ne(67, t);
};
var Vn = (e) => m.add(e).flush(100);
var Fn = (e) => Ne(102, e);
var pe = (e) => new Uint8Array([e, 0, 0, 0, 4]);
var vn = pe(72);
var Gn = pe(83);
var Wn = pe(88);
var jn = pe(99);
var O = { startup: An, password: Sn, requestSsl: xn, sendSASLInitialResponseMessage: Dn, sendSCRAMClientFinalMessage: Bn, query: In, parse: Rn, bind: En, execute: Pn, describe: On, close: kn, flush: () => vn, sync: () => Gn, end: () => Wn, copyData: Vn, copyDone: () => jn, copyFail: Fn, cancel: Un };
u();
u();
var Le = { text: 0, binary: 1 };
u();
var Qn = new ArrayBuffer(0);
var M;
var w;
var fe;
var me;
var re;
var de = class {
  constructor(t = 0) {
    R(this, M, new DataView(Qn));
    R(this, w);
    R(this, fe, "utf-8");
    R(this, me, new TextDecoder(h(this, fe)));
    R(this, re, false);
    x(this, w, t);
  }
  setBuffer(t, n2) {
    x(this, w, t), x(this, M, new DataView(n2));
  }
  int16() {
    let t = h(this, M).getInt16(h(this, w), h(this, re));
    return x(this, w, h(this, w) + 2), t;
  }
  byte() {
    let t = h(this, M).getUint8(h(this, w));
    return U(this, w)._++, t;
  }
  int32() {
    let t = h(this, M).getInt32(h(this, w), h(this, re));
    return x(this, w, h(this, w) + 4), t;
  }
  string(t) {
    return h(this, me).decode(this.bytes(t));
  }
  cstring() {
    let t = h(this, w), n2 = t;
    for (;h(this, M).getUint8(n2++) !== 0; )
      ;
    let r = this.string(n2 - t - 1);
    return x(this, w, n2), r;
  }
  bytes(t) {
    let n2 = h(this, M).buffer.slice(h(this, w), h(this, w) + t);
    return x(this, w, h(this, w) + t), new Uint8Array(n2);
  }
};
M = new WeakMap, w = new WeakMap, fe = new WeakMap, me = new WeakMap, re = new WeakMap;
var Oe = 1;
var _n = 4;
var Ze = Oe + _n;
var et = new ArrayBuffer(0);
var A;
var S;
var D2;
var o;
var l2;
var tt;
var nt;
var rt;
var st;
var it;
var at;
var ot;
var ke;
var ut;
var lt;
var ct;
var pt;
var dt;
var ft;
var mt;
var yt;
var Ve;
var ye = class {
  constructor() {
    R(this, l2);
    R(this, A, new DataView(et));
    R(this, S, 0);
    R(this, D2, 0);
    R(this, o, new de);
  }
  parse(t, n2) {
    T(this, l2, tt).call(this, ArrayBuffer.isView(t) ? t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength) : t);
    let r = h(this, D2) + h(this, S), i3 = h(this, D2);
    for (;i3 + Ze <= r; ) {
      let a2 = h(this, A).getUint8(i3), u2 = h(this, A).getUint32(i3 + Oe, false), d2 = Oe + u2;
      if (d2 + i3 <= r) {
        let c2 = T(this, l2, nt).call(this, i3 + Ze, a2, u2, h(this, A).buffer);
        n2(c2), i3 += d2;
      } else
        break;
    }
    i3 === r ? (x(this, A, new DataView(et)), x(this, S, 0), x(this, D2, 0)) : (x(this, S, r - i3), x(this, D2, i3));
  }
};
A = new WeakMap, S = new WeakMap, D2 = new WeakMap, o = new WeakMap, l2 = new WeakSet, tt = function(t) {
  if (h(this, S) > 0) {
    let n2 = h(this, S) + t.byteLength;
    if (n2 + h(this, D2) > h(this, A).byteLength) {
      let i3;
      if (n2 <= h(this, A).byteLength && h(this, D2) >= h(this, S))
        i3 = h(this, A).buffer;
      else {
        let a2 = h(this, A).byteLength * 2;
        for (;n2 >= a2; )
          a2 *= 2;
        i3 = new ArrayBuffer(a2);
      }
      new Uint8Array(i3).set(new Uint8Array(h(this, A).buffer, h(this, D2), h(this, S))), x(this, A, new DataView(i3)), x(this, D2, 0);
    }
    new Uint8Array(h(this, A).buffer).set(new Uint8Array(t), h(this, D2) + h(this, S)), x(this, S, n2);
  } else
    x(this, A, new DataView(t)), x(this, D2, 0), x(this, S, t.byteLength);
}, nt = function(t, n2, r, i3) {
  switch (n2) {
    case 50:
      return Ie;
    case 49:
      return Be;
    case 51:
      return Me;
    case 110:
      return Re;
    case 115:
      return Te;
    case 99:
      return Pe;
    case 87:
      return Ee;
    case 73:
      return Ce;
    case 68:
      return T(this, l2, dt).call(this, t, r, i3);
    case 67:
      return T(this, l2, st).call(this, t, r, i3);
    case 90:
      return T(this, l2, rt).call(this, t, r, i3);
    case 65:
      return T(this, l2, ut).call(this, t, r, i3);
    case 82:
      return T(this, l2, yt).call(this, t, r, i3);
    case 83:
      return T(this, l2, ft).call(this, t, r, i3);
    case 75:
      return T(this, l2, mt).call(this, t, r, i3);
    case 69:
      return T(this, l2, Ve).call(this, t, r, i3, "error");
    case 78:
      return T(this, l2, Ve).call(this, t, r, i3, "notice");
    case 84:
      return T(this, l2, lt).call(this, t, r, i3);
    case 116:
      return T(this, l2, pt).call(this, t, r, i3);
    case 71:
      return T(this, l2, at).call(this, t, r, i3);
    case 72:
      return T(this, l2, ot).call(this, t, r, i3);
    case 100:
      return T(this, l2, it).call(this, t, r, i3);
    default:
      return new E("received invalid response: " + n2.toString(16), r, "error");
  }
}, rt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).string(1);
  return new Z(n2, i3);
}, st = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).cstring();
  return new ee(n2, i3);
}, it = function(t, n2, r) {
  let i3 = r.slice(t, t + (n2 - 4));
  return new z(n2, new Uint8Array(i3));
}, at = function(t, n2, r) {
  return T(this, l2, ke).call(this, t, n2, r, "copyInResponse");
}, ot = function(t, n2, r) {
  return T(this, l2, ke).call(this, t, n2, r, "copyOutResponse");
}, ke = function(t, n2, r, i3) {
  h(this, o).setBuffer(t, r);
  let a2 = h(this, o).byte() !== 0, u2 = h(this, o).int16(), d2 = new H(n2, i3, a2, u2);
  for (let c2 = 0;c2 < u2; c2++)
    d2.columnTypes[c2] = h(this, o).int16();
  return d2;
}, ut = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int32(), a2 = h(this, o).cstring(), u2 = h(this, o).cstring();
  return new X(n2, i3, a2, u2);
}, lt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int16(), a2 = new Y(n2, i3);
  for (let u2 = 0;u2 < i3; u2++)
    a2.fields[u2] = T(this, l2, ct).call(this);
  return a2;
}, ct = function() {
  let t = h(this, o).cstring(), n2 = h(this, o).int32(), r = h(this, o).int16(), i3 = h(this, o).int32(), a2 = h(this, o).int16(), u2 = h(this, o).int32(), d2 = h(this, o).int16() === 0 ? Le.text : Le.binary;
  return new q(t, n2, r, i3, a2, u2, d2);
}, pt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int16(), a2 = new $(n2, i3);
  for (let u2 = 0;u2 < i3; u2++)
    a2.dataTypeIDs[u2] = h(this, o).int32();
  return a2;
}, dt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int16(), a2 = new Array(i3);
  for (let u2 = 0;u2 < i3; u2++) {
    let d2 = h(this, o).int32();
    a2[u2] = d2 === -1 ? null : h(this, o).string(d2);
  }
  return new te(n2, a2);
}, ft = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).cstring(), a2 = h(this, o).cstring();
  return new K(n2, i3, a2);
}, mt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int32(), a2 = h(this, o).int32();
  return new J(n2, i3, a2);
}, yt = function(t, n2, r) {
  h(this, o).setBuffer(t, r);
  let i3 = h(this, o).int32();
  switch (i3) {
    case 0:
      return new v(n2);
    case 3:
      return new G(n2);
    case 5:
      return new W(n2, h(this, o).bytes(4));
    case 10: {
      let a2 = [];
      for (;; ) {
        let u2 = h(this, o).cstring();
        if (u2.length === 0)
          return new j(n2, a2);
        a2.push(u2);
      }
    }
    case 11:
      return new Q(n2, h(this, o).string(n2 - 8));
    case 12:
      return new _2(n2, h(this, o).string(n2 - 8));
    default:
      throw new Error("Unknown authenticationOk message type " + i3);
  }
}, Ve = function(t, n2, r, i3) {
  h(this, o).setBuffer(t, r);
  let a2 = {}, u2 = h(this, o).string(1);
  for (;u2 !== "\x00"; )
    a2[u2] = h(this, o).cstring(), u2 = h(this, o).string(1);
  let d2 = a2.M, c2 = i3 === "notice" ? new ne(n2, d2) : new E(d2, n2, i3);
  return c2.severity = a2.S, c2.code = a2.C, c2.detail = a2.D, c2.hint = a2.H, c2.position = a2.P, c2.internalPosition = a2.p, c2.internalQuery = a2.q, c2.where = a2.W, c2.schema = a2.s, c2.table = a2.t, c2.column = a2.c, c2.dataType = a2.d, c2.constraint = a2.n, c2.file = a2.F, c2.line = a2.L, c2.routine = a2.R, c2;
};
u();
var Fe = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
var se;
async function Rr() {
  if (Fe || se)
    return;
  let e = new URL("./pglite.wasm", import.meta.url);
  se = fetch(e);
}
var k;
async function Tr(e, t) {
  if (t || k)
    return WebAssembly.instantiate(t || k, e), { instance: await WebAssembly.instantiate(t || k, e), module: t || k };
  let n2 = new URL("./pglite.wasm", import.meta.url);
  if (Fe) {
    let i3 = await (await import("fs/promises")).readFile(n2), { module: a2, instance: u2 } = await WebAssembly.instantiate(i3, e);
    return k = a2, { instance: u2, module: a2 };
  } else {
    se || (se = fetch(n2));
    let r = await se, { module: i3, instance: a2 } = await WebAssembly.instantiateStreaming(r, e);
    return k = i3, { instance: a2, module: i3 };
  }
}
async function Er() {
  let e = new URL("./pglite.data", import.meta.url);
  return Fe ? (await (await import("fs/promises")).readFile(e)).buffer : (await fetch(e)).arrayBuffer();
}
var Cr = () => {
  if (globalThis.crypto?.randomUUID)
    return globalThis.crypto.randomUUID();
  let e = new Uint8Array(16);
  if (globalThis.crypto?.getRandomValues)
    globalThis.crypto.getRandomValues(e);
  else
    for (let n2 = 0;n2 < e.length; n2++)
      e[n2] = Math.floor(Math.random() * 256);
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  let t = [];
  return e.forEach((n2) => {
    t.push(n2.toString(16).padStart(2, "0"));
  }), t.slice(0, 4).join("") + "-" + t.slice(4, 6).join("") + "-" + t.slice(6, 8).join("") + "-" + t.slice(8, 10).join("") + "-" + t.slice(10).join("");
};
function Nr(e) {
  let t;
  return e.startsWith('"') && e.endsWith('"') ? t = e.substring(1, e.length - 1) : t = e.toLowerCase(), t;
}

// node_modules/@electric-sql/pglite/dist/chunk-STOZMFXW.js
init_chunk_BTBUZ646();
u();
var o2 = { part: "part", container: "container" };
function s2(t, r, ...e) {
  let a2 = t.length - 1, p2 = e.length - 1;
  if (p2 !== -1) {
    if (p2 === 0) {
      t[a2] = t[a2] + e[0] + r;
      return;
    }
    t[a2] = t[a2] + e[0], t.push(...e.slice(1, p2)), t.push(e[p2] + r);
  }
}
function y(t, ...r) {
  let e = [t[0]];
  e.raw = [t.raw[0]];
  let a2 = [];
  for (let p2 = 0;p2 < r.length; p2++) {
    let n2 = r[p2], i3 = p2 + 1;
    if (n2?._templateType === o2.part) {
      s2(e, t[i3], n2.str), s2(e.raw, t.raw[i3], n2.str);
      continue;
    }
    if (n2?._templateType === o2.container) {
      s2(e, t[i3], ...n2.strings), s2(e.raw, t.raw[i3], ...n2.strings.raw), a2.push(...n2.values);
      continue;
    }
    e.push(t[i3]), e.raw.push(t.raw[i3]), a2.push(n2);
  }
  return { _templateType: "container", strings: e, values: a2 };
}
function g3(t, ...r) {
  let { strings: e, values: a2 } = y(t, ...r);
  return { query: [e[0], ...a2.flatMap((p2, n2) => [`$${n2 + 1}`, e[n2 + 1]])].join(""), params: a2 };
}

// node_modules/@electric-sql/pglite/dist/chunk-TGYMLQND.js
init_chunk_BTBUZ646();
u();
var b2;
var u2;
var r;
var l3;
var d2;
var h2;
var R3;
var z2 = class {
  constructor() {
    R(this, r);
    this.serializers = { ...cn };
    this.parsers = { ...ln };
    R(this, b2, false);
    R(this, u2, false);
  }
  async _initArrayTypes({ force: t = false } = {}) {
    if (h(this, b2) && !t)
      return;
    x(this, b2, true);
    let e = await this.query(`
      SELECT b.oid, b.typarray
      FROM pg_catalog.pg_type a
      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem
      WHERE a.typcategory = 'A'
      GROUP BY b.oid, b.typarray
      ORDER BY b.oid
    `);
    for (let s3 of e.rows)
      this.serializers[s3.typarray] = (i3) => Ke(i3, this.serializers[s3.oid], s3.typarray), this.parsers[s3.typarray] = (i3) => yn(i3, this.parsers[s3.oid], s3.typarray);
  }
  async refreshArrayTypes() {
    await this._initArrayTypes({ force: true });
  }
  async query(t, e, s3) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await T(this, r, d2).call(this, t, e, s3));
  }
  async sql(t, ...e) {
    let { query: s3, params: i3 } = g3(t, ...e);
    return await this.query(s3, i3);
  }
  async exec(t, e) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await T(this, r, h2).call(this, t, e));
  }
  async describeQuery(t, e) {
    try {
      await T(this, r, l3).call(this, O.parse({ text: t, types: e?.paramTypes }), e);
      let s3 = await T(this, r, l3).call(this, O.describe({ type: "S" }), e), i3 = s3.messages.find((n2) => n2.name === "parameterDescription"), c2 = s3.messages.find((n2) => n2.name === "rowDescription"), y2 = i3?.dataTypeIDs.map((n2) => ({ dataTypeID: n2, serializer: this.serializers[n2] })) ?? [], m2 = c2?.fields.map((n2) => ({ name: n2.name, dataTypeID: n2.dataTypeID, parser: this.parsers[n2.dataTypeID] })) ?? [];
      return { queryParams: y2, resultFields: m2 };
    } finally {
      await T(this, r, l3).call(this, O.sync(), e);
    }
  }
  async transaction(t) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => {
      await T(this, r, h2).call(this, "BEGIN"), x(this, u2, true);
      let e = false, s3 = () => {
        if (e)
          throw new Error("Transaction is closed");
      }, i3 = { query: async (c2, y2, m2) => (s3(), await T(this, r, d2).call(this, c2, y2, m2)), sql: async (c2, ...y2) => {
        let { query: m2, params: n2 } = g3(c2, ...y2);
        return await T(this, r, d2).call(this, m2, n2);
      }, exec: async (c2, y2) => (s3(), await T(this, r, h2).call(this, c2, y2)), rollback: async () => {
        s3(), await T(this, r, h2).call(this, "ROLLBACK"), e = true;
      }, get closed() {
        return e;
      } };
      try {
        let c2 = await t(i3);
        return e || (e = true, await T(this, r, h2).call(this, "COMMIT")), x(this, u2, false), c2;
      } catch (c2) {
        throw e || await T(this, r, h2).call(this, "ROLLBACK"), x(this, u2, false), c2;
      }
    });
  }
  async runExclusive(t) {
    return await this._runExclusiveQuery(t);
  }
};
b2 = new WeakMap, u2 = new WeakMap, r = new WeakSet, l3 = async function(t, e = {}) {
  return await this.execProtocol(t, { ...e, syncToFs: false });
}, d2 = async function(t, e = [], s3) {
  return await this._runExclusiveQuery(async () => {
    T(this, r, R3).call(this, "runQuery", t, e, s3), await this._handleBlob(s3?.blob);
    let i3;
    try {
      let { messages: y2 } = await T(this, r, l3).call(this, O.parse({ text: t, types: s3?.paramTypes }), s3), m2 = De((await T(this, r, l3).call(this, O.describe({ type: "S" }), s3)).messages), n2 = e.map((T2, B) => {
        let x3 = m2[B];
        if (T2 == null)
          return null;
        let _3 = s3?.serializers?.[x3] ?? this.serializers[x3];
        return _3 ? _3(T2) : T2.toString();
      });
      i3 = [...y2, ...(await T(this, r, l3).call(this, O.bind({ values: n2 }), s3)).messages, ...(await T(this, r, l3).call(this, O.describe({ type: "P" }), s3)).messages, ...(await T(this, r, l3).call(this, O.execute({}), s3)).messages];
    } finally {
      await T(this, r, l3).call(this, O.sync(), s3);
    }
    await this._cleanupBlob(), h(this, u2) || await this.syncToFs();
    let c2 = await this._getWrittenBlob();
    return bn(i3, this.parsers, s3, c2)[0];
  });
}, h2 = async function(t, e) {
  return await this._runExclusiveQuery(async () => {
    T(this, r, R3).call(this, "runExec", t, e), await this._handleBlob(e?.blob);
    let s3;
    try {
      s3 = (await T(this, r, l3).call(this, O.query(t), e)).messages;
    } finally {
      await T(this, r, l3).call(this, O.sync(), e);
    }
    this._cleanupBlob(), h(this, u2) || await this.syncToFs();
    let i3 = await this._getWrittenBlob();
    return bn(s3, this.parsers, e, i3);
  });
}, R3 = function(...t) {
  this.debug > 0 && console.log(...t);
};

// node_modules/@electric-sql/pglite/dist/index.js
init_chunk_WGR4JCLS();
init_chunk_BTBUZ646();
u();
u();
u();
var et2 = new Error("timeout while waiting for mutex to become available");
var tt2 = new Error("mutex already locked");
var Ke2 = new Error("request for lock canceled");
var Ye2 = function(e, t, r2, a2) {
  function o3(s4) {
    return s4 instanceof r2 ? s4 : new r2(function(l4) {
      l4(s4);
    });
  }
  return new (r2 || (r2 = Promise))(function(s4, l4) {
    function _3(p3) {
      try {
        m4(a2.next(p3));
      } catch (d3) {
        l4(d3);
      }
    }
    function n3(p3) {
      try {
        m4(a2.throw(p3));
      } catch (d3) {
        l4(d3);
      }
    }
    function m4(p3) {
      p3.done ? s4(p3.value) : o3(p3.value).then(_3, n3);
    }
    m4((a2 = a2.apply(e, t || [])).next());
  });
};
var fe2 = class {
  constructor(t, r2 = Ke2) {
    this._value = t, this._cancelError = r2, this._weightedQueues = [], this._weightedWaiters = [];
  }
  acquire(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((r2, a2) => {
      this._weightedQueues[t - 1] || (this._weightedQueues[t - 1] = []), this._weightedQueues[t - 1].push({ resolve: r2, reject: a2 }), this._dispatch();
    });
  }
  runExclusive(t, r2 = 1) {
    return Ye2(this, undefined, undefined, function* () {
      let [a2, o3] = yield this.acquire(r2);
      try {
        return yield t(a2);
      } finally {
        o3();
      }
    });
  }
  waitForUnlock(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((r2) => {
      this._weightedWaiters[t - 1] || (this._weightedWaiters[t - 1] = []), this._weightedWaiters[t - 1].push(r2), this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(t) {
    this._value = t, this._dispatch();
  }
  release(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    this._value += t, this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((t) => t.forEach((r2) => r2.reject(this._cancelError))), this._weightedQueues = [];
  }
  _dispatch() {
    var t;
    for (let r2 = this._value;r2 > 0; r2--) {
      let a2 = (t = this._weightedQueues[r2 - 1]) === null || t === undefined ? undefined : t.shift();
      if (!a2)
        continue;
      let o3 = this._value, s4 = r2;
      this._value -= r2, r2 = this._value + 1, a2.resolve([o3, this._newReleaser(s4)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(t) {
    let r2 = false;
    return () => {
      r2 || (r2 = true, this.release(t));
    };
  }
  _drainUnlockWaiters() {
    for (let t = this._value;t > 0; t--)
      this._weightedWaiters[t - 1] && (this._weightedWaiters[t - 1].forEach((r2) => r2()), this._weightedWaiters[t - 1] = []);
  }
};
var Je2 = function(e, t, r2, a2) {
  function o3(s4) {
    return s4 instanceof r2 ? s4 : new r2(function(l4) {
      l4(s4);
    });
  }
  return new (r2 || (r2 = Promise))(function(s4, l4) {
    function _3(p3) {
      try {
        m4(a2.next(p3));
      } catch (d3) {
        l4(d3);
      }
    }
    function n3(p3) {
      try {
        m4(a2.throw(p3));
      } catch (d3) {
        l4(d3);
      }
    }
    function m4(p3) {
      p3.done ? s4(p3.value) : o3(p3.value).then(_3, n3);
    }
    m4((a2 = a2.apply(e, t || [])).next());
  });
};
var X2 = class {
  constructor(t) {
    this._semaphore = new fe2(1, t);
  }
  acquire() {
    return Je2(this, undefined, undefined, function* () {
      let [, t] = yield this._semaphore.acquire();
      return t;
    });
  }
  runExclusive(t) {
    return this._semaphore.runExclusive(() => t());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
u();
var Pe2 = L(or(), 1);
async function xe2(e) {
  if (Fe) {
    let t = await import("fs"), r2 = await Promise.resolve().then(() => (init_zlib(), exports_zlib)), { Writable: a2 } = await Promise.resolve().then(() => __toESM(require_stream(), 1)), { pipeline: o3 } = await import("stream/promises");
    if (!t.existsSync(e))
      throw new Error(`Extension bundle not found: ${e}`);
    let s4 = r2.createGunzip(), l4 = [];
    return await o3(t.createReadStream(e), s4, new a2({ write(_3, n3, m4) {
      l4.push(_3), m4();
    } })), new Blob(l4);
  } else {
    let t = await fetch(e.toString());
    if (!t.ok || !t.body)
      return null;
    if (t.headers.get("Content-Encoding") === "gzip")
      return t.blob();
    {
      let r2 = new DecompressionStream("gzip");
      return new Response(t.body.pipeThrough(r2)).blob();
    }
  }
}
async function ke2(e, t) {
  for (let r2 in e.pg_extensions) {
    let a2;
    try {
      a2 = await e.pg_extensions[r2];
    } catch (o3) {
      console.error("Failed to fetch extension:", r2, o3);
      continue;
    }
    if (a2) {
      let o3 = new Uint8Array(await a2.arrayBuffer());
      Qe2(e, r2, o3, t);
    } else
      console.error("Could not get binary data for extension:", r2);
  }
}
function Qe2(e, t, r2, a2) {
  Pe2.default.untar(r2).forEach((s4) => {
    if (!s4.name.startsWith(".")) {
      let l4 = e.WASM_PREFIX + "/" + s4.name;
      if (s4.name.endsWith(".so")) {
        let _3 = (...m4) => {
          a2("pgfs:ext OK", l4, m4);
        }, n3 = (...m4) => {
          a2("pgfs:ext FAIL", l4, m4);
        };
        e.FS.createPreloadedFile($e2(l4), s4.name.split("/").pop().slice(0, -3), s4.data, true, true, _3, n3, false);
      } else
        e.FS.writeFile(l4, s4.data);
    }
  });
}
function $e2(e) {
  let t = e.lastIndexOf("/");
  return t > 0 ? e.slice(0, t) : e;
}
u();
u();
var ee2 = class extends ur {
  async init(t, r2) {
    return this.pg = t, { emscriptenOpts: { ...r2, preRun: [...r2.preRun || [], (o3) => {
      let s4 = o3.FS.filesystems.IDBFS;
      o3.FS.mkdir("/pglite"), o3.FS.mkdir(`/pglite/${this.dataDir}`), o3.FS.mount(s4, {}, `/pglite/${this.dataDir}`), o3.FS.symlink(`/pglite/${this.dataDir}`, C2);
    }] } };
  }
  initialSyncFs() {
    return new Promise((t, r2) => {
      this.pg.Module.FS.syncfs(true, (a2) => {
        a2 ? r2(a2) : t();
      });
    });
  }
  syncToFs(t) {
    return new Promise((r2, a2) => {
      this.pg.Module.FS.syncfs(false, (o3) => {
        o3 ? a2(o3) : r2();
      });
    });
  }
  async closeFs() {
    let t = this.pg.Module.FS.filesystems.IDBFS.dbs[this.dataDir];
    t && t.close(), this.pg.Module.FS.quit();
  }
};
u();
var te2 = class extends ur {
  async closeFs() {
    this.pg.Module.FS.quit();
  }
};
function Ae2(e) {
  let t;
  if (e?.startsWith("file://")) {
    if (e = e.slice(7), !e)
      throw new Error("Invalid dataDir, must be a valid path");
    t = "nodefs";
  } else
    e?.startsWith("idb://") ? (e = e.slice(6), t = "idbfs") : e?.startsWith("opfs-ahp://") ? (e = e.slice(11), t = "opfs-ahp") : !e || e?.startsWith("memory://") ? t = "memoryfs" : t = "nodefs";
  return { dataDir: e, fsType: t };
}
async function Te2(e, t) {
  let r2;
  if (e && t === "nodefs") {
    let { NodeFS: a2 } = await Promise.resolve().then(() => (init_nodefs(), exports_nodefs));
    r2 = new a2(e);
  } else if (e && t === "idbfs")
    r2 = new ee2(e);
  else if (e && t === "opfs-ahp") {
    let { OpfsAhpFS: a2 } = await Promise.resolve().then(() => (init_opfs_ahp(), exports_opfs_ahp));
    r2 = new a2(e);
  } else
    r2 = new te2;
  return r2;
}
u();
u();
var Ze2 = (() => {
  var _scriptName = import.meta.url;
  return async function(moduleArg = {}) {
    var moduleRtn, Module = moduleArg, readyPromiseResolve, readyPromiseReject, readyPromise = new Promise((e, t) => {
      readyPromiseResolve = e, readyPromiseReject = t;
    }), ENVIRONMENT_IS_WEB = typeof window == "object", ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope < "u", ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    if (ENVIRONMENT_IS_NODE) {
      let { createRequire: e } = await import("module"), t = import.meta.url;
      t.startsWith("data:") && (t = "/");
      var require = e(t);
    }
    Module.expectedDataFileDownloads ?? (Module.expectedDataFileDownloads = 0), Module.expectedDataFileDownloads++, (() => {
      var e = typeof ENVIRONMENT_IS_PTHREAD < "u" && ENVIRONMENT_IS_PTHREAD, t = typeof ENVIRONMENT_IS_WASM_WORKER < "u" && ENVIRONMENT_IS_WASM_WORKER;
      if (e || t)
        return;
      var r2 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      function a2(o3) {
        var s4 = "";
        typeof window == "object" ? s4 = window.encodeURIComponent(window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/")) + "/") : typeof process > "u" && typeof location < "u" && (s4 = encodeURIComponent(location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/"));
        var l4 = "/tmp/sdk/dist/pglite-web/pglite.data", _3 = "pglite.data", n3 = Module.locateFile ? Module.locateFile(_3, "") : _3, m4 = o3.remote_package_size;
        function p3(c2, w4, h3, v3) {
          if (r2) {
            require("fs").readFile(c2, (x5, y3) => {
              x5 ? v3(x5) : h3(y3.buffer);
            });
            return;
          }
          Module.dataFileDownloads ?? (Module.dataFileDownloads = {}), fetch(c2).catch((x5) => Promise.reject(new Error(`Network Error: ${c2}`, { cause: x5 }))).then((x5) => {
            if (!x5.ok)
              return Promise.reject(new Error(`${x5.status}: ${x5.url}`));
            if (!x5.body && x5.arrayBuffer)
              return x5.arrayBuffer().then(h3);
            let y3 = x5.body.getReader(), M3 = () => y3.read().then(W3).catch((D4) => Promise.reject(new Error(`Unexpected error while handling : ${x5.url} ${D4}`, { cause: D4 }))), E3 = [], b4 = x5.headers, U3 = Number(b4.get("Content-Length") ?? w4), z3 = 0, W3 = ({ done: D4, value: N2 }) => {
              if (D4) {
                let P4 = new Uint8Array(E3.map((k3) => k3.length).reduce((k3, Le2) => k3 + Le2, 0)), R4 = 0;
                for (let k3 of E3)
                  P4.set(k3, R4), R4 += k3.length;
                h3(P4.buffer);
              } else {
                E3.push(N2), z3 += N2.length, Module.dataFileDownloads[c2] = { loaded: z3, total: U3 };
                let P4 = 0, R4 = 0;
                for (let k3 of Object.values(Module.dataFileDownloads))
                  P4 += k3.loaded, R4 += k3.total;
                return Module.setStatus?.(`Downloading data... (${P4}/${R4})`), M3();
              }
            };
            return Module.setStatus?.("Downloading data..."), M3();
          });
        }
        function d3(c2) {
          console.error("package error:", c2);
        }
        var g5 = null, u3 = Module.getPreloadedPackage ? Module.getPreloadedPackage(n3, m4) : null;
        u3 || p3(n3, m4, (c2) => {
          g5 ? (g5(c2), g5 = null) : u3 = c2;
        }, d3);
        function f3(c2) {
          function w4(M3, E3) {
            if (!M3)
              throw E3 + new Error().stack;
          }
          c2.FS_createPath("/", "home", true, true), c2.FS_createPath("/home", "web_user", true, true), c2.FS_createPath("/", "tmp", true, true), c2.FS_createPath("/tmp", "pglite", true, true), c2.FS_createPath("/tmp/pglite", "bin", true, true), c2.FS_createPath("/tmp/pglite", "lib", true, true), c2.FS_createPath("/tmp/pglite/lib", "postgresql", true, true), c2.FS_createPath("/tmp/pglite/lib/postgresql", "pgxs", true, true), c2.FS_createPath("/tmp/pglite/lib/postgresql/pgxs", "config", true, true), c2.FS_createPath("/tmp/pglite/lib/postgresql/pgxs", "src", true, true), c2.FS_createPath("/tmp/pglite/lib/postgresql/pgxs/src", "makefiles", true, true), c2.FS_createPath("/tmp/pglite", "share", true, true), c2.FS_createPath("/tmp/pglite/share", "postgresql", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql", "extension", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql", "timezone", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Africa", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "America", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Argentina", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Indiana", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Kentucky", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "North_Dakota", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Antarctica", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Arctic", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Asia", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Atlantic", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Australia", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Brazil", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Canada", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Chile", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Etc", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Europe", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Indian", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Mexico", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Pacific", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql/timezone", "US", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql", "timezonesets", true, true), c2.FS_createPath("/tmp/pglite/share/postgresql", "tsearch_data", true, true);
          function h3(M3, E3, b4) {
            this.start = M3, this.end = E3, this.audio = b4;
          }
          h3.prototype = { requests: {}, open: function(M3, E3) {
            this.name = E3, this.requests[E3] = this, c2.addRunDependency(`fp ${this.name}`);
          }, send: function() {}, onload: function() {
            var M3 = this.byteArray.subarray(this.start, this.end);
            this.finish(M3);
          }, finish: function(M3) {
            var E3 = this;
            c2.FS_createDataFile(this.name, null, M3, true, true, true), c2.removeRunDependency(`fp ${E3.name}`), this.requests[this.name] = null;
          } };
          for (var v3 = o3.files, x5 = 0;x5 < v3.length; ++x5)
            new h3(v3[x5].start, v3[x5].end, v3[x5].audio || 0).open("GET", v3[x5].filename);
          function y3(M3) {
            w4(M3, "Loading data file failed."), w4(M3.constructor.name === ArrayBuffer.name, "bad input to processPackageData");
            var E3 = new Uint8Array(M3);
            h3.prototype.byteArray = E3;
            for (var b4 = o3.files, U3 = 0;U3 < b4.length; ++U3)
              h3.prototype.requests[b4[U3].filename].onload();
            c2.removeRunDependency("datafile_/tmp/sdk/dist/pglite-web/pglite.data");
          }
          c2.addRunDependency("datafile_/tmp/sdk/dist/pglite-web/pglite.data"), c2.preloadResults ?? (c2.preloadResults = {}), c2.preloadResults[l4] = { fromCache: false }, u3 ? (y3(u3), u3 = null) : g5 = y3;
        }
        Module.calledRun ? f3(Module) : (Module.preRun ?? (Module.preRun = [])).push(f3);
      }
      a2({ files: [{ filename: "/home/web_user/.pgpass", start: 0, end: 204 }, { filename: "/tmp/pglite/bin/initdb", start: 204, end: 204 }, { filename: "/tmp/pglite/bin/postgres", start: 204, end: 204 }, { filename: "/tmp/pglite/lib/postgresql/cyrillic_and_mic.so", start: 204, end: 4699 }, { filename: "/tmp/pglite/lib/postgresql/dict_snowball.so", start: 4699, end: 576732 }, { filename: "/tmp/pglite/lib/postgresql/euc2004_sjis2004.so", start: 576732, end: 578729 }, { filename: "/tmp/pglite/lib/postgresql/euc_cn_and_mic.so", start: 578729, end: 579667 }, { filename: "/tmp/pglite/lib/postgresql/euc_jp_and_sjis.so", start: 579667, end: 586924 }, { filename: "/tmp/pglite/lib/postgresql/euc_kr_and_mic.so", start: 586924, end: 587876 }, { filename: "/tmp/pglite/lib/postgresql/euc_tw_and_big5.so", start: 587876, end: 592450 }, { filename: "/tmp/pglite/lib/postgresql/latin2_and_win1250.so", start: 592450, end: 593857 }, { filename: "/tmp/pglite/lib/postgresql/latin_and_mic.so", start: 593857, end: 594879 }, { filename: "/tmp/pglite/lib/postgresql/libpqwalreceiver.so", start: 594879, end: 715269 }, { filename: "/tmp/pglite/lib/postgresql/pgoutput.so", start: 715269, end: 728610 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/config/install-sh", start: 728610, end: 742607 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/config/missing", start: 742607, end: 743955 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.global", start: 743955, end: 780212 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.port", start: 780212, end: 780764 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.shlib", start: 780764, end: 796066 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/makefiles/pgxs.mk", start: 796066, end: 810977 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/nls-global.mk", start: 810977, end: 817845 }, { filename: "/tmp/pglite/lib/postgresql/plpgsql.so", start: 817845, end: 967676 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_big5.so", start: 967676, end: 1082425 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_cyrillic.so", start: 1082425, end: 1088400 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc2004.so", start: 1088400, end: 1293333 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_cn.so", start: 1293333, end: 1368514 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_jp.so", start: 1368514, end: 1519743 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_kr.so", start: 1519743, end: 1622600 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_tw.so", start: 1622600, end: 1822157 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_gb18030.so", start: 1822157, end: 2084535 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_gbk.so", start: 2084535, end: 2231068 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_iso8859.so", start: 2231068, end: 2254653 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_iso8859_1.so", start: 2254653, end: 2255623 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_johab.so", start: 2255623, end: 2417328 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_sjis.so", start: 2417328, end: 2498989 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_sjis2004.so", start: 2498989, end: 2625622 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_uhc.so", start: 2625622, end: 2792895 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_win.so", start: 2792895, end: 2819439 }, { filename: "/tmp/pglite/password", start: 2819439, end: 2819448 }, { filename: "/tmp/pglite/share/postgresql/errcodes.txt", start: 2819448, end: 2852840 }, { filename: "/tmp/pglite/share/postgresql/extension/plpgsql--1.0.sql", start: 2852840, end: 2853498 }, { filename: "/tmp/pglite/share/postgresql/extension/plpgsql.control", start: 2853498, end: 2853691 }, { filename: "/tmp/pglite/share/postgresql/information_schema.sql", start: 2853691, end: 2969214 }, { filename: "/tmp/pglite/share/postgresql/pg_hba.conf.sample", start: 2969214, end: 2974839 }, { filename: "/tmp/pglite/share/postgresql/pg_ident.conf.sample", start: 2974839, end: 2977479 }, { filename: "/tmp/pglite/share/postgresql/pg_service.conf.sample", start: 2977479, end: 2978083 }, { filename: "/tmp/pglite/share/postgresql/postgres.bki", start: 2978083, end: 3931351 }, { filename: "/tmp/pglite/share/postgresql/postgresql.conf.sample", start: 3931351, end: 3962013 }, { filename: "/tmp/pglite/share/postgresql/psqlrc.sample", start: 3962013, end: 3962291 }, { filename: "/tmp/pglite/share/postgresql/snowball_create.sql", start: 3962291, end: 4006467 }, { filename: "/tmp/pglite/share/postgresql/sql_features.txt", start: 4006467, end: 4042200 }, { filename: "/tmp/pglite/share/postgresql/system_constraints.sql", start: 4042200, end: 4051095 }, { filename: "/tmp/pglite/share/postgresql/system_functions.sql", start: 4051095, end: 4075398 }, { filename: "/tmp/pglite/share/postgresql/system_views.sql", start: 4075398, end: 4127092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Abidjan", start: 4127092, end: 4127240 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Accra", start: 4127240, end: 4127388 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Addis_Ababa", start: 4127388, end: 4127653 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Algiers", start: 4127653, end: 4128388 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Asmara", start: 4128388, end: 4128653 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Asmera", start: 4128653, end: 4128918 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bamako", start: 4128918, end: 4129066 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bangui", start: 4129066, end: 4129301 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Banjul", start: 4129301, end: 4129449 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bissau", start: 4129449, end: 4129643 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Blantyre", start: 4129643, end: 4129792 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Brazzaville", start: 4129792, end: 4130027 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bujumbura", start: 4130027, end: 4130176 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Cairo", start: 4130176, end: 4132575 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Casablanca", start: 4132575, end: 4135004 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ceuta", start: 4135004, end: 4137056 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Conakry", start: 4137056, end: 4137204 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Dakar", start: 4137204, end: 4137352 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Dar_es_Salaam", start: 4137352, end: 4137617 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Djibouti", start: 4137617, end: 4137882 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Douala", start: 4137882, end: 4138117 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/El_Aaiun", start: 4138117, end: 4140412 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Freetown", start: 4140412, end: 4140560 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Gaborone", start: 4140560, end: 4140709 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Harare", start: 4140709, end: 4140858 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Johannesburg", start: 4140858, end: 4141104 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Juba", start: 4141104, end: 4141783 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kampala", start: 4141783, end: 4142048 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Khartoum", start: 4142048, end: 4142727 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kigali", start: 4142727, end: 4142876 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kinshasa", start: 4142876, end: 4143111 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lagos", start: 4143111, end: 4143346 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Libreville", start: 4143346, end: 4143581 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lome", start: 4143581, end: 4143729 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Luanda", start: 4143729, end: 4143964 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lubumbashi", start: 4143964, end: 4144113 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lusaka", start: 4144113, end: 4144262 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Malabo", start: 4144262, end: 4144497 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Maputo", start: 4144497, end: 4144646 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Maseru", start: 4144646, end: 4144892 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Mbabane", start: 4144892, end: 4145138 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Mogadishu", start: 4145138, end: 4145403 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Monrovia", start: 4145403, end: 4145611 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Nairobi", start: 4145611, end: 4145876 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ndjamena", start: 4145876, end: 4146075 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Niamey", start: 4146075, end: 4146310 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Nouakchott", start: 4146310, end: 4146458 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ouagadougou", start: 4146458, end: 4146606 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Porto-Novo", start: 4146606, end: 4146841 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Sao_Tome", start: 4146841, end: 4147095 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Timbuktu", start: 4147095, end: 4147243 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Tripoli", start: 4147243, end: 4147868 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Tunis", start: 4147868, end: 4148557 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Windhoek", start: 4148557, end: 4149512 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Adak", start: 4149512, end: 4151868 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Anchorage", start: 4151868, end: 4154239 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Anguilla", start: 4154239, end: 4154485 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Antigua", start: 4154485, end: 4154731 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Araguaina", start: 4154731, end: 4155615 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Buenos_Aires", start: 4155615, end: 4156691 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Catamarca", start: 4156691, end: 4157767 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/ComodRivadavia", start: 4157767, end: 4158843 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Cordoba", start: 4158843, end: 4159919 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Jujuy", start: 4159919, end: 4160967 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/La_Rioja", start: 4160967, end: 4162057 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Mendoza", start: 4162057, end: 4163133 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Rio_Gallegos", start: 4163133, end: 4164209 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Salta", start: 4164209, end: 4165257 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Juan", start: 4165257, end: 4166347 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Luis", start: 4166347, end: 4167449 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Tucuman", start: 4167449, end: 4168553 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Ushuaia", start: 4168553, end: 4169629 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Aruba", start: 4169629, end: 4169875 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Asuncion", start: 4169875, end: 4171533 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Atikokan", start: 4171533, end: 4171715 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Atka", start: 4171715, end: 4174071 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bahia", start: 4174071, end: 4175095 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bahia_Banderas", start: 4175095, end: 4176195 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Barbados", start: 4176195, end: 4176631 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Belem", start: 4176631, end: 4177207 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Belize", start: 4177207, end: 4178821 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Blanc-Sablon", start: 4178821, end: 4179067 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Boa_Vista", start: 4179067, end: 4179699 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bogota", start: 4179699, end: 4179945 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Boise", start: 4179945, end: 4182355 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Buenos_Aires", start: 4182355, end: 4183431 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cambridge_Bay", start: 4183431, end: 4185685 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Campo_Grande", start: 4185685, end: 4187129 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cancun", start: 4187129, end: 4187993 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Caracas", start: 4187993, end: 4188257 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Catamarca", start: 4188257, end: 4189333 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cayenne", start: 4189333, end: 4189531 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cayman", start: 4189531, end: 4189713 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Chicago", start: 4189713, end: 4193305 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Chihuahua", start: 4193305, end: 4194407 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ciudad_Juarez", start: 4194407, end: 4195945 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Coral_Harbour", start: 4195945, end: 4196127 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cordoba", start: 4196127, end: 4197203 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Costa_Rica", start: 4197203, end: 4197519 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Creston", start: 4197519, end: 4197879 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cuiaba", start: 4197879, end: 4199295 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Curacao", start: 4199295, end: 4199541 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Danmarkshavn", start: 4199541, end: 4200239 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dawson", start: 4200239, end: 4201853 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dawson_Creek", start: 4201853, end: 4202903 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Denver", start: 4202903, end: 4205363 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Detroit", start: 4205363, end: 4207593 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dominica", start: 4207593, end: 4207839 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Edmonton", start: 4207839, end: 4210171 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Eirunepe", start: 4210171, end: 4210827 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/El_Salvador", start: 4210827, end: 4211051 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ensenada", start: 4211051, end: 4213509 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fort_Nelson", start: 4213509, end: 4215749 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fort_Wayne", start: 4215749, end: 4217431 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fortaleza", start: 4217431, end: 4218147 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Glace_Bay", start: 4218147, end: 4220339 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Godthab", start: 4220339, end: 4222242 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Goose_Bay", start: 4222242, end: 4225452 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Grand_Turk", start: 4225452, end: 4227286 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Grenada", start: 4227286, end: 4227532 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guadeloupe", start: 4227532, end: 4227778 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guatemala", start: 4227778, end: 4228058 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guayaquil", start: 4228058, end: 4228304 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guyana", start: 4228304, end: 4228566 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Halifax", start: 4228566, end: 4231990 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Havana", start: 4231990, end: 4234406 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Hermosillo", start: 4234406, end: 4234794 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Indianapolis", start: 4234794, end: 4236476 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Knox", start: 4236476, end: 4238920 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Marengo", start: 4238920, end: 4240658 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Petersburg", start: 4240658, end: 4242578 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Tell_City", start: 4242578, end: 4244278 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vevay", start: 4244278, end: 4245708 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vincennes", start: 4245708, end: 4247418 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Winamac", start: 4247418, end: 4249212 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indianapolis", start: 4249212, end: 4250894 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Inuvik", start: 4250894, end: 4252968 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Iqaluit", start: 4252968, end: 4255170 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Jamaica", start: 4255170, end: 4255652 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Jujuy", start: 4255652, end: 4256700 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Juneau", start: 4256700, end: 4259053 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Louisville", start: 4259053, end: 4261841 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Monticello", start: 4261841, end: 4264209 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Knox_IN", start: 4264209, end: 4266653 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kralendijk", start: 4266653, end: 4266899 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/La_Paz", start: 4266899, end: 4267131 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Lima", start: 4267131, end: 4267537 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Los_Angeles", start: 4267537, end: 4270389 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Louisville", start: 4270389, end: 4273177 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Lower_Princes", start: 4273177, end: 4273423 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Maceio", start: 4273423, end: 4274167 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Managua", start: 4274167, end: 4274597 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Manaus", start: 4274597, end: 4275201 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Marigot", start: 4275201, end: 4275447 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Martinique", start: 4275447, end: 4275679 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Matamoros", start: 4275679, end: 4277097 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mazatlan", start: 4277097, end: 4278157 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mendoza", start: 4278157, end: 4279233 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Menominee", start: 4279233, end: 4281507 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Merida", start: 4281507, end: 4282511 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Metlakatla", start: 4282511, end: 4283934 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mexico_City", start: 4283934, end: 4285156 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Miquelon", start: 4285156, end: 4286822 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Moncton", start: 4286822, end: 4289976 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Monterrey", start: 4289976, end: 4291090 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montevideo", start: 4291090, end: 4292600 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montreal", start: 4292600, end: 4296094 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montserrat", start: 4296094, end: 4296340 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nassau", start: 4296340, end: 4299834 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/New_York", start: 4299834, end: 4303386 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nipigon", start: 4303386, end: 4306880 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nome", start: 4306880, end: 4309247 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Noronha", start: 4309247, end: 4309963 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Beulah", start: 4309963, end: 4312359 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Center", start: 4312359, end: 4314755 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/New_Salem", start: 4314755, end: 4317151 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nuuk", start: 4317151, end: 4319054 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ojinaga", start: 4319054, end: 4320578 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Panama", start: 4320578, end: 4320760 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Pangnirtung", start: 4320760, end: 4322962 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Paramaribo", start: 4322962, end: 4323224 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Phoenix", start: 4323224, end: 4323584 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Port-au-Prince", start: 4323584, end: 4325018 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Port_of_Spain", start: 4325018, end: 4325264 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Porto_Acre", start: 4325264, end: 4325892 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Porto_Velho", start: 4325892, end: 4326468 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Puerto_Rico", start: 4326468, end: 4326714 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Punta_Arenas", start: 4326714, end: 4328630 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rainy_River", start: 4328630, end: 4331498 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rankin_Inlet", start: 4331498, end: 4333564 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Recife", start: 4333564, end: 4334280 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Regina", start: 4334280, end: 4335260 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Resolute", start: 4335260, end: 4337326 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rio_Branco", start: 4337326, end: 4337954 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rosario", start: 4337954, end: 4339030 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santa_Isabel", start: 4339030, end: 4341488 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santarem", start: 4341488, end: 4342090 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santiago", start: 4342090, end: 4344619 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santo_Domingo", start: 4344619, end: 4345077 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Sao_Paulo", start: 4345077, end: 4346521 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Scoresbysund", start: 4346521, end: 4348470 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Shiprock", start: 4348470, end: 4350930 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Sitka", start: 4350930, end: 4353259 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Barthelemy", start: 4353259, end: 4353505 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Johns", start: 4353505, end: 4357160 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Kitts", start: 4357160, end: 4357406 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Lucia", start: 4357406, end: 4357652 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Thomas", start: 4357652, end: 4357898 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Vincent", start: 4357898, end: 4358144 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Swift_Current", start: 4358144, end: 4358704 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tegucigalpa", start: 4358704, end: 4358956 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Thule", start: 4358956, end: 4360458 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Thunder_Bay", start: 4360458, end: 4363952 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tijuana", start: 4363952, end: 4366410 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Toronto", start: 4366410, end: 4369904 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tortola", start: 4369904, end: 4370150 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Vancouver", start: 4370150, end: 4373042 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Virgin", start: 4373042, end: 4373288 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Whitehorse", start: 4373288, end: 4374902 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Winnipeg", start: 4374902, end: 4377770 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Yakutat", start: 4377770, end: 4380075 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Yellowknife", start: 4380075, end: 4382407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Casey", start: 4382407, end: 4382844 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Davis", start: 4382844, end: 4383141 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/DumontDUrville", start: 4383141, end: 4383327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Macquarie", start: 4383327, end: 4385587 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Mawson", start: 4385587, end: 4385786 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/McMurdo", start: 4385786, end: 4388223 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Palmer", start: 4388223, end: 4389641 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Rothera", start: 4389641, end: 4389805 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/South_Pole", start: 4389805, end: 4392242 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Syowa", start: 4392242, end: 4392407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Troll", start: 4392407, end: 4393569 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Vostok", start: 4393569, end: 4393796 }, { filename: "/tmp/pglite/share/postgresql/timezone/Arctic/Longyearbyen", start: 4393796, end: 4396094 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aden", start: 4396094, end: 4396259 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Almaty", start: 4396259, end: 4397256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Amman", start: 4397256, end: 4398703 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Anadyr", start: 4398703, end: 4399891 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aqtau", start: 4399891, end: 4400874 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aqtobe", start: 4400874, end: 4401885 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ashgabat", start: 4401885, end: 4402504 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ashkhabad", start: 4402504, end: 4403123 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Atyrau", start: 4403123, end: 4404114 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Baghdad", start: 4404114, end: 4405097 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bahrain", start: 4405097, end: 4405296 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Baku", start: 4405296, end: 4406523 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bangkok", start: 4406523, end: 4406722 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Barnaul", start: 4406722, end: 4407943 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Beirut", start: 4407943, end: 4410097 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bishkek", start: 4410097, end: 4411080 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Brunei", start: 4411080, end: 4411563 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Calcutta", start: 4411563, end: 4411848 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chita", start: 4411848, end: 4413069 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Choibalsan", start: 4413069, end: 4413960 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chongqing", start: 4413960, end: 4414521 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chungking", start: 4414521, end: 4415082 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Colombo", start: 4415082, end: 4415454 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dacca", start: 4415454, end: 4415791 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Damascus", start: 4415791, end: 4417678 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dhaka", start: 4417678, end: 4418015 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dili", start: 4418015, end: 4418286 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dubai", start: 4418286, end: 4418451 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dushanbe", start: 4418451, end: 4419042 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Famagusta", start: 4419042, end: 4421070 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Gaza", start: 4421070, end: 4424914 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Harbin", start: 4424914, end: 4425475 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hebron", start: 4425475, end: 4429347 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ho_Chi_Minh", start: 4429347, end: 4429698 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hong_Kong", start: 4429698, end: 4430931 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hovd", start: 4430931, end: 4431822 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Irkutsk", start: 4431822, end: 4433065 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Istanbul", start: 4433065, end: 4435012 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jakarta", start: 4435012, end: 4435395 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jayapura", start: 4435395, end: 4435616 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jerusalem", start: 4435616, end: 4438004 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kabul", start: 4438004, end: 4438212 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kamchatka", start: 4438212, end: 4439378 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Karachi", start: 4439378, end: 4439757 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kashgar", start: 4439757, end: 4439922 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kathmandu", start: 4439922, end: 4440134 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Katmandu", start: 4440134, end: 4440346 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Khandyga", start: 4440346, end: 4441617 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kolkata", start: 4441617, end: 4441902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Krasnoyarsk", start: 4441902, end: 4443109 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuala_Lumpur", start: 4443109, end: 4443524 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuching", start: 4443524, end: 4444007 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuwait", start: 4444007, end: 4444172 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Macao", start: 4444172, end: 4445399 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Macau", start: 4445399, end: 4446626 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Magadan", start: 4446626, end: 4447848 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Makassar", start: 4447848, end: 4448102 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Manila", start: 4448102, end: 4448524 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Muscat", start: 4448524, end: 4448689 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Nicosia", start: 4448689, end: 4450691 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Novokuznetsk", start: 4450691, end: 4451856 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Novosibirsk", start: 4451856, end: 4453077 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Omsk", start: 4453077, end: 4454284 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Oral", start: 4454284, end: 4455289 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Phnom_Penh", start: 4455289, end: 4455488 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Pontianak", start: 4455488, end: 4455841 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Pyongyang", start: 4455841, end: 4456078 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qatar", start: 4456078, end: 4456277 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qostanay", start: 4456277, end: 4457316 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qyzylorda", start: 4457316, end: 4458341 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Rangoon", start: 4458341, end: 4458609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Riyadh", start: 4458609, end: 4458774 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Saigon", start: 4458774, end: 4459125 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Sakhalin", start: 4459125, end: 4460327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Samarkand", start: 4460327, end: 4460904 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Seoul", start: 4460904, end: 4461521 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Shanghai", start: 4461521, end: 4462082 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Singapore", start: 4462082, end: 4462497 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Srednekolymsk", start: 4462497, end: 4463705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Taipei", start: 4463705, end: 4464466 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tashkent", start: 4464466, end: 4465057 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tbilisi", start: 4465057, end: 4466092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tehran", start: 4466092, end: 4467354 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tel_Aviv", start: 4467354, end: 4469742 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Thimbu", start: 4469742, end: 4469945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Thimphu", start: 4469945, end: 4470148 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tokyo", start: 4470148, end: 4470457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tomsk", start: 4470457, end: 4471678 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ujung_Pandang", start: 4471678, end: 4471932 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ulaanbaatar", start: 4471932, end: 4472823 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ulan_Bator", start: 4472823, end: 4473714 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Urumqi", start: 4473714, end: 4473879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ust-Nera", start: 4473879, end: 4475131 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Vientiane", start: 4475131, end: 4475330 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Vladivostok", start: 4475330, end: 4476538 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yakutsk", start: 4476538, end: 4477745 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yangon", start: 4477745, end: 4478013 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yekaterinburg", start: 4478013, end: 4479256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yerevan", start: 4479256, end: 4480407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Azores", start: 4480407, end: 4483863 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Bermuda", start: 4483863, end: 4486259 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Canary", start: 4486259, end: 4488156 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Cape_Verde", start: 4488156, end: 4488426 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Faeroe", start: 4488426, end: 4490241 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Faroe", start: 4490241, end: 4492056 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Jan_Mayen", start: 4492056, end: 4494354 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Madeira", start: 4494354, end: 4497731 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Reykjavik", start: 4497731, end: 4497879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/South_Georgia", start: 4497879, end: 4498043 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/St_Helena", start: 4498043, end: 4498191 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Stanley", start: 4498191, end: 4499405 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/ACT", start: 4499405, end: 4501595 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Adelaide", start: 4501595, end: 4503803 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Brisbane", start: 4503803, end: 4504222 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Broken_Hill", start: 4504222, end: 4506451 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Canberra", start: 4506451, end: 4508641 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Currie", start: 4508641, end: 4510999 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Darwin", start: 4510999, end: 4511324 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Eucla", start: 4511324, end: 4511794 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Hobart", start: 4511794, end: 4514152 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/LHI", start: 4514152, end: 4516012 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Lindeman", start: 4516012, end: 4516487 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Lord_Howe", start: 4516487, end: 4518347 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Melbourne", start: 4518347, end: 4520537 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/NSW", start: 4520537, end: 4522727 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/North", start: 4522727, end: 4523052 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Perth", start: 4523052, end: 4523498 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Queensland", start: 4523498, end: 4523917 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/South", start: 4523917, end: 4526125 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Sydney", start: 4526125, end: 4528315 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Tasmania", start: 4528315, end: 4530673 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Victoria", start: 4530673, end: 4532863 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/West", start: 4532863, end: 4533309 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Yancowinna", start: 4533309, end: 4535538 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/Acre", start: 4535538, end: 4536166 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/DeNoronha", start: 4536166, end: 4536882 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/East", start: 4536882, end: 4538326 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/West", start: 4538326, end: 4538930 }, { filename: "/tmp/pglite/share/postgresql/timezone/CET", start: 4538930, end: 4541863 }, { filename: "/tmp/pglite/share/postgresql/timezone/CST6CDT", start: 4541863, end: 4545455 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Atlantic", start: 4545455, end: 4548879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Central", start: 4548879, end: 4551747 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Eastern", start: 4551747, end: 4555241 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Mountain", start: 4555241, end: 4557573 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Newfoundland", start: 4557573, end: 4561228 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Pacific", start: 4561228, end: 4564120 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Saskatchewan", start: 4564120, end: 4565100 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Yukon", start: 4565100, end: 4566714 }, { filename: "/tmp/pglite/share/postgresql/timezone/Chile/Continental", start: 4566714, end: 4569243 }, { filename: "/tmp/pglite/share/postgresql/timezone/Chile/EasterIsland", start: 4569243, end: 4571476 }, { filename: "/tmp/pglite/share/postgresql/timezone/Cuba", start: 4571476, end: 4573892 }, { filename: "/tmp/pglite/share/postgresql/timezone/EET", start: 4573892, end: 4576154 }, { filename: "/tmp/pglite/share/postgresql/timezone/EST", start: 4576154, end: 4576336 }, { filename: "/tmp/pglite/share/postgresql/timezone/EST5EDT", start: 4576336, end: 4579888 }, { filename: "/tmp/pglite/share/postgresql/timezone/Egypt", start: 4579888, end: 4582287 }, { filename: "/tmp/pglite/share/postgresql/timezone/Eire", start: 4582287, end: 4585779 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT", start: 4585779, end: 4585893 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+0", start: 4585893, end: 4586007 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+1", start: 4586007, end: 4586123 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+10", start: 4586123, end: 4586240 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+11", start: 4586240, end: 4586357 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+12", start: 4586357, end: 4586474 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+2", start: 4586474, end: 4586590 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+3", start: 4586590, end: 4586706 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+4", start: 4586706, end: 4586822 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+5", start: 4586822, end: 4586938 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+6", start: 4586938, end: 4587054 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+7", start: 4587054, end: 4587170 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+8", start: 4587170, end: 4587286 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+9", start: 4587286, end: 4587402 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-0", start: 4587402, end: 4587516 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-1", start: 4587516, end: 4587633 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-10", start: 4587633, end: 4587751 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-11", start: 4587751, end: 4587869 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-12", start: 4587869, end: 4587987 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-13", start: 4587987, end: 4588105 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-14", start: 4588105, end: 4588223 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-2", start: 4588223, end: 4588340 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-3", start: 4588340, end: 4588457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-4", start: 4588457, end: 4588574 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-5", start: 4588574, end: 4588691 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-6", start: 4588691, end: 4588808 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-7", start: 4588808, end: 4588925 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-8", start: 4588925, end: 4589042 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-9", start: 4589042, end: 4589159 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT0", start: 4589159, end: 4589273 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Greenwich", start: 4589273, end: 4589387 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/UCT", start: 4589387, end: 4589501 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/UTC", start: 4589501, end: 4589615 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Universal", start: 4589615, end: 4589729 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Zulu", start: 4589729, end: 4589843 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Amsterdam", start: 4589843, end: 4592776 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Andorra", start: 4592776, end: 4594518 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Astrakhan", start: 4594518, end: 4595683 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Athens", start: 4595683, end: 4597945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Belfast", start: 4597945, end: 4601609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Belgrade", start: 4601609, end: 4603529 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Berlin", start: 4603529, end: 4605827 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Bratislava", start: 4605827, end: 4608128 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Brussels", start: 4608128, end: 4611061 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Bucharest", start: 4611061, end: 4613245 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Budapest", start: 4613245, end: 4615613 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Busingen", start: 4615613, end: 4617522 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Chisinau", start: 4617522, end: 4619912 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Copenhagen", start: 4619912, end: 4622210 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Dublin", start: 4622210, end: 4625702 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Gibraltar", start: 4625702, end: 4628770 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Guernsey", start: 4628770, end: 4632434 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Helsinki", start: 4632434, end: 4634334 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Isle_of_Man", start: 4634334, end: 4637998 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Istanbul", start: 4637998, end: 4639945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Jersey", start: 4639945, end: 4643609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kaliningrad", start: 4643609, end: 4645102 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kiev", start: 4645102, end: 4647222 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kirov", start: 4647222, end: 4648407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kyiv", start: 4648407, end: 4650527 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Lisbon", start: 4650527, end: 4654054 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Ljubljana", start: 4654054, end: 4655974 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/London", start: 4655974, end: 4659638 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Luxembourg", start: 4659638, end: 4662571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Madrid", start: 4662571, end: 4665185 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Malta", start: 4665185, end: 4667805 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Mariehamn", start: 4667805, end: 4669705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Minsk", start: 4669705, end: 4671026 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Monaco", start: 4671026, end: 4673988 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Moscow", start: 4673988, end: 4675523 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Nicosia", start: 4675523, end: 4677525 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Oslo", start: 4677525, end: 4679823 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Paris", start: 4679823, end: 4682785 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Podgorica", start: 4682785, end: 4684705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Prague", start: 4684705, end: 4687006 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Riga", start: 4687006, end: 4689204 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Rome", start: 4689204, end: 4691845 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Samara", start: 4691845, end: 4693060 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/San_Marino", start: 4693060, end: 4695701 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Sarajevo", start: 4695701, end: 4697621 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Saratov", start: 4697621, end: 4698804 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Simferopol", start: 4698804, end: 4700273 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Skopje", start: 4700273, end: 4702193 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Sofia", start: 4702193, end: 4704270 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Stockholm", start: 4704270, end: 4706568 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tallinn", start: 4706568, end: 4708716 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tirane", start: 4708716, end: 4710800 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tiraspol", start: 4710800, end: 4713190 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Ulyanovsk", start: 4713190, end: 4714457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Uzhgorod", start: 4714457, end: 4716577 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vaduz", start: 4716577, end: 4718486 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vatican", start: 4718486, end: 4721127 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vienna", start: 4721127, end: 4723327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vilnius", start: 4723327, end: 4725489 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Volgograd", start: 4725489, end: 4726682 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Warsaw", start: 4726682, end: 4729336 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zagreb", start: 4729336, end: 4731256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zaporozhye", start: 4731256, end: 4733376 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zurich", start: 4733376, end: 4735285 }, { filename: "/tmp/pglite/share/postgresql/timezone/Factory", start: 4735285, end: 4735401 }, { filename: "/tmp/pglite/share/postgresql/timezone/GB", start: 4735401, end: 4739065 }, { filename: "/tmp/pglite/share/postgresql/timezone/GB-Eire", start: 4739065, end: 4742729 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT", start: 4742729, end: 4742843 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT+0", start: 4742843, end: 4742957 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT-0", start: 4742957, end: 4743071 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT0", start: 4743071, end: 4743185 }, { filename: "/tmp/pglite/share/postgresql/timezone/Greenwich", start: 4743185, end: 4743299 }, { filename: "/tmp/pglite/share/postgresql/timezone/HST", start: 4743299, end: 4743628 }, { filename: "/tmp/pglite/share/postgresql/timezone/Hongkong", start: 4743628, end: 4744861 }, { filename: "/tmp/pglite/share/postgresql/timezone/Iceland", start: 4744861, end: 4745009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Antananarivo", start: 4745009, end: 4745274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Chagos", start: 4745274, end: 4745473 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Christmas", start: 4745473, end: 4745672 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Cocos", start: 4745672, end: 4745940 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Comoro", start: 4745940, end: 4746205 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Kerguelen", start: 4746205, end: 4746404 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mahe", start: 4746404, end: 4746569 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Maldives", start: 4746569, end: 4746768 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mauritius", start: 4746768, end: 4747009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mayotte", start: 4747009, end: 4747274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Reunion", start: 4747274, end: 4747439 }, { filename: "/tmp/pglite/share/postgresql/timezone/Iran", start: 4747439, end: 4748701 }, { filename: "/tmp/pglite/share/postgresql/timezone/Israel", start: 4748701, end: 4751089 }, { filename: "/tmp/pglite/share/postgresql/timezone/Jamaica", start: 4751089, end: 4751571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Japan", start: 4751571, end: 4751880 }, { filename: "/tmp/pglite/share/postgresql/timezone/Kwajalein", start: 4751880, end: 4752196 }, { filename: "/tmp/pglite/share/postgresql/timezone/Libya", start: 4752196, end: 4752821 }, { filename: "/tmp/pglite/share/postgresql/timezone/MET", start: 4752821, end: 4755754 }, { filename: "/tmp/pglite/share/postgresql/timezone/MST", start: 4755754, end: 4756114 }, { filename: "/tmp/pglite/share/postgresql/timezone/MST7MDT", start: 4756114, end: 4758574 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/BajaNorte", start: 4758574, end: 4761032 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/BajaSur", start: 4761032, end: 4762092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/General", start: 4762092, end: 4763314 }, { filename: "/tmp/pglite/share/postgresql/timezone/NZ", start: 4763314, end: 4765751 }, { filename: "/tmp/pglite/share/postgresql/timezone/NZ-CHAT", start: 4765751, end: 4767819 }, { filename: "/tmp/pglite/share/postgresql/timezone/Navajo", start: 4767819, end: 4770279 }, { filename: "/tmp/pglite/share/postgresql/timezone/PRC", start: 4770279, end: 4770840 }, { filename: "/tmp/pglite/share/postgresql/timezone/PST8PDT", start: 4770840, end: 4773692 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Apia", start: 4773692, end: 4774304 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Auckland", start: 4774304, end: 4776741 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Bougainville", start: 4776741, end: 4777009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Chatham", start: 4777009, end: 4779077 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Chuuk", start: 4779077, end: 4779263 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Easter", start: 4779263, end: 4781496 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Efate", start: 4781496, end: 4782034 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Enderbury", start: 4782034, end: 4782268 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Fakaofo", start: 4782268, end: 4782468 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Fiji", start: 4782468, end: 4783046 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Funafuti", start: 4783046, end: 4783212 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Galapagos", start: 4783212, end: 4783450 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Gambier", start: 4783450, end: 4783614 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Guadalcanal", start: 4783614, end: 4783780 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Guam", start: 4783780, end: 4784274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Honolulu", start: 4784274, end: 4784603 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Johnston", start: 4784603, end: 4784932 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kanton", start: 4784932, end: 4785166 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kiritimati", start: 4785166, end: 4785404 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kosrae", start: 4785404, end: 4785755 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kwajalein", start: 4785755, end: 4786071 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Majuro", start: 4786071, end: 4786237 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Marquesas", start: 4786237, end: 4786410 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Midway", start: 4786410, end: 4786585 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Nauru", start: 4786585, end: 4786837 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Niue", start: 4786837, end: 4787040 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Norfolk", start: 4787040, end: 4787920 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Noumea", start: 4787920, end: 4788224 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pago_Pago", start: 4788224, end: 4788399 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Palau", start: 4788399, end: 4788579 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pitcairn", start: 4788579, end: 4788781 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pohnpei", start: 4788781, end: 4788947 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Ponape", start: 4788947, end: 4789113 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Port_Moresby", start: 4789113, end: 4789299 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Rarotonga", start: 4789299, end: 4789902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Saipan", start: 4789902, end: 4790396 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Samoa", start: 4790396, end: 4790571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tahiti", start: 4790571, end: 4790736 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tarawa", start: 4790736, end: 4790902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tongatapu", start: 4790902, end: 4791274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Truk", start: 4791274, end: 4791460 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Wake", start: 4791460, end: 4791626 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Wallis", start: 4791626, end: 4791792 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Yap", start: 4791792, end: 4791978 }, { filename: "/tmp/pglite/share/postgresql/timezone/Poland", start: 4791978, end: 4794632 }, { filename: "/tmp/pglite/share/postgresql/timezone/Portugal", start: 4794632, end: 4798159 }, { filename: "/tmp/pglite/share/postgresql/timezone/ROC", start: 4798159, end: 4798920 }, { filename: "/tmp/pglite/share/postgresql/timezone/ROK", start: 4798920, end: 4799537 }, { filename: "/tmp/pglite/share/postgresql/timezone/Singapore", start: 4799537, end: 4799952 }, { filename: "/tmp/pglite/share/postgresql/timezone/Turkey", start: 4799952, end: 4801899 }, { filename: "/tmp/pglite/share/postgresql/timezone/UCT", start: 4801899, end: 4802013 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Alaska", start: 4802013, end: 4804384 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Aleutian", start: 4804384, end: 4806740 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Arizona", start: 4806740, end: 4807100 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Central", start: 4807100, end: 4810692 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/East-Indiana", start: 4810692, end: 4812374 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Eastern", start: 4812374, end: 4815926 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Hawaii", start: 4815926, end: 4816255 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Indiana-Starke", start: 4816255, end: 4818699 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Michigan", start: 4818699, end: 4820929 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Mountain", start: 4820929, end: 4823389 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Pacific", start: 4823389, end: 4826241 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Samoa", start: 4826241, end: 4826416 }, { filename: "/tmp/pglite/share/postgresql/timezone/UTC", start: 4826416, end: 4826530 }, { filename: "/tmp/pglite/share/postgresql/timezone/Universal", start: 4826530, end: 4826644 }, { filename: "/tmp/pglite/share/postgresql/timezone/W-SU", start: 4826644, end: 4828179 }, { filename: "/tmp/pglite/share/postgresql/timezone/WET", start: 4828179, end: 4831706 }, { filename: "/tmp/pglite/share/postgresql/timezone/Zulu", start: 4831706, end: 4831820 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Africa.txt", start: 4831820, end: 4838793 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/America.txt", start: 4838793, end: 4849800 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Antarctica.txt", start: 4849800, end: 4850934 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Asia.txt", start: 4850934, end: 4859245 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Atlantic.txt", start: 4859245, end: 4862778 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Australia", start: 4862778, end: 4863913 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Australia.txt", start: 4863913, end: 4867297 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Default", start: 4867297, end: 4894511 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Etc.txt", start: 4894511, end: 4895761 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Europe.txt", start: 4895761, end: 4904507 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/India", start: 4904507, end: 4905100 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Indian.txt", start: 4905100, end: 4906361 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Pacific.txt", start: 4906361, end: 4910129 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/danish.stop", start: 4910129, end: 4910553 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/dutch.stop", start: 4910553, end: 4911006 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/english.stop", start: 4911006, end: 4911628 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/finnish.stop", start: 4911628, end: 4913207 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/french.stop", start: 4913207, end: 4914012 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/german.stop", start: 4914012, end: 4915361 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hungarian.stop", start: 4915361, end: 4916588 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample.affix", start: 4916588, end: 4916831 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.affix", start: 4916831, end: 4917464 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.dict", start: 4917464, end: 4917562 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.affix", start: 4917562, end: 4918024 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.dict", start: 4918024, end: 4918153 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.affix", start: 4918153, end: 4918618 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.dict", start: 4918618, end: 4918699 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/italian.stop", start: 4918699, end: 4920353 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/nepali.stop", start: 4920353, end: 4924614 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/norwegian.stop", start: 4924614, end: 4925465 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/portuguese.stop", start: 4925465, end: 4926732 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/russian.stop", start: 4926732, end: 4927967 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/spanish.stop", start: 4927967, end: 4930145 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/swedish.stop", start: 4930145, end: 4930704 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/synonym_sample.syn", start: 4930704, end: 4930777 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/thesaurus_sample.ths", start: 4930777, end: 4931250 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/turkish.stop", start: 4931250, end: 4931510 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/unaccent.rules", start: 4931510, end: 4941513 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/xsyn_sample.rules", start: 4941513, end: 4941652 }], remote_package_size: 4941652 });
    })();
    var moduleOverrides = Object.assign({}, Module), arguments_ = [], thisProgram = "./this.program", quit_ = (e, t) => {
      throw t;
    }, scriptDirectory = "";
    function locateFile(e) {
      return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
    }
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs"), nodePath = require("path");
      import.meta.url.startsWith("data:") || (scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import.meta.url)) + "/"), readBinary = (e) => {
        e = isFileURI(e) ? new URL(e) : e;
        var t = fs.readFileSync(e);
        return t;
      }, readAsync = async (e, t = true) => {
        e = isFileURI(e) ? new URL(e) : e;
        var r2 = fs.readFileSync(e, t ? undefined : "utf8");
        return r2;
      }, !Module.thisProgram && process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), quit_ = (e, t) => {
        throw process.exitCode = e, t;
      };
    } else
      (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : typeof document < "u" && document.currentScript && (scriptDirectory = document.currentScript.src), _scriptName && (scriptDirectory = _scriptName), scriptDirectory.startsWith("blob:") ? scriptDirectory = "" : scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1), readAsync = async (e) => {
        var t = await fetch(e, { credentials: "same-origin" });
        if (t.ok)
          return t.arrayBuffer();
        throw new Error(t.status + " : " + t.url);
      });
    var out = Module.print || console.log.bind(console), err = Module.printErr || console.error.bind(console);
    Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram);
    var dynamicLibraries = Module.dynamicLibraries || [], wasmBinary = Module.wasmBinary, wasmMemory, ABORT = false, EXITSTATUS;
    function assert(e, t) {
      e || abort(t);
    }
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var e = wasmMemory.buffer;
      Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e), Module.HEAP64 = HEAP64 = new BigInt64Array(e), Module.HEAPU64 = HEAPU64 = new BigUint64Array(e);
    }
    if (Module.wasmMemory)
      wasmMemory = Module.wasmMemory;
    else {
      var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;
      wasmMemory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / 65536, maximum: 32768 });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [], __ATINIT__ = [], __ATMAIN__ = [], __ATPOSTRUN__ = [], __RELOC_FUNCS__ = [], runtimeInitialized = false;
    function preRun() {
      if (Module.preRun)
        for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]);Module.preRun.length; )
          addOnPreRun(Module.preRun.shift());
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true, callRuntimeCallbacks(__RELOC_FUNCS__), !Module.noFSInit && !FS.initialized && FS.init(), FS.ignorePermissions = false, TTY.init(), SOCKFS.root = FS.mount(SOCKFS, {}, null), PIPEFS.root = FS.mount(PIPEFS, {}, null), callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }
    function postRun() {
      if (Module.postRun)
        for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]);Module.postRun.length; )
          addOnPostRun(Module.postRun.shift());
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(e) {
      __ATPRERUN__.unshift(e);
    }
    function addOnInit(e) {
      __ATINIT__.unshift(e);
    }
    function addOnPostRun(e) {
      __ATPOSTRUN__.unshift(e);
    }
    var runDependencies = 0, dependenciesFulfilled = null;
    function getUniqueRunDependency(e) {
      return e;
    }
    function addRunDependency(e) {
      runDependencies++, Module.monitorRunDependencies?.(runDependencies);
    }
    function removeRunDependency(e) {
      if (runDependencies--, Module.monitorRunDependencies?.(runDependencies), runDependencies == 0 && dependenciesFulfilled) {
        var t = dependenciesFulfilled;
        dependenciesFulfilled = null, t();
      }
    }
    function abort(e) {
      Module.onAbort?.(e), e = "Aborted(" + e + ")", err(e), ABORT = true, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw readyPromiseReject(t), t;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,", isDataURI = (e) => e.startsWith(dataURIPrefix), isFileURI = (e) => e.startsWith("file://");
    function findWasmBinary() {
      if (Module.locateFile) {
        var e = "pglite.wasm";
        return isDataURI(e) ? e : locateFile(e);
      }
      return new URL("pglite.wasm", import.meta.url).href;
    }
    var wasmBinaryFile;
    function getBinarySync(e) {
      if (e == wasmBinaryFile && wasmBinary)
        return new Uint8Array(wasmBinary);
      if (readBinary)
        return readBinary(e);
      throw "both async and sync fetching of the wasm failed";
    }
    async function getWasmBinary(e) {
      if (!wasmBinary)
        try {
          var t = await readAsync(e);
          return new Uint8Array(t);
        } catch {}
      return getBinarySync(e);
    }
    async function instantiateArrayBuffer(e, t) {
      try {
        var r2 = await getWasmBinary(e), a2 = await WebAssembly.instantiate(r2, t);
        return a2;
      } catch (o3) {
        err(`failed to asynchronously prepare wasm: ${o3}`), abort(o3);
      }
    }
    async function instantiateAsync(e, t, r2) {
      if (!e && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(t) && !ENVIRONMENT_IS_NODE && typeof fetch == "function")
        try {
          var a2 = fetch(t, { credentials: "same-origin" }), o3 = await WebAssembly.instantiateStreaming(a2, r2);
          return o3;
        } catch (s4) {
          err(`wasm streaming compile failed: ${s4}`), err("falling back to ArrayBuffer instantiation");
        }
      return instantiateArrayBuffer(t, r2);
    }
    function getWasmImports() {
      return { env: wasmImports, wasi_snapshot_preview1: wasmImports, "GOT.mem": new Proxy(wasmImports, GOTHandler), "GOT.func": new Proxy(wasmImports, GOTHandler) };
    }
    async function createWasm() {
      function e(o3, s4) {
        wasmExports = o3.exports, wasmExports = relocateExports(wasmExports, 12582912);
        var l4 = getDylinkMetadata(s4);
        return l4.neededDynlibs && (dynamicLibraries = l4.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(wasmExports, "main"), LDSO.init(), loadDylibs(), addOnInit(wasmExports.__wasm_call_ctors), __RELOC_FUNCS__.push(wasmExports.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate"), wasmExports;
      }
      addRunDependency("wasm-instantiate");
      function t(o3) {
        e(o3.instance, o3.module);
      }
      var r2 = getWasmImports();
      if (Module.instantiateWasm)
        try {
          return Module.instantiateWasm(r2, e);
        } catch (o3) {
          err(`Module.instantiateWasm callback failed with error: ${o3}`), readyPromiseReject(o3);
        }
      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
      try {
        var a2 = await instantiateAsync(wasmBinary, wasmBinaryFile, r2);
        return t(a2), a2;
      } catch (o3) {
        readyPromiseReject(o3);
        return;
      }
    }
    var ASM_CONSTS = { 15161036: (e) => {
      Module.is_worker = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, Module.FD_BUFFER_MAX = e, Module.emscripten_copy_to = console.warn;
    }, 15161208: () => {
      Module.postMessage = function(t) {
        console.log("# pg_main_emsdk.c:544: onCustomMessage:", t);
      };
    }, 15161337: () => {
      if (Module.is_worker) {
        let t = function(r2) {
          console.log("onCustomMessage:", r2);
        };
        var e = t;
        Module.onCustomMessage = t;
      } else
        Module.postMessage = function(r2) {
          switch (r2.type) {
            case "raw":
              break;
            case "stdin": {
              stringToUTF8(r2.data, 1, Module.FD_BUFFER_MAX);
              break;
            }
            case "rcon":
              break;
            default:
              console.warn("custom_postMessage?", r2);
          }
        };
    } };

    class ExitStatus {
      constructor(t) {
        P(this, "name", "ExitStatus");
        this.message = `Program terminated with exit(${t})`, this.status = t;
      }
    }
    var GOT = {}, currentModuleWeakSymbols = new Set([]), GOTHandler = { get(e, t) {
      var r2 = GOT[t];
      return r2 || (r2 = GOT[t] = new WebAssembly.Global({ value: "i32", mutable: true })), currentModuleWeakSymbols.has(t) || (r2.required = true), r2;
    } }, callRuntimeCallbacks = (e) => {
      for (;e.length > 0; )
        e.shift()(Module);
    }, UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder : undefined, UTF8ArrayToString = (e, t = 0, r2 = NaN) => {
      for (var a2 = t + r2, o3 = t;e[o3] && !(o3 >= a2); )
        ++o3;
      if (o3 - t > 16 && e.buffer && UTF8Decoder)
        return UTF8Decoder.decode(e.subarray(t, o3));
      for (var s4 = "";t < o3; ) {
        var l4 = e[t++];
        if (!(l4 & 128)) {
          s4 += String.fromCharCode(l4);
          continue;
        }
        var _3 = e[t++] & 63;
        if ((l4 & 224) == 192) {
          s4 += String.fromCharCode((l4 & 31) << 6 | _3);
          continue;
        }
        var n3 = e[t++] & 63;
        if ((l4 & 240) == 224 ? l4 = (l4 & 15) << 12 | _3 << 6 | n3 : l4 = (l4 & 7) << 18 | _3 << 12 | n3 << 6 | e[t++] & 63, l4 < 65536)
          s4 += String.fromCharCode(l4);
        else {
          var m4 = l4 - 65536;
          s4 += String.fromCharCode(55296 | m4 >> 10, 56320 | m4 & 1023);
        }
      }
      return s4;
    }, getDylinkMetadata = (e) => {
      var t = 0, r2 = 0;
      function a2() {
        return e[t++];
      }
      function o3() {
        for (var P4 = 0, R4 = 1;; ) {
          var k3 = e[t++];
          if (P4 += (k3 & 127) * R4, R4 *= 128, !(k3 & 128))
            break;
        }
        return P4;
      }
      function s4() {
        var P4 = o3();
        return t += P4, UTF8ArrayToString(e, t - P4, P4);
      }
      function l4(P4, R4) {
        if (P4)
          throw new Error(R4);
      }
      var _3 = "dylink.0";
      if (e instanceof WebAssembly.Module) {
        var n3 = WebAssembly.Module.customSections(e, _3);
        n3.length === 0 && (_3 = "dylink", n3 = WebAssembly.Module.customSections(e, _3)), l4(n3.length === 0, "need dylink section"), e = new Uint8Array(n3[0]), r2 = e.length;
      } else {
        var m4 = new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer), p3 = m4[0] == 1836278016;
        l4(!p3, "need to see wasm magic number"), l4(e[8] !== 0, "need the dylink section to be first"), t = 9;
        var d3 = o3();
        r2 = t + d3, _3 = s4();
      }
      var g5 = { neededDynlibs: [], tlsExports: new Set, weakImports: new Set };
      if (_3 == "dylink") {
        g5.memorySize = o3(), g5.memoryAlign = o3(), g5.tableSize = o3(), g5.tableAlign = o3();
        for (var u3 = o3(), f3 = 0;f3 < u3; ++f3) {
          var c2 = s4();
          g5.neededDynlibs.push(c2);
        }
      } else {
        l4(_3 !== "dylink.0");
        for (var w4 = 1, h3 = 2, v3 = 3, x5 = 4, y3 = 256, M3 = 3, E3 = 1;t < r2; ) {
          var b4 = a2(), U3 = o3();
          if (b4 === w4)
            g5.memorySize = o3(), g5.memoryAlign = o3(), g5.tableSize = o3(), g5.tableAlign = o3();
          else if (b4 === h3)
            for (var u3 = o3(), f3 = 0;f3 < u3; ++f3)
              c2 = s4(), g5.neededDynlibs.push(c2);
          else if (b4 === v3)
            for (var z3 = o3();z3--; ) {
              var W3 = s4(), D4 = o3();
              D4 & y3 && g5.tlsExports.add(W3);
            }
          else if (b4 === x5)
            for (var z3 = o3();z3--; ) {
              var N2 = s4(), W3 = s4(), D4 = o3();
              (D4 & M3) == E3 && g5.weakImports.add(W3);
            }
          else
            t += U3;
        }
      }
      return g5;
    };
    function getValue(e, t = "i8") {
      switch (t.endsWith("*") && (t = "*"), t) {
        case "i1":
          return HEAP8[e];
        case "i8":
          return HEAP8[e];
        case "i16":
          return HEAP16[e >> 1];
        case "i32":
          return HEAP32[e >> 2];
        case "i64":
          return HEAP64[e >> 3];
        case "float":
          return HEAPF32[e >> 2];
        case "double":
          return HEAPF64[e >> 3];
        case "*":
          return HEAPU32[e >> 2];
        default:
          abort(`invalid type for getValue: ${t}`);
      }
    }
    var newDSO = (e, t, r2) => {
      var a2 = { refcount: Infinity, name: e, exports: r2, global: true };
      return LDSO.loadedLibsByName[e] = a2, t != null && (LDSO.loadedLibsByHandle[t] = a2), a2;
    }, LDSO = { loadedLibsByName: {}, loadedLibsByHandle: {}, init() {
      newDSO("__main__", 0, wasmImports);
    } }, ___heap_base = 15394512, alignMemory = (e, t) => Math.ceil(e / t) * t, getMemory = (e) => {
      if (runtimeInitialized)
        return _calloc(e, 1);
      var t = ___heap_base, r2 = t + alignMemory(e, 16);
      return ___heap_base = r2, GOT.__heap_base.value = r2, t;
    }, isInternalSym = (e) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(e) || e.startsWith("__em_js__"), uleb128Encode = (e, t) => {
      e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
    }, sigToWasmTypes = (e) => {
      for (var t = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" }, r2 = { parameters: [], results: e[0] == "v" ? [] : [t[e[0]]] }, a2 = 1;a2 < e.length; ++a2)
        r2.parameters.push(t[e[a2]]);
      return r2;
    }, generateFuncType = (e, t) => {
      var r2 = e.slice(0, 1), a2 = e.slice(1), o3 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
      t.push(96), uleb128Encode(a2.length, t);
      for (var s4 = 0;s4 < a2.length; ++s4)
        t.push(o3[a2[s4]]);
      r2 == "v" ? t.push(0) : t.push(1, o3[r2]);
    }, convertJsFunctionToWasm = (e, t) => {
      if (typeof WebAssembly.Function == "function")
        return new WebAssembly.Function(sigToWasmTypes(t), e);
      var r2 = [1];
      generateFuncType(t, r2);
      var a2 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
      uleb128Encode(r2.length, a2), a2.push(...r2), a2.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
      var o3 = new WebAssembly.Module(new Uint8Array(a2)), s4 = new WebAssembly.Instance(o3, { e: { f: e } }), l4 = s4.exports.f;
      return l4;
    }, wasmTable = new WebAssembly.Table({ initial: 5919, element: "anyfunc" }), getWasmTableEntry = (e) => wasmTable.get(e), updateTableMap = (e, t) => {
      if (functionsInTableMap)
        for (var r2 = e;r2 < e + t; r2++) {
          var a2 = getWasmTableEntry(r2);
          a2 && functionsInTableMap.set(a2, r2);
        }
    }, functionsInTableMap, getFunctionAddress = (e) => (functionsInTableMap || (functionsInTableMap = new WeakMap, updateTableMap(0, wasmTable.length)), functionsInTableMap.get(e) || 0), freeTableIndexes = [], getEmptyTableSlot = () => {
      if (freeTableIndexes.length)
        return freeTableIndexes.pop();
      try {
        wasmTable.grow(1);
      } catch (e) {
        throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
      }
      return wasmTable.length - 1;
    }, setWasmTableEntry = (e, t) => wasmTable.set(e, t), addFunction = (e, t) => {
      var r2 = getFunctionAddress(e);
      if (r2)
        return r2;
      var a2 = getEmptyTableSlot();
      try {
        setWasmTableEntry(a2, e);
      } catch (s4) {
        if (!(s4 instanceof TypeError))
          throw s4;
        var o3 = convertJsFunctionToWasm(e, t);
        setWasmTableEntry(a2, o3);
      }
      return functionsInTableMap.set(e, a2), a2;
    }, updateGOT = (e, t) => {
      for (var r2 in e)
        if (!isInternalSym(r2)) {
          var a2 = e[r2];
          GOT[r2] || (GOT[r2] = new WebAssembly.Global({ value: "i32", mutable: true })), (t || GOT[r2].value == 0) && (typeof a2 == "function" ? GOT[r2].value = addFunction(a2) : typeof a2 == "number" ? GOT[r2].value = a2 : err(`unhandled export type for '${r2}': ${typeof a2}`));
        }
    }, relocateExports = (e, t, r2) => {
      var a2 = {};
      for (var o3 in e) {
        var s4 = e[o3];
        typeof s4 == "object" && (s4 = s4.value), typeof s4 == "number" && (s4 += t), a2[o3] = s4;
      }
      return updateGOT(a2, r2), a2;
    }, isSymbolDefined = (e) => {
      var t = wasmImports[e];
      return !(!t || t.stub);
    }, dynCall = (e, t, r2 = []) => {
      var a2 = getWasmTableEntry(t)(...r2);
      return a2;
    }, stackSave = () => _emscripten_stack_get_current(), stackRestore = (e) => __emscripten_stack_restore(e), createInvokeFunction = (e) => (t, ...r2) => {
      var a2 = stackSave();
      try {
        return dynCall(e, t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        if (_setThrew(1, 0), e[0] == "j")
          return 0n;
      }
    }, resolveGlobalSymbol = (e, t = false) => {
      var r2;
      return isSymbolDefined(e) ? r2 = wasmImports[e] : e.startsWith("invoke_") && (r2 = wasmImports[e] = createInvokeFunction(e.split("_")[1])), { sym: r2, name: e };
    }, UTF8ToString = (e, t) => e ? UTF8ArrayToString(HEAPU8, e, t) : "", loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var firstLoad = !handle || !HEAP8[handle + 8];
        if (firstLoad) {
          var memAlign = Math.pow(2, metadata.memoryAlign), memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0, tableBase = metadata.tableSize ? wasmTable.length : 0;
          handle && (HEAP8[handle + 8] = 1, HEAPU32[handle + 12 >> 2] = memoryBase, HEAP32[handle + 16 >> 2] = metadata.memorySize, HEAPU32[handle + 20 >> 2] = tableBase, HEAP32[handle + 24 >> 2] = metadata.tableSize);
        } else
          memoryBase = HEAPU32[handle + 12 >> 2], tableBase = HEAPU32[handle + 20 >> 2];
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
        var moduleExports;
        function resolveSymbol(e) {
          var t = resolveGlobalSymbol(e).sym;
          return !t && localScope && (t = localScope[e]), t || (t = moduleExports[e]), t;
        }
        var proxyHandler = { get(e, t) {
          switch (t) {
            case "__memory_base":
              return memoryBase;
            case "__table_base":
              return tableBase;
          }
          if (t in wasmImports && !wasmImports[t].stub)
            return wasmImports[t];
          if (!(t in e)) {
            var r2;
            e[t] = (...a2) => {
              if (r2 || (r2 = resolveSymbol(t)), !r2) {
                if (t === "getTempRet0")
                  return __emscripten_tempret_get(...a2);
                throw new Error(`Dynamic linking error: cannot resolve symbol ${t}`);
              }
              return r2(...a2);
            };
          }
          return e[t];
        } }, proxy = new Proxy({}, proxyHandler), info = { "GOT.mem": new Proxy({}, GOTHandler), "GOT.func": new Proxy({}, GOTHandler), env: proxy, wasi_snapshot_preview1: proxy };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols();
          function addEmAsm(addr, body) {
            for (var args = [], arity = 0;arity < 16 && body.indexOf("$" + arity) != -1; arity++)
              args.push("$" + arity);
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          if ("__start_em_asm" in moduleExports)
            for (var { __start_em_asm: start, __stop_em_asm: stop } = moduleExports;start < stop; ) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
            }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            if (cSig = cSig.slice(1, -1), cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replaceAll("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          for (var name in moduleExports)
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name], jsString = UTF8ToString(start), parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]), delete moduleExports[name];
            }
          var applyRelocs = moduleExports.__wasm_apply_data_relocs;
          applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
          var init = moduleExports.__wasm_call_ctors;
          return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
        }
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then((e) => postInstantiation(e.module, e.instance));
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary), instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      return flags.loadAsync ? metadata.neededDynlibs.reduce((e, t) => e.then(() => loadDynamicLibrary(t, flags, localScope)), Promise.resolve()).then(loadModule) : (metadata.neededDynlibs.forEach((e) => loadDynamicLibrary(e, flags, localScope)), loadModule());
    }, mergeLibSymbols = (e, t) => {
      for (var [r2, a2] of Object.entries(e)) {
        let o3 = (l4) => {
          isSymbolDefined(l4) || (wasmImports[l4] = a2);
        };
        o3(r2);
        let s4 = "__main_argc_argv";
        r2 == "main" && o3(s4), r2 == s4 && o3("main");
      }
    }, asyncLoad = async (e) => {
      var t = await readAsync(e);
      return new Uint8Array(t);
    }, preloadPlugins = Module.preloadPlugins || [], registerWasmPlugin = () => {
      var e = { promiseChainEnd: Promise.resolve(), canHandle: (t) => !Module.noWasmDecoding && t.endsWith(".so"), handle: (t, r2, a2, o3) => {
        e.promiseChainEnd = e.promiseChainEnd.then(() => loadWebAssemblyModule(t, { loadAsync: true, nodelete: true }, r2, {})).then((s4) => {
          preloadedWasm[r2] = s4, a2(t);
        }, (s4) => {
          err(`failed to instantiate wasm: ${r2}: ${s4}`), o3();
        });
      } };
      preloadPlugins.push(e);
    }, preloadedWasm = {};
    function loadDynamicLibrary(e, t = { global: true, nodelete: true }, r2, a2) {
      var o3 = LDSO.loadedLibsByName[e];
      if (o3)
        return t.global ? o3.global || (o3.global = true, mergeLibSymbols(o3.exports, e)) : r2 && Object.assign(r2, o3.exports), t.nodelete && o3.refcount !== Infinity && (o3.refcount = Infinity), o3.refcount++, a2 && (LDSO.loadedLibsByHandle[a2] = o3), t.loadAsync ? Promise.resolve(true) : true;
      o3 = newDSO(e, a2, "loading"), o3.refcount = t.nodelete ? Infinity : 1, o3.global = t.global;
      function s4() {
        if (a2) {
          var n3 = HEAPU32[a2 + 28 >> 2], m4 = HEAPU32[a2 + 32 >> 2];
          if (n3 && m4) {
            var p3 = HEAP8.slice(n3, n3 + m4);
            return t.loadAsync ? Promise.resolve(p3) : p3;
          }
        }
        var d3 = locateFile(e);
        if (t.loadAsync)
          return asyncLoad(d3);
        if (!readBinary)
          throw new Error(`${d3}: file not found, and synchronous loading of external files is not available`);
        return readBinary(d3);
      }
      function l4() {
        var n3 = preloadedWasm[e];
        return n3 ? t.loadAsync ? Promise.resolve(n3) : n3 : t.loadAsync ? s4().then((m4) => loadWebAssemblyModule(m4, t, e, r2, a2)) : loadWebAssemblyModule(s4(), t, e, r2, a2);
      }
      function _3(n3) {
        o3.global ? mergeLibSymbols(n3, e) : r2 && Object.assign(r2, n3), o3.exports = n3;
      }
      return t.loadAsync ? l4().then((n3) => (_3(n3), true)) : (_3(l4()), true);
    }
    var reportUndefinedSymbols = () => {
      for (var [e, t] of Object.entries(GOT))
        if (t.value == 0) {
          var r2 = resolveGlobalSymbol(e, true).sym;
          if (!r2 && !t.required)
            continue;
          if (typeof r2 == "function")
            t.value = addFunction(r2, r2.sig);
          else if (typeof r2 == "number")
            t.value = r2;
          else
            throw new Error(`bad export type for '${e}': ${typeof r2}`);
        }
    }, loadDylibs = () => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs"), dynamicLibraries.reduce((e, t) => e.then(() => loadDynamicLibrary(t, { loadAsync: true, global: true, nodelete: true, allowUndefined: true })), Promise.resolve()).then(() => {
        reportUndefinedSymbols(), removeRunDependency("loadDylibs");
      });
    }, noExitRuntime = Module.noExitRuntime || true;
    function setValue(e, t, r2 = "i8") {
      switch (r2.endsWith("*") && (r2 = "*"), r2) {
        case "i1":
          HEAP8[e] = t;
          break;
        case "i8":
          HEAP8[e] = t;
          break;
        case "i16":
          HEAP16[e >> 1] = t;
          break;
        case "i32":
          HEAP32[e >> 2] = t;
          break;
        case "i64":
          HEAP64[e >> 3] = BigInt(t);
          break;
        case "float":
          HEAPF32[e >> 2] = t;
          break;
        case "double":
          HEAPF64[e >> 3] = t;
          break;
        case "*":
          HEAPU32[e >> 2] = t;
          break;
        default:
          abort(`invalid type for setValue: ${r2}`);
      }
    }
    var ___assert_fail = (e, t, r2, a2) => abort(`Assertion failed: ${UTF8ToString(e)}, at: ` + [t ? UTF8ToString(t) : "unknown filename", r2, a2 ? UTF8ToString(a2) : "unknown function"]);
    ___assert_fail.sig = "vppip";
    var ___call_sighandler = (e, t) => getWasmTableEntry(e)(t);
    ___call_sighandler.sig = "vpi";
    var ___memory_base = new WebAssembly.Global({ value: "i32", mutable: false }, 12582912), ___stack_pointer = new WebAssembly.Global({ value: "i32", mutable: true }, 15394512), PATH = { isAbs: (e) => e.charAt(0) === "/", splitPath: (e) => {
      var t = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return t.exec(e).slice(1);
    }, normalizeArray: (e, t) => {
      for (var r2 = 0, a2 = e.length - 1;a2 >= 0; a2--) {
        var o3 = e[a2];
        o3 === "." ? e.splice(a2, 1) : o3 === ".." ? (e.splice(a2, 1), r2++) : r2 && (e.splice(a2, 1), r2--);
      }
      if (t)
        for (;r2; r2--)
          e.unshift("..");
      return e;
    }, normalize: (e) => {
      var t = PATH.isAbs(e), r2 = e.substr(-1) === "/";
      return e = PATH.normalizeArray(e.split("/").filter((a2) => !!a2), !t).join("/"), !e && !t && (e = "."), e && r2 && (e += "/"), (t ? "/" : "") + e;
    }, dirname: (e) => {
      var t = PATH.splitPath(e), r2 = t[0], a2 = t[1];
      return !r2 && !a2 ? "." : (a2 && (a2 = a2.substr(0, a2.length - 1)), r2 + a2);
    }, basename: (e) => {
      if (e === "/")
        return "/";
      e = PATH.normalize(e), e = e.replace(/\/$/, "");
      var t = e.lastIndexOf("/");
      return t === -1 ? e : e.substr(t + 1);
    }, join: (...e) => PATH.normalize(e.join("/")), join2: (e, t) => PATH.normalize(e + "/" + t) }, initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function")
        return (a2) => crypto.getRandomValues(a2);
      if (ENVIRONMENT_IS_NODE)
        try {
          var e = require("crypto"), t = e.randomFillSync;
          if (t)
            return (a2) => e.randomFillSync(a2);
          var r2 = e.randomBytes;
          return (a2) => (a2.set(r2(a2.byteLength)), a2);
        } catch {}
      abort("initRandomDevice");
    }, randomFill = (e) => (randomFill = initRandomFill())(e), PATH_FS = { resolve: (...e) => {
      for (var t = "", r2 = false, a2 = e.length - 1;a2 >= -1 && !r2; a2--) {
        var o3 = a2 >= 0 ? e[a2] : FS.cwd();
        if (typeof o3 != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!o3)
          return "";
        t = o3 + "/" + t, r2 = PATH.isAbs(o3);
      }
      return t = PATH.normalizeArray(t.split("/").filter((s4) => !!s4), !r2).join("/"), (r2 ? "/" : "") + t || ".";
    }, relative: (e, t) => {
      e = PATH_FS.resolve(e).substr(1), t = PATH_FS.resolve(t).substr(1);
      function r2(m4) {
        for (var p3 = 0;p3 < m4.length && m4[p3] === ""; p3++)
          ;
        for (var d3 = m4.length - 1;d3 >= 0 && m4[d3] === ""; d3--)
          ;
        return p3 > d3 ? [] : m4.slice(p3, d3 - p3 + 1);
      }
      for (var a2 = r2(e.split("/")), o3 = r2(t.split("/")), s4 = Math.min(a2.length, o3.length), l4 = s4, _3 = 0;_3 < s4; _3++)
        if (a2[_3] !== o3[_3]) {
          l4 = _3;
          break;
        }
      for (var n3 = [], _3 = l4;_3 < a2.length; _3++)
        n3.push("..");
      return n3 = n3.concat(o3.slice(l4)), n3.join("/");
    } }, FS_stdin_getChar_buffer = [], lengthBytesUTF8 = (e) => {
      for (var t = 0, r2 = 0;r2 < e.length; ++r2) {
        var a2 = e.charCodeAt(r2);
        a2 <= 127 ? t++ : a2 <= 2047 ? t += 2 : a2 >= 55296 && a2 <= 57343 ? (t += 4, ++r2) : t += 3;
      }
      return t;
    }, stringToUTF8Array = (e, t, r2, a2) => {
      if (!(a2 > 0))
        return 0;
      for (var o3 = r2, s4 = r2 + a2 - 1, l4 = 0;l4 < e.length; ++l4) {
        var _3 = e.charCodeAt(l4);
        if (_3 >= 55296 && _3 <= 57343) {
          var n3 = e.charCodeAt(++l4);
          _3 = 65536 + ((_3 & 1023) << 10) | n3 & 1023;
        }
        if (_3 <= 127) {
          if (r2 >= s4)
            break;
          t[r2++] = _3;
        } else if (_3 <= 2047) {
          if (r2 + 1 >= s4)
            break;
          t[r2++] = 192 | _3 >> 6, t[r2++] = 128 | _3 & 63;
        } else if (_3 <= 65535) {
          if (r2 + 2 >= s4)
            break;
          t[r2++] = 224 | _3 >> 12, t[r2++] = 128 | _3 >> 6 & 63, t[r2++] = 128 | _3 & 63;
        } else {
          if (r2 + 3 >= s4)
            break;
          t[r2++] = 240 | _3 >> 18, t[r2++] = 128 | _3 >> 12 & 63, t[r2++] = 128 | _3 >> 6 & 63, t[r2++] = 128 | _3 & 63;
        }
      }
      return t[r2] = 0, r2 - o3;
    };
    function intArrayFromString(e, t, r2) {
      var a2 = r2 > 0 ? r2 : lengthBytesUTF8(e) + 1, o3 = new Array(a2), s4 = stringToUTF8Array(e, o3, 0, o3.length);
      return t && (o3.length = s4), o3;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var e = null;
        if (ENVIRONMENT_IS_NODE) {
          var t = 256, r2 = Buffer.alloc(t), a2 = 0, o3 = process.stdin.fd;
          try {
            a2 = fs.readSync(o3, r2, 0, t);
          } catch (s4) {
            if (s4.toString().includes("EOF"))
              a2 = 0;
            else
              throw s4;
          }
          a2 > 0 && (e = r2.slice(0, a2).toString("utf-8"));
        } else
          typeof window < "u" && typeof window.prompt == "function" && (e = window.prompt("Input: "), e !== null && (e += `
`));
        if (!e)
          return null;
        FS_stdin_getChar_buffer = intArrayFromString(e, true);
      }
      return FS_stdin_getChar_buffer.shift();
    }, TTY = { ttys: [], init() {}, shutdown() {}, register(e, t) {
      TTY.ttys[e] = { input: [], output: [], ops: t }, FS.registerDevice(e, TTY.stream_ops);
    }, stream_ops: { open(e) {
      var t = TTY.ttys[e.node.rdev];
      if (!t)
        throw new FS.ErrnoError(43);
      e.tty = t, e.seekable = false;
    }, close(e) {
      e.tty.ops.fsync(e.tty);
    }, fsync(e) {
      e.tty.ops.fsync(e.tty);
    }, read(e, t, r2, a2, o3) {
      if (!e.tty || !e.tty.ops.get_char)
        throw new FS.ErrnoError(60);
      for (var s4 = 0, l4 = 0;l4 < a2; l4++) {
        var _3;
        try {
          _3 = e.tty.ops.get_char(e.tty);
        } catch {
          throw new FS.ErrnoError(29);
        }
        if (_3 === undefined && s4 === 0)
          throw new FS.ErrnoError(6);
        if (_3 == null)
          break;
        s4++, t[r2 + l4] = _3;
      }
      return s4 && (e.node.atime = Date.now()), s4;
    }, write(e, t, r2, a2, o3) {
      if (!e.tty || !e.tty.ops.put_char)
        throw new FS.ErrnoError(60);
      try {
        for (var s4 = 0;s4 < a2; s4++)
          e.tty.ops.put_char(e.tty, t[r2 + s4]);
      } catch {
        throw new FS.ErrnoError(29);
      }
      return a2 && (e.node.mtime = e.node.ctime = Date.now()), s4;
    } }, default_tty_ops: { get_char(e) {
      return FS_stdin_getChar();
    }, put_char(e, t) {
      t === null || t === 10 ? (out(UTF8ArrayToString(e.output)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync(e) {
      e.output && e.output.length > 0 && (out(UTF8ArrayToString(e.output)), e.output = []);
    }, ioctl_tcgets(e) {
      return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
    }, ioctl_tcsets(e, t, r2) {
      return 0;
    }, ioctl_tiocgwinsz(e) {
      return [24, 80];
    } }, default_tty1_ops: { put_char(e, t) {
      t === null || t === 10 ? (err(UTF8ArrayToString(e.output)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync(e) {
      e.output && e.output.length > 0 && (err(UTF8ArrayToString(e.output)), e.output = []);
    } } }, zeroMemory = (e, t) => {
      HEAPU8.fill(0, e, e + t);
    }, mmapAlloc = (e) => {
      e = alignMemory(e, 65536);
      var t = _emscripten_builtin_memalign(65536, e);
      return t && zeroMemory(t, e), t;
    }, MEMFS = { ops_table: null, mount(e) {
      return MEMFS.createNode(null, "/", 16895, 0);
    }, createNode(e, t, r2, a2) {
      if (FS.isBlkdev(r2) || FS.isFIFO(r2))
        throw new FS.ErrnoError(63);
      MEMFS.ops_table || (MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } });
      var o3 = FS.createNode(e, t, r2, a2);
      return FS.isDir(o3.mode) ? (o3.node_ops = MEMFS.ops_table.dir.node, o3.stream_ops = MEMFS.ops_table.dir.stream, o3.contents = {}) : FS.isFile(o3.mode) ? (o3.node_ops = MEMFS.ops_table.file.node, o3.stream_ops = MEMFS.ops_table.file.stream, o3.usedBytes = 0, o3.contents = null) : FS.isLink(o3.mode) ? (o3.node_ops = MEMFS.ops_table.link.node, o3.stream_ops = MEMFS.ops_table.link.stream) : FS.isChrdev(o3.mode) && (o3.node_ops = MEMFS.ops_table.chrdev.node, o3.stream_ops = MEMFS.ops_table.chrdev.stream), o3.atime = o3.mtime = o3.ctime = Date.now(), e && (e.contents[t] = o3, e.atime = e.mtime = e.ctime = o3.atime), o3;
    }, getFileDataAsTypedArray(e) {
      return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0);
    }, expandFileStorage(e, t) {
      var r2 = e.contents ? e.contents.length : 0;
      if (!(r2 >= t)) {
        var a2 = 1048576;
        t = Math.max(t, r2 * (r2 < a2 ? 2 : 1.125) >>> 0), r2 != 0 && (t = Math.max(t, 256));
        var o3 = e.contents;
        e.contents = new Uint8Array(t), e.usedBytes > 0 && e.contents.set(o3.subarray(0, e.usedBytes), 0);
      }
    }, resizeFileStorage(e, t) {
      if (e.usedBytes != t)
        if (t == 0)
          e.contents = null, e.usedBytes = 0;
        else {
          var r2 = e.contents;
          e.contents = new Uint8Array(t), r2 && e.contents.set(r2.subarray(0, Math.min(t, e.usedBytes))), e.usedBytes = t;
        }
    }, node_ops: { getattr(e) {
      var t = {};
      return t.dev = FS.isChrdev(e.mode) ? e.id : 1, t.ino = e.id, t.mode = e.mode, t.nlink = 1, t.uid = 0, t.gid = 0, t.rdev = e.rdev, FS.isDir(e.mode) ? t.size = 4096 : FS.isFile(e.mode) ? t.size = e.usedBytes : FS.isLink(e.mode) ? t.size = e.link.length : t.size = 0, t.atime = new Date(e.atime), t.mtime = new Date(e.mtime), t.ctime = new Date(e.ctime), t.blksize = 4096, t.blocks = Math.ceil(t.size / t.blksize), t;
    }, setattr(e, t) {
      for (let r2 of ["mode", "atime", "mtime", "ctime"])
        t[r2] && (e[r2] = t[r2]);
      t.size !== undefined && MEMFS.resizeFileStorage(e, t.size);
    }, lookup(e, t) {
      throw MEMFS.doesNotExistError;
    }, mknod(e, t, r2, a2) {
      return MEMFS.createNode(e, t, r2, a2);
    }, rename(e, t, r2) {
      var a2;
      try {
        a2 = FS.lookupNode(t, r2);
      } catch {}
      if (a2) {
        if (FS.isDir(e.mode))
          for (var o3 in a2.contents)
            throw new FS.ErrnoError(55);
        FS.hashRemoveNode(a2);
      }
      delete e.parent.contents[e.name], t.contents[r2] = e, e.name = r2, t.ctime = t.mtime = e.parent.ctime = e.parent.mtime = Date.now();
    }, unlink(e, t) {
      delete e.contents[t], e.ctime = e.mtime = Date.now();
    }, rmdir(e, t) {
      var r2 = FS.lookupNode(e, t);
      for (var a2 in r2.contents)
        throw new FS.ErrnoError(55);
      delete e.contents[t], e.ctime = e.mtime = Date.now();
    }, readdir(e) {
      return [".", "..", ...Object.keys(e.contents)];
    }, symlink(e, t, r2) {
      var a2 = MEMFS.createNode(e, t, 41471, 0);
      return a2.link = r2, a2;
    }, readlink(e) {
      if (!FS.isLink(e.mode))
        throw new FS.ErrnoError(28);
      return e.link;
    } }, stream_ops: { read(e, t, r2, a2, o3) {
      var s4 = e.node.contents;
      if (o3 >= e.node.usedBytes)
        return 0;
      var l4 = Math.min(e.node.usedBytes - o3, a2);
      if (l4 > 8 && s4.subarray)
        t.set(s4.subarray(o3, o3 + l4), r2);
      else
        for (var _3 = 0;_3 < l4; _3++)
          t[r2 + _3] = s4[o3 + _3];
      return l4;
    }, write(e, t, r2, a2, o3, s4) {
      if (t.buffer === HEAP8.buffer && (s4 = false), !a2)
        return 0;
      var l4 = e.node;
      if (l4.mtime = l4.ctime = Date.now(), t.subarray && (!l4.contents || l4.contents.subarray)) {
        if (s4)
          return l4.contents = t.subarray(r2, r2 + a2), l4.usedBytes = a2, a2;
        if (l4.usedBytes === 0 && o3 === 0)
          return l4.contents = t.slice(r2, r2 + a2), l4.usedBytes = a2, a2;
        if (o3 + a2 <= l4.usedBytes)
          return l4.contents.set(t.subarray(r2, r2 + a2), o3), a2;
      }
      if (MEMFS.expandFileStorage(l4, o3 + a2), l4.contents.subarray && t.subarray)
        l4.contents.set(t.subarray(r2, r2 + a2), o3);
      else
        for (var _3 = 0;_3 < a2; _3++)
          l4.contents[o3 + _3] = t[r2 + _3];
      return l4.usedBytes = Math.max(l4.usedBytes, o3 + a2), a2;
    }, llseek(e, t, r2) {
      var a2 = t;
      if (r2 === 1 ? a2 += e.position : r2 === 2 && FS.isFile(e.node.mode) && (a2 += e.node.usedBytes), a2 < 0)
        throw new FS.ErrnoError(28);
      return a2;
    }, allocate(e, t, r2) {
      MEMFS.expandFileStorage(e.node, t + r2), e.node.usedBytes = Math.max(e.node.usedBytes, t + r2);
    }, mmap(e, t, r2, a2, o3) {
      if (!FS.isFile(e.node.mode))
        throw new FS.ErrnoError(43);
      var s4, l4, _3 = e.node.contents;
      if (!(o3 & 2) && _3 && _3.buffer === HEAP8.buffer)
        l4 = false, s4 = _3.byteOffset;
      else {
        if (l4 = true, s4 = mmapAlloc(t), !s4)
          throw new FS.ErrnoError(48);
        _3 && ((r2 > 0 || r2 + t < _3.length) && (_3.subarray ? _3 = _3.subarray(r2, r2 + t) : _3 = Array.prototype.slice.call(_3, r2, r2 + t)), HEAP8.set(_3, s4));
      }
      return { ptr: s4, allocated: l4 };
    }, msync(e, t, r2, a2, o3) {
      return MEMFS.stream_ops.write(e, t, 0, a2, r2, false), 0;
    } } }, FS_createDataFile = (e, t, r2, a2, o3, s4) => {
      FS.createDataFile(e, t, r2, a2, o3, s4);
    }, FS_handledByPreloadPlugin = (e, t, r2, a2) => {
      typeof Browser < "u" && Browser.init();
      var o3 = false;
      return preloadPlugins.forEach((s4) => {
        o3 || s4.canHandle(t) && (s4.handle(e, t, r2, a2), o3 = true);
      }), o3;
    }, FS_createPreloadedFile = (e, t, r2, a2, o3, s4, l4, _3, n3, m4) => {
      var p3 = t ? PATH_FS.resolve(PATH.join2(e, t)) : e, d3 = `cp ${p3}`;
      function g5(u3) {
        function f3(c2) {
          m4?.(), _3 || FS_createDataFile(e, t, c2, a2, o3, n3), s4?.(), removeRunDependency(d3);
        }
        FS_handledByPreloadPlugin(u3, p3, f3, () => {
          l4?.(), removeRunDependency(d3);
        }) || f3(u3);
      }
      addRunDependency(d3), typeof r2 == "string" ? asyncLoad(r2).then(g5, l4) : g5(r2);
    }, FS_modeStringToFlags = (e) => {
      var t = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, r2 = t[e];
      if (typeof r2 > "u")
        throw new Error(`Unknown file open mode: ${e}`);
      return r2;
    }, FS_getMode = (e, t) => {
      var r2 = 0;
      return e && (r2 |= 365), t && (r2 |= 146), r2;
    }, IDBFS = { dbs: {}, indexedDB: () => {
      if (typeof indexedDB < "u")
        return indexedDB;
      var e = null;
      return typeof window == "object" && (e = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB), e;
    }, DB_VERSION: 21, DB_STORE_NAME: "FILE_DATA", queuePersist: (e) => {
      function t() {
        e.idbPersistState === "again" ? r2() : e.idbPersistState = 0;
      }
      function r2() {
        e.idbPersistState = "idb", IDBFS.syncfs(e, false, t);
      }
      e.idbPersistState ? e.idbPersistState === "idb" && (e.idbPersistState = "again") : e.idbPersistState = setTimeout(r2, 0);
    }, mount: (e) => {
      var t = MEMFS.mount(e);
      if (e?.opts?.autoPersist) {
        t.idbPersistState = 0;
        var r2 = t.node_ops;
        t.node_ops = Object.assign({}, t.node_ops), t.node_ops.mknod = (a2, o3, s4, l4) => {
          var _3 = r2.mknod(a2, o3, s4, l4);
          return _3.node_ops = t.node_ops, _3.idbfs_mount = t.mount, _3.memfs_stream_ops = _3.stream_ops, _3.stream_ops = Object.assign({}, _3.stream_ops), _3.stream_ops.write = (n3, m4, p3, d3, g5, u3) => (n3.node.isModified = true, _3.memfs_stream_ops.write(n3, m4, p3, d3, g5, u3)), _3.stream_ops.close = (n3) => {
            var m4 = n3.node;
            if (m4.isModified && (IDBFS.queuePersist(m4.idbfs_mount), m4.isModified = false), m4.memfs_stream_ops.close)
              return m4.memfs_stream_ops.close(n3);
          }, _3;
        }, t.node_ops.mkdir = (...a2) => (IDBFS.queuePersist(t.mount), r2.mkdir(...a2)), t.node_ops.rmdir = (...a2) => (IDBFS.queuePersist(t.mount), r2.rmdir(...a2)), t.node_ops.symlink = (...a2) => (IDBFS.queuePersist(t.mount), r2.symlink(...a2)), t.node_ops.unlink = (...a2) => (IDBFS.queuePersist(t.mount), r2.unlink(...a2)), t.node_ops.rename = (...a2) => (IDBFS.queuePersist(t.mount), r2.rename(...a2));
      }
      return t;
    }, syncfs: (e, t, r2) => {
      IDBFS.getLocalSet(e, (a2, o3) => {
        if (a2)
          return r2(a2);
        IDBFS.getRemoteSet(e, (s4, l4) => {
          if (s4)
            return r2(s4);
          var _3 = t ? l4 : o3, n3 = t ? o3 : l4;
          IDBFS.reconcile(_3, n3, r2);
        });
      });
    }, quit: () => {
      Object.values(IDBFS.dbs).forEach((e) => e.close()), IDBFS.dbs = {};
    }, getDB: (e, t) => {
      var r2 = IDBFS.dbs[e];
      if (r2)
        return t(null, r2);
      var a2;
      try {
        a2 = IDBFS.indexedDB().open(e, IDBFS.DB_VERSION);
      } catch (o3) {
        return t(o3);
      }
      if (!a2)
        return t("Unable to connect to IndexedDB");
      a2.onupgradeneeded = (o3) => {
        var s4 = o3.target.result, l4 = o3.target.transaction, _3;
        s4.objectStoreNames.contains(IDBFS.DB_STORE_NAME) ? _3 = l4.objectStore(IDBFS.DB_STORE_NAME) : _3 = s4.createObjectStore(IDBFS.DB_STORE_NAME), _3.indexNames.contains("timestamp") || _3.createIndex("timestamp", "timestamp", { unique: false });
      }, a2.onsuccess = () => {
        r2 = a2.result, IDBFS.dbs[e] = r2, t(null, r2);
      }, a2.onerror = (o3) => {
        t(o3.target.error), o3.preventDefault();
      };
    }, getLocalSet: (e, t) => {
      var r2 = {};
      function a2(n3) {
        return n3 !== "." && n3 !== "..";
      }
      function o3(n3) {
        return (m4) => PATH.join2(n3, m4);
      }
      for (var s4 = FS.readdir(e.mountpoint).filter(a2).map(o3(e.mountpoint));s4.length; ) {
        var l4 = s4.pop(), _3;
        try {
          _3 = FS.stat(l4);
        } catch (n3) {
          return t(n3);
        }
        FS.isDir(_3.mode) && s4.push(...FS.readdir(l4).filter(a2).map(o3(l4))), r2[l4] = { timestamp: _3.mtime };
      }
      return t(null, { type: "local", entries: r2 });
    }, getRemoteSet: (e, t) => {
      var r2 = {};
      IDBFS.getDB(e.mountpoint, (a2, o3) => {
        if (a2)
          return t(a2);
        try {
          var s4 = o3.transaction([IDBFS.DB_STORE_NAME], "readonly");
          s4.onerror = (n3) => {
            t(n3.target.error), n3.preventDefault();
          };
          var l4 = s4.objectStore(IDBFS.DB_STORE_NAME), _3 = l4.index("timestamp");
          _3.openKeyCursor().onsuccess = (n3) => {
            var m4 = n3.target.result;
            if (!m4)
              return t(null, { type: "remote", db: o3, entries: r2 });
            r2[m4.primaryKey] = { timestamp: m4.key }, m4.continue();
          };
        } catch (n3) {
          return t(n3);
        }
      });
    }, loadLocalEntry: (e, t) => {
      var r2, a2;
      try {
        var o3 = FS.lookupPath(e);
        a2 = o3.node, r2 = FS.stat(e);
      } catch (s4) {
        return t(s4);
      }
      return FS.isDir(r2.mode) ? t(null, { timestamp: r2.mtime, mode: r2.mode }) : FS.isFile(r2.mode) ? (a2.contents = MEMFS.getFileDataAsTypedArray(a2), t(null, { timestamp: r2.mtime, mode: r2.mode, contents: a2.contents })) : t(new Error("node type not supported"));
    }, storeLocalEntry: (e, t, r2) => {
      try {
        if (FS.isDir(t.mode))
          FS.mkdirTree(e, t.mode);
        else if (FS.isFile(t.mode))
          FS.writeFile(e, t.contents, { canOwn: true });
        else
          return r2(new Error("node type not supported"));
        FS.chmod(e, t.mode), FS.utime(e, t.timestamp, t.timestamp);
      } catch (a2) {
        return r2(a2);
      }
      r2(null);
    }, removeLocalEntry: (e, t) => {
      try {
        var r2 = FS.stat(e);
        FS.isDir(r2.mode) ? FS.rmdir(e) : FS.isFile(r2.mode) && FS.unlink(e);
      } catch (a2) {
        return t(a2);
      }
      t(null);
    }, loadRemoteEntry: (e, t, r2) => {
      var a2 = e.get(t);
      a2.onsuccess = (o3) => r2(null, o3.target.result), a2.onerror = (o3) => {
        r2(o3.target.error), o3.preventDefault();
      };
    }, storeRemoteEntry: (e, t, r2, a2) => {
      try {
        var o3 = e.put(r2, t);
      } catch (s4) {
        a2(s4);
        return;
      }
      o3.onsuccess = (s4) => a2(), o3.onerror = (s4) => {
        a2(s4.target.error), s4.preventDefault();
      };
    }, removeRemoteEntry: (e, t, r2) => {
      var a2 = e.delete(t);
      a2.onsuccess = (o3) => r2(), a2.onerror = (o3) => {
        r2(o3.target.error), o3.preventDefault();
      };
    }, reconcile: (e, t, r2) => {
      var a2 = 0, o3 = [];
      Object.keys(e.entries).forEach((d3) => {
        var g5 = e.entries[d3], u3 = t.entries[d3];
        (!u3 || g5.timestamp.getTime() != u3.timestamp.getTime()) && (o3.push(d3), a2++);
      });
      var s4 = [];
      if (Object.keys(t.entries).forEach((d3) => {
        e.entries[d3] || (s4.push(d3), a2++);
      }), !a2)
        return r2(null);
      var l4 = false, _3 = e.type === "remote" ? e.db : t.db, n3 = _3.transaction([IDBFS.DB_STORE_NAME], "readwrite"), m4 = n3.objectStore(IDBFS.DB_STORE_NAME);
      function p3(d3) {
        if (d3 && !l4)
          return l4 = true, r2(d3);
      }
      n3.onerror = n3.onabort = (d3) => {
        p3(d3.target.error), d3.preventDefault();
      }, n3.oncomplete = (d3) => {
        l4 || r2(null);
      }, o3.sort().forEach((d3) => {
        t.type === "local" ? IDBFS.loadRemoteEntry(m4, d3, (g5, u3) => {
          if (g5)
            return p3(g5);
          IDBFS.storeLocalEntry(d3, u3, p3);
        }) : IDBFS.loadLocalEntry(d3, (g5, u3) => {
          if (g5)
            return p3(g5);
          IDBFS.storeRemoteEntry(m4, d3, u3, p3);
        });
      }), s4.sort().reverse().forEach((d3) => {
        t.type === "local" ? IDBFS.removeLocalEntry(d3, p3) : IDBFS.removeRemoteEntry(m4, d3, p3);
      });
    } }, ERRNO_CODES = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 }, NODEFS = { isWindows: false, staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var e = process.binding("constants");
      e.fs && (e = e.fs), NODEFS.flagsForNodeMap = { 1024: e.O_APPEND, 64: e.O_CREAT, 128: e.O_EXCL, 256: e.O_NOCTTY, 0: e.O_RDONLY, 2: e.O_RDWR, 4096: e.O_SYNC, 512: e.O_TRUNC, 1: e.O_WRONLY, 131072: e.O_NOFOLLOW };
    }, convertNodeCode(e) {
      var t = e.code;
      return ERRNO_CODES[t];
    }, tryFSOperation(e) {
      try {
        return e();
      } catch (t) {
        throw t.code ? t.code === "UNKNOWN" ? new FS.ErrnoError(28) : new FS.ErrnoError(NODEFS.convertNodeCode(t)) : t;
      }
    }, mount(e) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(e.opts.root), 0);
    }, createNode(e, t, r2, a2) {
      if (!FS.isDir(r2) && !FS.isFile(r2) && !FS.isLink(r2))
        throw new FS.ErrnoError(28);
      var o3 = FS.createNode(e, t, r2);
      return o3.node_ops = NODEFS.node_ops, o3.stream_ops = NODEFS.stream_ops, o3;
    }, getMode(e) {
      return NODEFS.tryFSOperation(() => {
        var t = fs.lstatSync(e).mode;
        return NODEFS.isWindows && (t |= (t & 292) >> 2), t;
      });
    }, realPath(e) {
      for (var t = [];e.parent !== e; )
        t.push(e.name), e = e.parent;
      return t.push(e.mount.opts.root), t.reverse(), PATH.join(...t);
    }, flagsForNode(e) {
      e &= -2097153, e &= -2049, e &= -32769, e &= -524289, e &= -65537;
      var t = 0;
      for (var r2 in NODEFS.flagsForNodeMap)
        e & r2 && (t |= NODEFS.flagsForNodeMap[r2], e ^= r2);
      if (e)
        throw new FS.ErrnoError(28);
      return t;
    }, node_ops: { getattr(e) {
      var t = NODEFS.realPath(e), r2;
      return NODEFS.tryFSOperation(() => r2 = fs.lstatSync(t)), NODEFS.isWindows && (r2.blksize || (r2.blksize = 4096), r2.blocks || (r2.blocks = (r2.size + r2.blksize - 1) / r2.blksize | 0), r2.mode |= (r2.mode & 292) >> 2), { dev: r2.dev, ino: r2.ino, mode: r2.mode, nlink: r2.nlink, uid: r2.uid, gid: r2.gid, rdev: r2.rdev, size: r2.size, atime: r2.atime, mtime: r2.mtime, ctime: r2.ctime, blksize: r2.blksize, blocks: r2.blocks };
    }, setattr(e, t) {
      var r2 = NODEFS.realPath(e);
      NODEFS.tryFSOperation(() => {
        if (t.mode !== undefined) {
          var a2 = t.mode;
          NODEFS.isWindows && (a2 &= 384), fs.chmodSync(r2, a2), e.mode = t.mode;
        }
        if (t.atime || t.mtime) {
          var o3 = t.atime && new Date(t.atime), s4 = t.mtime && new Date(t.mtime);
          fs.utimesSync(r2, o3, s4);
        }
        t.size !== undefined && fs.truncateSync(r2, t.size);
      });
    }, lookup(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t), a2 = NODEFS.getMode(r2);
      return NODEFS.createNode(e, t, a2);
    }, mknod(e, t, r2, a2) {
      var o3 = NODEFS.createNode(e, t, r2, a2), s4 = NODEFS.realPath(o3);
      return NODEFS.tryFSOperation(() => {
        FS.isDir(o3.mode) ? fs.mkdirSync(s4, o3.mode) : fs.writeFileSync(s4, "", { mode: o3.mode });
      }), o3;
    }, rename(e, t, r2) {
      var a2 = NODEFS.realPath(e), o3 = PATH.join2(NODEFS.realPath(t), r2);
      try {
        FS.unlink(o3);
      } catch {}
      NODEFS.tryFSOperation(() => fs.renameSync(a2, o3)), e.name = r2;
    }, unlink(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.unlinkSync(r2));
    }, rmdir(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.rmdirSync(r2));
    }, readdir(e) {
      var t = NODEFS.realPath(e);
      return NODEFS.tryFSOperation(() => fs.readdirSync(t));
    }, symlink(e, t, r2) {
      var a2 = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.symlinkSync(r2, a2));
    }, readlink(e) {
      var t = NODEFS.realPath(e);
      return NODEFS.tryFSOperation(() => fs.readlinkSync(t));
    }, statfs(e) {
      var t = NODEFS.tryFSOperation(() => fs.statfsSync(e));
      return t.frsize = t.bsize, t;
    } }, stream_ops: { open(e) {
      var t = NODEFS.realPath(e.node);
      NODEFS.tryFSOperation(() => {
        FS.isFile(e.node.mode) && (e.shared.refcount = 1, e.nfd = fs.openSync(t, NODEFS.flagsForNode(e.flags)));
      });
    }, close(e) {
      NODEFS.tryFSOperation(() => {
        FS.isFile(e.node.mode) && e.nfd && --e.shared.refcount === 0 && fs.closeSync(e.nfd);
      });
    }, dup(e) {
      e.shared.refcount++;
    }, read(e, t, r2, a2, o3) {
      return a2 === 0 ? 0 : NODEFS.tryFSOperation(() => fs.readSync(e.nfd, new Int8Array(t.buffer, r2, a2), 0, a2, o3));
    }, write(e, t, r2, a2, o3) {
      return NODEFS.tryFSOperation(() => fs.writeSync(e.nfd, new Int8Array(t.buffer, r2, a2), 0, a2, o3));
    }, llseek(e, t, r2) {
      var a2 = t;
      if (r2 === 1 ? a2 += e.position : r2 === 2 && FS.isFile(e.node.mode) && NODEFS.tryFSOperation(() => {
        var o3 = fs.fstatSync(e.nfd);
        a2 += o3.size;
      }), a2 < 0)
        throw new FS.ErrnoError(28);
      return a2;
    }, mmap(e, t, r2, a2, o3) {
      if (!FS.isFile(e.node.mode))
        throw new FS.ErrnoError(43);
      var s4 = mmapAlloc(t);
      return NODEFS.stream_ops.read(e, HEAP8, s4, t, r2), { ptr: s4, allocated: true };
    }, msync(e, t, r2, a2, o3) {
      return NODEFS.stream_ops.write(e, t, 0, a2, r2, false), 0;
    } } }, FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
      constructor(e) {
        P(this, "name", "ErrnoError");
        this.errno = e;
      }
    }, filesystems: null, syncFSRequests: 0, readFiles: {}, FSStream: class {
      constructor() {
        P(this, "shared", {});
      }
      get object() {
        return this.node;
      }
      set object(e) {
        this.node = e;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(e) {
        this.shared.flags = e;
      }
      get position() {
        return this.shared.position;
      }
      set position(e) {
        this.shared.position = e;
      }
    }, FSNode: class {
      constructor(e, t, r2, a2) {
        P(this, "node_ops", {});
        P(this, "stream_ops", {});
        P(this, "readMode", 365);
        P(this, "writeMode", 146);
        P(this, "mounted", null);
        e || (e = this), this.parent = e, this.mount = e.mount, this.id = FS.nextInode++, this.name = t, this.mode = r2, this.rdev = a2, this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(e) {
        e ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(e) {
        e ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    }, lookupPath(e, t = {}) {
      if (!e)
        return { path: "", node: null };
      t.follow_mount ?? (t.follow_mount = true), PATH.isAbs(e) || (e = FS.cwd() + "/" + e);
      e:
        for (var r2 = 0;r2 < 40; r2++) {
          for (var a2 = e.split("/").filter((m4) => !!m4 && m4 !== "."), o3 = FS.root, s4 = "/", l4 = 0;l4 < a2.length; l4++) {
            var _3 = l4 === a2.length - 1;
            if (_3 && t.parent)
              break;
            if (a2[l4] === "..") {
              s4 = PATH.dirname(s4), o3 = o3.parent;
              continue;
            }
            s4 = PATH.join2(s4, a2[l4]);
            try {
              o3 = FS.lookupNode(o3, a2[l4]);
            } catch (m4) {
              if (m4?.errno === 44 && _3 && t.noent_okay)
                return { path: s4 };
              throw m4;
            }
            if (FS.isMountpoint(o3) && (!_3 || t.follow_mount) && (o3 = o3.mounted.root), FS.isLink(o3.mode) && (!_3 || t.follow)) {
              if (!o3.node_ops.readlink)
                throw new FS.ErrnoError(52);
              var n3 = o3.node_ops.readlink(o3);
              PATH.isAbs(n3) || (n3 = PATH.dirname(s4) + "/" + n3), e = n3 + "/" + a2.slice(l4 + 1).join("/");
              continue e;
            }
          }
          return { path: s4, node: o3 };
        }
      throw new FS.ErrnoError(32);
    }, getPath(e) {
      for (var t;; ) {
        if (FS.isRoot(e)) {
          var r2 = e.mount.mountpoint;
          return t ? r2[r2.length - 1] !== "/" ? `${r2}/${t}` : r2 + t : r2;
        }
        t = t ? `${e.name}/${t}` : e.name, e = e.parent;
      }
    }, hashName(e, t) {
      for (var r2 = 0, a2 = 0;a2 < t.length; a2++)
        r2 = (r2 << 5) - r2 + t.charCodeAt(a2) | 0;
      return (e + r2 >>> 0) % FS.nameTable.length;
    }, hashAddNode(e) {
      var t = FS.hashName(e.parent.id, e.name);
      e.name_next = FS.nameTable[t], FS.nameTable[t] = e;
    }, hashRemoveNode(e) {
      var t = FS.hashName(e.parent.id, e.name);
      if (FS.nameTable[t] === e)
        FS.nameTable[t] = e.name_next;
      else
        for (var r2 = FS.nameTable[t];r2; ) {
          if (r2.name_next === e) {
            r2.name_next = e.name_next;
            break;
          }
          r2 = r2.name_next;
        }
    }, lookupNode(e, t) {
      var r2 = FS.mayLookup(e);
      if (r2)
        throw new FS.ErrnoError(r2);
      for (var a2 = FS.hashName(e.id, t), o3 = FS.nameTable[a2];o3; o3 = o3.name_next) {
        var s4 = o3.name;
        if (o3.parent.id === e.id && s4 === t)
          return o3;
      }
      return FS.lookup(e, t);
    }, createNode(e, t, r2, a2) {
      var o3 = new FS.FSNode(e, t, r2, a2);
      return FS.hashAddNode(o3), o3;
    }, destroyNode(e) {
      FS.hashRemoveNode(e);
    }, isRoot(e) {
      return e === e.parent;
    }, isMountpoint(e) {
      return !!e.mounted;
    }, isFile(e) {
      return (e & 61440) === 32768;
    }, isDir(e) {
      return (e & 61440) === 16384;
    }, isLink(e) {
      return (e & 61440) === 40960;
    }, isChrdev(e) {
      return (e & 61440) === 8192;
    }, isBlkdev(e) {
      return (e & 61440) === 24576;
    }, isFIFO(e) {
      return (e & 61440) === 4096;
    }, isSocket(e) {
      return (e & 49152) === 49152;
    }, flagsToPermissionString(e) {
      var t = ["r", "w", "rw"][e & 3];
      return e & 512 && (t += "w"), t;
    }, nodePermissions(e, t) {
      return FS.ignorePermissions ? 0 : t.includes("r") && !(e.mode & 292) || t.includes("w") && !(e.mode & 146) || t.includes("x") && !(e.mode & 73) ? 2 : 0;
    }, mayLookup(e) {
      if (!FS.isDir(e.mode))
        return 54;
      var t = FS.nodePermissions(e, "x");
      return t || (e.node_ops.lookup ? 0 : 2);
    }, mayCreate(e, t) {
      if (!FS.isDir(e.mode))
        return 54;
      try {
        var r2 = FS.lookupNode(e, t);
        return 20;
      } catch {}
      return FS.nodePermissions(e, "wx");
    }, mayDelete(e, t, r2) {
      var a2;
      try {
        a2 = FS.lookupNode(e, t);
      } catch (s4) {
        return s4.errno;
      }
      var o3 = FS.nodePermissions(e, "wx");
      if (o3)
        return o3;
      if (r2) {
        if (!FS.isDir(a2.mode))
          return 54;
        if (FS.isRoot(a2) || FS.getPath(a2) === FS.cwd())
          return 10;
      } else if (FS.isDir(a2.mode))
        return 31;
      return 0;
    }, mayOpen(e, t) {
      return e ? FS.isLink(e.mode) ? 32 : FS.isDir(e.mode) && (FS.flagsToPermissionString(t) !== "r" || t & 512) ? 31 : FS.nodePermissions(e, FS.flagsToPermissionString(t)) : 44;
    }, MAX_OPEN_FDS: 4096, nextfd() {
      for (var e = 0;e <= FS.MAX_OPEN_FDS; e++)
        if (!FS.streams[e])
          return e;
      throw new FS.ErrnoError(33);
    }, getStreamChecked(e) {
      var t = FS.getStream(e);
      if (!t)
        throw new FS.ErrnoError(8);
      return t;
    }, getStream: (e) => FS.streams[e], createStream(e, t = -1) {
      return e = Object.assign(new FS.FSStream, e), t == -1 && (t = FS.nextfd()), e.fd = t, FS.streams[t] = e, e;
    }, closeStream(e) {
      FS.streams[e] = null;
    }, dupStream(e, t = -1) {
      var r2 = FS.createStream(e, t);
      return r2.stream_ops?.dup?.(r2), r2;
    }, chrdev_stream_ops: { open(e) {
      var t = FS.getDevice(e.node.rdev);
      e.stream_ops = t.stream_ops, e.stream_ops.open?.(e);
    }, llseek() {
      throw new FS.ErrnoError(70);
    } }, major: (e) => e >> 8, minor: (e) => e & 255, makedev: (e, t) => e << 8 | t, registerDevice(e, t) {
      FS.devices[e] = { stream_ops: t };
    }, getDevice: (e) => FS.devices[e], getMounts(e) {
      for (var t = [], r2 = [e];r2.length; ) {
        var a2 = r2.pop();
        t.push(a2), r2.push(...a2.mounts);
      }
      return t;
    }, syncfs(e, t) {
      typeof e == "function" && (t = e, e = false), FS.syncFSRequests++, FS.syncFSRequests > 1 && err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      var r2 = FS.getMounts(FS.root.mount), a2 = 0;
      function o3(l4) {
        return FS.syncFSRequests--, t(l4);
      }
      function s4(l4) {
        if (l4)
          return s4.errored ? undefined : (s4.errored = true, o3(l4));
        ++a2 >= r2.length && o3(null);
      }
      r2.forEach((l4) => {
        if (!l4.type.syncfs)
          return s4(null);
        l4.type.syncfs(l4, e, s4);
      });
    }, mount(e, t, r2) {
      var a2 = r2 === "/", o3 = !r2, s4;
      if (a2 && FS.root)
        throw new FS.ErrnoError(10);
      if (!a2 && !o3) {
        var l4 = FS.lookupPath(r2, { follow_mount: false });
        if (r2 = l4.path, s4 = l4.node, FS.isMountpoint(s4))
          throw new FS.ErrnoError(10);
        if (!FS.isDir(s4.mode))
          throw new FS.ErrnoError(54);
      }
      var _3 = { type: e, opts: t, mountpoint: r2, mounts: [] }, n3 = e.mount(_3);
      return n3.mount = _3, _3.root = n3, a2 ? FS.root = n3 : s4 && (s4.mounted = _3, s4.mount && s4.mount.mounts.push(_3)), n3;
    }, unmount(e) {
      var t = FS.lookupPath(e, { follow_mount: false });
      if (!FS.isMountpoint(t.node))
        throw new FS.ErrnoError(28);
      var r2 = t.node, a2 = r2.mounted, o3 = FS.getMounts(a2);
      Object.keys(FS.nameTable).forEach((l4) => {
        for (var _3 = FS.nameTable[l4];_3; ) {
          var n3 = _3.name_next;
          o3.includes(_3.mount) && FS.destroyNode(_3), _3 = n3;
        }
      }), r2.mounted = null;
      var s4 = r2.mount.mounts.indexOf(a2);
      r2.mount.mounts.splice(s4, 1);
    }, lookup(e, t) {
      return e.node_ops.lookup(e, t);
    }, mknod(e, t, r2) {
      var a2 = FS.lookupPath(e, { parent: true }), o3 = a2.node, s4 = PATH.basename(e);
      if (!s4 || s4 === "." || s4 === "..")
        throw new FS.ErrnoError(28);
      var l4 = FS.mayCreate(o3, s4);
      if (l4)
        throw new FS.ErrnoError(l4);
      if (!o3.node_ops.mknod)
        throw new FS.ErrnoError(63);
      return o3.node_ops.mknod(o3, s4, t, r2);
    }, statfs(e) {
      var t = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 500000, bavail: 500000, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 }, r2 = FS.lookupPath(e, { follow: true }).node;
      return r2?.node_ops.statfs && Object.assign(t, r2.node_ops.statfs(r2.mount.opts.root)), t;
    }, create(e, t = 438) {
      return t &= 4095, t |= 32768, FS.mknod(e, t, 0);
    }, mkdir(e, t = 511) {
      return t &= 1023, t |= 16384, FS.mknod(e, t, 0);
    }, mkdirTree(e, t) {
      for (var r2 = e.split("/"), a2 = "", o3 = 0;o3 < r2.length; ++o3)
        if (r2[o3]) {
          a2 += "/" + r2[o3];
          try {
            FS.mkdir(a2, t);
          } catch (s4) {
            if (s4.errno != 20)
              throw s4;
          }
        }
    }, mkdev(e, t, r2) {
      return typeof r2 > "u" && (r2 = t, t = 438), t |= 8192, FS.mknod(e, t, r2);
    }, symlink(e, t) {
      if (!PATH_FS.resolve(e))
        throw new FS.ErrnoError(44);
      var r2 = FS.lookupPath(t, { parent: true }), a2 = r2.node;
      if (!a2)
        throw new FS.ErrnoError(44);
      var o3 = PATH.basename(t), s4 = FS.mayCreate(a2, o3);
      if (s4)
        throw new FS.ErrnoError(s4);
      if (!a2.node_ops.symlink)
        throw new FS.ErrnoError(63);
      return a2.node_ops.symlink(a2, o3, e);
    }, rename(e, t) {
      var r2 = PATH.dirname(e), a2 = PATH.dirname(t), o3 = PATH.basename(e), s4 = PATH.basename(t), l4, _3, n3;
      if (l4 = FS.lookupPath(e, { parent: true }), _3 = l4.node, l4 = FS.lookupPath(t, { parent: true }), n3 = l4.node, !_3 || !n3)
        throw new FS.ErrnoError(44);
      if (_3.mount !== n3.mount)
        throw new FS.ErrnoError(75);
      var m4 = FS.lookupNode(_3, o3), p3 = PATH_FS.relative(e, a2);
      if (p3.charAt(0) !== ".")
        throw new FS.ErrnoError(28);
      if (p3 = PATH_FS.relative(t, r2), p3.charAt(0) !== ".")
        throw new FS.ErrnoError(55);
      var d3;
      try {
        d3 = FS.lookupNode(n3, s4);
      } catch {}
      if (m4 !== d3) {
        var g5 = FS.isDir(m4.mode), u3 = FS.mayDelete(_3, o3, g5);
        if (u3)
          throw new FS.ErrnoError(u3);
        if (u3 = d3 ? FS.mayDelete(n3, s4, g5) : FS.mayCreate(n3, s4), u3)
          throw new FS.ErrnoError(u3);
        if (!_3.node_ops.rename)
          throw new FS.ErrnoError(63);
        if (FS.isMountpoint(m4) || d3 && FS.isMountpoint(d3))
          throw new FS.ErrnoError(10);
        if (n3 !== _3 && (u3 = FS.nodePermissions(_3, "w"), u3))
          throw new FS.ErrnoError(u3);
        FS.hashRemoveNode(m4);
        try {
          _3.node_ops.rename(m4, n3, s4), m4.parent = n3;
        } catch (f3) {
          throw f3;
        } finally {
          FS.hashAddNode(m4);
        }
      }
    }, rmdir(e) {
      var t = FS.lookupPath(e, { parent: true }), r2 = t.node, a2 = PATH.basename(e), o3 = FS.lookupNode(r2, a2), s4 = FS.mayDelete(r2, a2, true);
      if (s4)
        throw new FS.ErrnoError(s4);
      if (!r2.node_ops.rmdir)
        throw new FS.ErrnoError(63);
      if (FS.isMountpoint(o3))
        throw new FS.ErrnoError(10);
      r2.node_ops.rmdir(r2, a2), FS.destroyNode(o3);
    }, readdir(e) {
      var t = FS.lookupPath(e, { follow: true }), r2 = t.node;
      if (!r2.node_ops.readdir)
        throw new FS.ErrnoError(54);
      return r2.node_ops.readdir(r2);
    }, unlink(e) {
      var t = FS.lookupPath(e, { parent: true }), r2 = t.node;
      if (!r2)
        throw new FS.ErrnoError(44);
      var a2 = PATH.basename(e), o3 = FS.lookupNode(r2, a2), s4 = FS.mayDelete(r2, a2, false);
      if (s4)
        throw new FS.ErrnoError(s4);
      if (!r2.node_ops.unlink)
        throw new FS.ErrnoError(63);
      if (FS.isMountpoint(o3))
        throw new FS.ErrnoError(10);
      r2.node_ops.unlink(r2, a2), FS.destroyNode(o3);
    }, readlink(e) {
      var t = FS.lookupPath(e), r2 = t.node;
      if (!r2)
        throw new FS.ErrnoError(44);
      if (!r2.node_ops.readlink)
        throw new FS.ErrnoError(28);
      return r2.node_ops.readlink(r2);
    }, stat(e, t) {
      var r2 = FS.lookupPath(e, { follow: !t }), a2 = r2.node;
      if (!a2)
        throw new FS.ErrnoError(44);
      if (!a2.node_ops.getattr)
        throw new FS.ErrnoError(63);
      return a2.node_ops.getattr(a2);
    }, lstat(e) {
      return FS.stat(e, true);
    }, chmod(e, t, r2) {
      var a2;
      if (typeof e == "string") {
        var o3 = FS.lookupPath(e, { follow: !r2 });
        a2 = o3.node;
      } else
        a2 = e;
      if (!a2.node_ops.setattr)
        throw new FS.ErrnoError(63);
      a2.node_ops.setattr(a2, { mode: t & 4095 | a2.mode & -4096, ctime: Date.now() });
    }, lchmod(e, t) {
      FS.chmod(e, t, true);
    }, fchmod(e, t) {
      var r2 = FS.getStreamChecked(e);
      FS.chmod(r2.node, t);
    }, chown(e, t, r2, a2) {
      var o3;
      if (typeof e == "string") {
        var s4 = FS.lookupPath(e, { follow: !a2 });
        o3 = s4.node;
      } else
        o3 = e;
      if (!o3.node_ops.setattr)
        throw new FS.ErrnoError(63);
      o3.node_ops.setattr(o3, { timestamp: Date.now() });
    }, lchown(e, t, r2) {
      FS.chown(e, t, r2, true);
    }, fchown(e, t, r2) {
      var a2 = FS.getStreamChecked(e);
      FS.chown(a2.node, t, r2);
    }, truncate(e, t) {
      if (t < 0)
        throw new FS.ErrnoError(28);
      var r2;
      if (typeof e == "string") {
        var a2 = FS.lookupPath(e, { follow: true });
        r2 = a2.node;
      } else
        r2 = e;
      if (!r2.node_ops.setattr)
        throw new FS.ErrnoError(63);
      if (FS.isDir(r2.mode))
        throw new FS.ErrnoError(31);
      if (!FS.isFile(r2.mode))
        throw new FS.ErrnoError(28);
      var o3 = FS.nodePermissions(r2, "w");
      if (o3)
        throw new FS.ErrnoError(o3);
      r2.node_ops.setattr(r2, { size: t, timestamp: Date.now() });
    }, ftruncate(e, t) {
      var r2 = FS.getStreamChecked(e);
      if (!(r2.flags & 2097155))
        throw new FS.ErrnoError(28);
      FS.truncate(r2.node, t);
    }, utime(e, t, r2) {
      var a2 = FS.lookupPath(e, { follow: true }), o3 = a2.node;
      o3.node_ops.setattr(o3, { atime: t, mtime: r2 });
    }, open(e, t, r2 = 438) {
      if (e === "")
        throw new FS.ErrnoError(44);
      t = typeof t == "string" ? FS_modeStringToFlags(t) : t, t & 64 ? r2 = r2 & 4095 | 32768 : r2 = 0;
      var a2;
      if (typeof e == "object")
        a2 = e;
      else {
        var o3 = FS.lookupPath(e, { follow: !(t & 131072), noent_okay: true });
        a2 = o3.node, e = o3.path;
      }
      var s4 = false;
      if (t & 64)
        if (a2) {
          if (t & 128)
            throw new FS.ErrnoError(20);
        } else
          a2 = FS.mknod(e, r2, 0), s4 = true;
      if (!a2)
        throw new FS.ErrnoError(44);
      if (FS.isChrdev(a2.mode) && (t &= -513), t & 65536 && !FS.isDir(a2.mode))
        throw new FS.ErrnoError(54);
      if (!s4) {
        var l4 = FS.mayOpen(a2, t);
        if (l4)
          throw new FS.ErrnoError(l4);
      }
      t & 512 && !s4 && FS.truncate(a2, 0), t &= -131713;
      var _3 = FS.createStream({ node: a2, path: FS.getPath(a2), flags: t, seekable: true, position: 0, stream_ops: a2.stream_ops, ungotten: [], error: false });
      return _3.stream_ops.open && _3.stream_ops.open(_3), Module.logReadFiles && !(t & 1) && ((e in FS.readFiles) || (FS.readFiles[e] = 1)), _3;
    }, close(e) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      e.getdents && (e.getdents = null);
      try {
        e.stream_ops.close && e.stream_ops.close(e);
      } catch (t) {
        throw t;
      } finally {
        FS.closeStream(e.fd);
      }
      e.fd = null;
    }, isClosed(e) {
      return e.fd === null;
    }, llseek(e, t, r2) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (!e.seekable || !e.stream_ops.llseek)
        throw new FS.ErrnoError(70);
      if (r2 != 0 && r2 != 1 && r2 != 2)
        throw new FS.ErrnoError(28);
      return e.position = e.stream_ops.llseek(e, t, r2), e.ungotten = [], e.position;
    }, read(e, t, r2, a2, o3) {
      if (a2 < 0 || o3 < 0)
        throw new FS.ErrnoError(28);
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if ((e.flags & 2097155) === 1)
        throw new FS.ErrnoError(8);
      if (FS.isDir(e.node.mode))
        throw new FS.ErrnoError(31);
      if (!e.stream_ops.read)
        throw new FS.ErrnoError(28);
      var s4 = typeof o3 < "u";
      if (!s4)
        o3 = e.position;
      else if (!e.seekable)
        throw new FS.ErrnoError(70);
      var l4 = e.stream_ops.read(e, t, r2, a2, o3);
      return s4 || (e.position += l4), l4;
    }, write(e, t, r2, a2, o3, s4) {
      if (a2 < 0 || o3 < 0)
        throw new FS.ErrnoError(28);
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (!(e.flags & 2097155))
        throw new FS.ErrnoError(8);
      if (FS.isDir(e.node.mode))
        throw new FS.ErrnoError(31);
      if (!e.stream_ops.write)
        throw new FS.ErrnoError(28);
      e.seekable && e.flags & 1024 && FS.llseek(e, 0, 2);
      var l4 = typeof o3 < "u";
      if (!l4)
        o3 = e.position;
      else if (!e.seekable)
        throw new FS.ErrnoError(70);
      var _3 = e.stream_ops.write(e, t, r2, a2, o3, s4);
      return l4 || (e.position += _3), _3;
    }, allocate(e, t, r2) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (t < 0 || r2 <= 0)
        throw new FS.ErrnoError(28);
      if (!(e.flags & 2097155))
        throw new FS.ErrnoError(8);
      if (!FS.isFile(e.node.mode) && !FS.isDir(e.node.mode))
        throw new FS.ErrnoError(43);
      if (!e.stream_ops.allocate)
        throw new FS.ErrnoError(138);
      e.stream_ops.allocate(e, t, r2);
    }, mmap(e, t, r2, a2, o3) {
      if (a2 & 2 && !(o3 & 2) && (e.flags & 2097155) !== 2)
        throw new FS.ErrnoError(2);
      if ((e.flags & 2097155) === 1)
        throw new FS.ErrnoError(2);
      if (!e.stream_ops.mmap)
        throw new FS.ErrnoError(43);
      if (!t)
        throw new FS.ErrnoError(28);
      return e.stream_ops.mmap(e, t, r2, a2, o3);
    }, msync(e, t, r2, a2, o3) {
      return e.stream_ops.msync ? e.stream_ops.msync(e, t, r2, a2, o3) : 0;
    }, ioctl(e, t, r2) {
      if (!e.stream_ops.ioctl)
        throw new FS.ErrnoError(59);
      return e.stream_ops.ioctl(e, t, r2);
    }, readFile(e, t = {}) {
      if (t.flags = t.flags || 0, t.encoding = t.encoding || "binary", t.encoding !== "utf8" && t.encoding !== "binary")
        throw new Error(`Invalid encoding type "${t.encoding}"`);
      var r2, a2 = FS.open(e, t.flags), o3 = FS.stat(e), s4 = o3.size, l4 = new Uint8Array(s4);
      return FS.read(a2, l4, 0, s4, 0), t.encoding === "utf8" ? r2 = UTF8ArrayToString(l4) : t.encoding === "binary" && (r2 = l4), FS.close(a2), r2;
    }, writeFile(e, t, r2 = {}) {
      r2.flags = r2.flags || 577;
      var a2 = FS.open(e, r2.flags, r2.mode);
      if (typeof t == "string") {
        var o3 = new Uint8Array(lengthBytesUTF8(t) + 1), s4 = stringToUTF8Array(t, o3, 0, o3.length);
        FS.write(a2, o3, 0, s4, undefined, r2.canOwn);
      } else if (ArrayBuffer.isView(t))
        FS.write(a2, t, 0, t.byteLength, undefined, r2.canOwn);
      else
        throw new Error("Unsupported data type");
      FS.close(a2);
    }, cwd: () => FS.currentPath, chdir(e) {
      var t = FS.lookupPath(e, { follow: true });
      if (t.node === null)
        throw new FS.ErrnoError(44);
      if (!FS.isDir(t.node.mode))
        throw new FS.ErrnoError(54);
      var r2 = FS.nodePermissions(t.node, "x");
      if (r2)
        throw new FS.ErrnoError(r2);
      FS.currentPath = t.path;
    }, createDefaultDirectories() {
      FS.mkdir("/tmp"), FS.mkdir("/home"), FS.mkdir("/home/web_user");
    }, createDefaultDevices() {
      FS.mkdir("/dev"), FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (a2, o3, s4, l4, _3) => l4, llseek: () => 0 }), FS.mkdev("/dev/null", FS.makedev(1, 3)), TTY.register(FS.makedev(5, 0), TTY.default_tty_ops), TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops), FS.mkdev("/dev/tty", FS.makedev(5, 0)), FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var e = new Uint8Array(1024), t = 0, r2 = () => (t === 0 && (t = randomFill(e).byteLength), e[--t]);
      FS.createDevice("/dev", "random", r2), FS.createDevice("/dev", "urandom", r2), FS.mkdir("/dev/shm"), FS.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories() {
      FS.mkdir("/proc");
      var e = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd"), FS.mount({ mount() {
        var t = FS.createNode(e, "fd", 16895, 73);
        return t.stream_ops = { llseek: MEMFS.stream_ops.llseek }, t.node_ops = { lookup(r2, a2) {
          var o3 = +a2, s4 = FS.getStreamChecked(o3), l4 = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => s4.path }, id: o3 + 1 };
          return l4.parent = l4, l4;
        }, readdir() {
          return Array.from(FS.streams.entries()).filter(([r2, a2]) => a2).map(([r2, a2]) => r2.toString());
        } }, t;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams(e, t, r2) {
      e ? FS.createDevice("/dev", "stdin", e) : FS.symlink("/dev/tty", "/dev/stdin"), t ? FS.createDevice("/dev", "stdout", null, t) : FS.symlink("/dev/tty", "/dev/stdout"), r2 ? FS.createDevice("/dev", "stderr", null, r2) : FS.symlink("/dev/tty1", "/dev/stderr");
      var a2 = FS.open("/dev/stdin", 0), o3 = FS.open("/dev/stdout", 1), s4 = FS.open("/dev/stderr", 1);
    }, staticInit() {
      FS.nameTable = new Array(4096), FS.mount(MEMFS, {}, "/"), FS.createDefaultDirectories(), FS.createDefaultDevices(), FS.createSpecialDirectories(), FS.filesystems = { MEMFS, IDBFS, NODEFS };
    }, init(e, t, r2) {
      FS.initialized = true, e ?? (e = Module.stdin), t ?? (t = Module.stdout), r2 ?? (r2 = Module.stderr), FS.createStandardStreams(e, t, r2);
    }, quit() {
      FS.initialized = false, _fflush(0);
      for (var e = 0;e < FS.streams.length; e++) {
        var t = FS.streams[e];
        t && FS.close(t);
      }
    }, findObject(e, t) {
      var r2 = FS.analyzePath(e, t);
      return r2.exists ? r2.object : null;
    }, analyzePath(e, t) {
      try {
        var r2 = FS.lookupPath(e, { follow: !t });
        e = r2.path;
      } catch {}
      var a2 = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var r2 = FS.lookupPath(e, { parent: true });
        a2.parentExists = true, a2.parentPath = r2.path, a2.parentObject = r2.node, a2.name = PATH.basename(e), r2 = FS.lookupPath(e, { follow: !t }), a2.exists = true, a2.path = r2.path, a2.object = r2.node, a2.name = r2.node.name, a2.isRoot = r2.path === "/";
      } catch (o3) {
        a2.error = o3.errno;
      }
      return a2;
    }, createPath(e, t, r2, a2) {
      e = typeof e == "string" ? e : FS.getPath(e);
      for (var o3 = t.split("/").reverse();o3.length; ) {
        var s4 = o3.pop();
        if (s4) {
          var l4 = PATH.join2(e, s4);
          try {
            FS.mkdir(l4);
          } catch {}
          e = l4;
        }
      }
      return l4;
    }, createFile(e, t, r2, a2, o3) {
      var s4 = PATH.join2(typeof e == "string" ? e : FS.getPath(e), t), l4 = FS_getMode(a2, o3);
      return FS.create(s4, l4);
    }, createDataFile(e, t, r2, a2, o3, s4) {
      var l4 = t;
      e && (e = typeof e == "string" ? e : FS.getPath(e), l4 = t ? PATH.join2(e, t) : e);
      var _3 = FS_getMode(a2, o3), n3 = FS.create(l4, _3);
      if (r2) {
        if (typeof r2 == "string") {
          for (var m4 = new Array(r2.length), p3 = 0, d3 = r2.length;p3 < d3; ++p3)
            m4[p3] = r2.charCodeAt(p3);
          r2 = m4;
        }
        FS.chmod(n3, _3 | 146);
        var g5 = FS.open(n3, 577);
        FS.write(g5, r2, 0, r2.length, 0, s4), FS.close(g5), FS.chmod(n3, _3);
      }
    }, createDevice(e, t, r2, a2) {
      var _3;
      var o3 = PATH.join2(typeof e == "string" ? e : FS.getPath(e), t), s4 = FS_getMode(!!r2, !!a2);
      (_3 = FS.createDevice).major ?? (_3.major = 64);
      var l4 = FS.makedev(FS.createDevice.major++, 0);
      return FS.registerDevice(l4, { open(n3) {
        n3.seekable = false;
      }, close(n3) {
        a2?.buffer?.length && a2(10);
      }, read(n3, m4, p3, d3, g5) {
        for (var u3 = 0, f3 = 0;f3 < d3; f3++) {
          var c2;
          try {
            c2 = r2();
          } catch {
            throw new FS.ErrnoError(29);
          }
          if (c2 === undefined && u3 === 0)
            throw new FS.ErrnoError(6);
          if (c2 == null)
            break;
          u3++, m4[p3 + f3] = c2;
        }
        return u3 && (n3.node.atime = Date.now()), u3;
      }, write(n3, m4, p3, d3, g5) {
        for (var u3 = 0;u3 < d3; u3++)
          try {
            a2(m4[p3 + u3]);
          } catch {
            throw new FS.ErrnoError(29);
          }
        return d3 && (n3.node.mtime = n3.node.ctime = Date.now()), u3;
      } }), FS.mkdev(o3, s4, l4);
    }, forceLoadFile(e) {
      if (e.isDevice || e.isFolder || e.link || e.contents)
        return true;
      if (typeof XMLHttpRequest < "u")
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      try {
        e.contents = readBinary(e.url), e.usedBytes = e.contents.length;
      } catch {
        throw new FS.ErrnoError(29);
      }
    }, createLazyFile(e, t, r2, a2, o3) {

      class s4 {
        constructor() {
          P(this, "lengthKnown", false);
          P(this, "chunks", []);
        }
        get(u3) {
          if (!(u3 > this.length - 1 || u3 < 0)) {
            var f3 = u3 % this.chunkSize, c2 = u3 / this.chunkSize | 0;
            return this.getter(c2)[f3];
          }
        }
        setDataGetter(u3) {
          this.getter = u3;
        }
        cacheLength() {
          var u3 = new XMLHttpRequest;
          if (u3.open("HEAD", r2, false), u3.send(null), !(u3.status >= 200 && u3.status < 300 || u3.status === 304))
            throw new Error("Couldn't load " + r2 + ". Status: " + u3.status);
          var f3 = Number(u3.getResponseHeader("Content-length")), c2, w4 = (c2 = u3.getResponseHeader("Accept-Ranges")) && c2 === "bytes", h3 = (c2 = u3.getResponseHeader("Content-Encoding")) && c2 === "gzip", v3 = 1048576;
          w4 || (v3 = f3);
          var x5 = (M3, E3) => {
            if (M3 > E3)
              throw new Error("invalid range (" + M3 + ", " + E3 + ") or no bytes requested!");
            if (E3 > f3 - 1)
              throw new Error("only " + f3 + " bytes available! programmer error!");
            var b4 = new XMLHttpRequest;
            if (b4.open("GET", r2, false), f3 !== v3 && b4.setRequestHeader("Range", "bytes=" + M3 + "-" + E3), b4.responseType = "arraybuffer", b4.overrideMimeType && b4.overrideMimeType("text/plain; charset=x-user-defined"), b4.send(null), !(b4.status >= 200 && b4.status < 300 || b4.status === 304))
              throw new Error("Couldn't load " + r2 + ". Status: " + b4.status);
            return b4.response !== undefined ? new Uint8Array(b4.response || []) : intArrayFromString(b4.responseText || "", true);
          }, y3 = this;
          y3.setDataGetter((M3) => {
            var E3 = M3 * v3, b4 = (M3 + 1) * v3 - 1;
            if (b4 = Math.min(b4, f3 - 1), typeof y3.chunks[M3] > "u" && (y3.chunks[M3] = x5(E3, b4)), typeof y3.chunks[M3] > "u")
              throw new Error("doXHR failed!");
            return y3.chunks[M3];
          }), (h3 || !f3) && (v3 = f3 = 1, f3 = this.getter(0).length, v3 = f3, out("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = f3, this._chunkSize = v3, this.lengthKnown = true;
        }
        get length() {
          return this.lengthKnown || this.cacheLength(), this._length;
        }
        get chunkSize() {
          return this.lengthKnown || this.cacheLength(), this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest < "u") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var l4 = new s4, _3 = { isDevice: false, contents: l4 };
      } else
        var _3 = { isDevice: false, url: r2 };
      var n3 = FS.createFile(e, t, _3, a2, o3);
      _3.contents ? n3.contents = _3.contents : _3.url && (n3.contents = null, n3.url = _3.url), Object.defineProperties(n3, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var m4 = {}, p3 = Object.keys(n3.stream_ops);
      p3.forEach((g5) => {
        var u3 = n3.stream_ops[g5];
        m4[g5] = (...f3) => (FS.forceLoadFile(n3), u3(...f3));
      });
      function d3(g5, u3, f3, c2, w4) {
        var h3 = g5.node.contents;
        if (w4 >= h3.length)
          return 0;
        var v3 = Math.min(h3.length - w4, c2);
        if (h3.slice)
          for (var x5 = 0;x5 < v3; x5++)
            u3[f3 + x5] = h3[w4 + x5];
        else
          for (var x5 = 0;x5 < v3; x5++)
            u3[f3 + x5] = h3.get(w4 + x5);
        return v3;
      }
      return m4.read = (g5, u3, f3, c2, w4) => (FS.forceLoadFile(n3), d3(g5, u3, f3, c2, w4)), m4.mmap = (g5, u3, f3, c2, w4) => {
        FS.forceLoadFile(n3);
        var h3 = mmapAlloc(u3);
        if (!h3)
          throw new FS.ErrnoError(48);
        return d3(g5, HEAP8, h3, u3, f3), { ptr: h3, allocated: true };
      }, n3.stream_ops = m4, n3;
    } }, SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(e, t, r2) {
      if (PATH.isAbs(t))
        return t;
      var a2;
      if (e === -100)
        a2 = FS.cwd();
      else {
        var o3 = SYSCALLS.getStreamFromFD(e);
        a2 = o3.path;
      }
      if (t.length == 0) {
        if (!r2)
          throw new FS.ErrnoError(44);
        return a2;
      }
      return a2 + "/" + t;
    }, doStat(e, t, r2) {
      var a2 = e(t);
      HEAP32[r2 >> 2] = a2.dev, HEAP32[r2 + 4 >> 2] = a2.mode, HEAPU32[r2 + 8 >> 2] = a2.nlink, HEAP32[r2 + 12 >> 2] = a2.uid, HEAP32[r2 + 16 >> 2] = a2.gid, HEAP32[r2 + 20 >> 2] = a2.rdev, HEAP64[r2 + 24 >> 3] = BigInt(a2.size), HEAP32[r2 + 32 >> 2] = 4096, HEAP32[r2 + 36 >> 2] = a2.blocks;
      var o3 = a2.atime.getTime(), s4 = a2.mtime.getTime(), l4 = a2.ctime.getTime();
      return HEAP64[r2 + 40 >> 3] = BigInt(Math.floor(o3 / 1000)), HEAPU32[r2 + 48 >> 2] = o3 % 1000 * 1000 * 1000, HEAP64[r2 + 56 >> 3] = BigInt(Math.floor(s4 / 1000)), HEAPU32[r2 + 64 >> 2] = s4 % 1000 * 1000 * 1000, HEAP64[r2 + 72 >> 3] = BigInt(Math.floor(l4 / 1000)), HEAPU32[r2 + 80 >> 2] = l4 % 1000 * 1000 * 1000, HEAP64[r2 + 88 >> 3] = BigInt(a2.ino), 0;
    }, doMsync(e, t, r2, a2, o3) {
      if (!FS.isFile(t.node.mode))
        throw new FS.ErrnoError(43);
      if (a2 & 2)
        return 0;
      var s4 = HEAPU8.slice(e, e + r2);
      FS.msync(t, s4, o3, r2, a2);
    }, getStreamFromFD(e) {
      var t = FS.getStreamChecked(e);
      return t;
    }, varargs: undefined, getStr(e) {
      var t = UTF8ToString(e);
      return t;
    } }, ___syscall__newselect = function(e, t, r2, a2, o3) {
      try {
        for (var s4 = 0, l4 = t ? HEAP32[t >> 2] : 0, _3 = t ? HEAP32[t + 4 >> 2] : 0, n3 = r2 ? HEAP32[r2 >> 2] : 0, m4 = r2 ? HEAP32[r2 + 4 >> 2] : 0, p3 = a2 ? HEAP32[a2 >> 2] : 0, d3 = a2 ? HEAP32[a2 + 4 >> 2] : 0, g5 = 0, u3 = 0, f3 = 0, c2 = 0, w4 = 0, h3 = 0, v3 = (t ? HEAP32[t >> 2] : 0) | (r2 ? HEAP32[r2 >> 2] : 0) | (a2 ? HEAP32[a2 >> 2] : 0), x5 = (t ? HEAP32[t + 4 >> 2] : 0) | (r2 ? HEAP32[r2 + 4 >> 2] : 0) | (a2 ? HEAP32[a2 + 4 >> 2] : 0), y3 = (N2, P4, R4, k3) => N2 < 32 ? P4 & k3 : R4 & k3, M3 = 0;M3 < e; M3++) {
          var E3 = 1 << M3 % 32;
          if (y3(M3, v3, x5, E3)) {
            var b4 = SYSCALLS.getStreamFromFD(M3), U3 = SYSCALLS.DEFAULT_POLLMASK;
            if (b4.stream_ops.poll) {
              var z3 = -1;
              if (o3) {
                var W3 = t ? HEAP32[o3 >> 2] : 0, D4 = t ? HEAP32[o3 + 4 >> 2] : 0;
                z3 = (W3 + D4 / 1e6) * 1000;
              }
              U3 = b4.stream_ops.poll(b4, z3);
            }
            U3 & 1 && y3(M3, l4, _3, E3) && (M3 < 32 ? g5 = g5 | E3 : u3 = u3 | E3, s4++), U3 & 4 && y3(M3, n3, m4, E3) && (M3 < 32 ? f3 = f3 | E3 : c2 = c2 | E3, s4++), U3 & 2 && y3(M3, p3, d3, E3) && (M3 < 32 ? w4 = w4 | E3 : h3 = h3 | E3, s4++);
          }
        }
        return t && (HEAP32[t >> 2] = g5, HEAP32[t + 4 >> 2] = u3), r2 && (HEAP32[r2 >> 2] = f3, HEAP32[r2 + 4 >> 2] = c2), a2 && (HEAP32[a2 >> 2] = w4, HEAP32[a2 + 4 >> 2] = h3), s4;
      } catch (N2) {
        if (typeof FS > "u" || N2.name !== "ErrnoError")
          throw N2;
        return -N2.errno;
      }
    };
    ___syscall__newselect.sig = "iipppp";
    var SOCKFS = { websocketArgs: {}, callbacks: {}, on(e, t) {
      SOCKFS.callbacks[e] = t;
    }, emit(e, t) {
      SOCKFS.callbacks[e]?.(t);
    }, mount(e) {
      return SOCKFS.websocketArgs = Module.websocket || {}, (Module.websocket ?? (Module.websocket = {})).on = SOCKFS.on, FS.createNode(null, "/", 16895, 0);
    }, createSocket(e, t, r2) {
      t &= -526337;
      var a2 = t == 1;
      if (a2 && r2 && r2 != 6)
        throw new FS.ErrnoError(66);
      var o3 = { family: e, type: t, protocol: r2, server: null, error: null, peers: {}, pending: [], recv_queue: [], sock_ops: SOCKFS.websocket_sock_ops }, s4 = SOCKFS.nextname(), l4 = FS.createNode(SOCKFS.root, s4, 49152, 0);
      l4.sock = o3;
      var _3 = FS.createStream({ path: s4, node: l4, flags: 2, seekable: false, stream_ops: SOCKFS.stream_ops });
      return o3.stream = _3, o3;
    }, getSocket(e) {
      var t = FS.getStream(e);
      return !t || !FS.isSocket(t.node.mode) ? null : t.node.sock;
    }, stream_ops: { poll(e) {
      var t = e.node.sock;
      return t.sock_ops.poll(t);
    }, ioctl(e, t, r2) {
      var a2 = e.node.sock;
      return a2.sock_ops.ioctl(a2, t, r2);
    }, read(e, t, r2, a2, o3) {
      var s4 = e.node.sock, l4 = s4.sock_ops.recvmsg(s4, a2);
      return l4 ? (t.set(l4.buffer, r2), l4.buffer.length) : 0;
    }, write(e, t, r2, a2, o3) {
      var s4 = e.node.sock;
      return s4.sock_ops.sendmsg(s4, t, r2, a2);
    }, close(e) {
      var t = e.node.sock;
      t.sock_ops.close(t);
    } }, nextname() {
      return SOCKFS.nextname.current || (SOCKFS.nextname.current = 0), `socket[${SOCKFS.nextname.current++}]`;
    }, websocket_sock_ops: { createPeer(e, t, r2) {
      var a2;
      if (typeof t == "object" && (a2 = t, t = null, r2 = null), a2)
        if (a2._socket)
          t = a2._socket.remoteAddress, r2 = a2._socket.remotePort;
        else {
          var o3 = /ws[s]?:\/\/([^:]+):(\d+)/.exec(a2.url);
          if (!o3)
            throw new Error("WebSocket URL must be in the format ws(s)://address:port");
          t = o3[1], r2 = parseInt(o3[2], 10);
        }
      else
        try {
          var s4 = "ws:#".replace("#", "//"), l4 = "binary", _3 = undefined;
          if (SOCKFS.websocketArgs.url && (s4 = SOCKFS.websocketArgs.url), SOCKFS.websocketArgs.subprotocol ? l4 = SOCKFS.websocketArgs.subprotocol : SOCKFS.websocketArgs.subprotocol === null && (l4 = "null"), s4 === "ws://" || s4 === "wss://") {
            var n3 = t.split("/");
            s4 = s4 + n3[0] + ":" + r2 + "/" + n3.slice(1).join("/");
          }
          l4 !== "null" && (l4 = l4.replace(/^ +| +$/g, "").split(/ *, */), _3 = l4);
          var m4;
          ENVIRONMENT_IS_NODE ? m4 = require("ws") : m4 = WebSocket, a2 = new m4(s4, _3), a2.binaryType = "arraybuffer";
        } catch {
          throw new FS.ErrnoError(23);
        }
      var p3 = { addr: t, port: r2, socket: a2, msg_send_queue: [] };
      return SOCKFS.websocket_sock_ops.addPeer(e, p3), SOCKFS.websocket_sock_ops.handlePeerEvents(e, p3), e.type === 2 && typeof e.sport < "u" && p3.msg_send_queue.push(new Uint8Array([255, 255, 255, 255, 112, 111, 114, 116, (e.sport & 65280) >> 8, e.sport & 255])), p3;
    }, getPeer(e, t, r2) {
      return e.peers[t + ":" + r2];
    }, addPeer(e, t) {
      e.peers[t.addr + ":" + t.port] = t;
    }, removePeer(e, t) {
      delete e.peers[t.addr + ":" + t.port];
    }, handlePeerEvents(e, t) {
      var r2 = true, a2 = function() {
        e.connecting = false, SOCKFS.emit("open", e.stream.fd);
        try {
          for (var s4 = t.msg_send_queue.shift();s4; )
            t.socket.send(s4), s4 = t.msg_send_queue.shift();
        } catch {
          t.socket.close();
        }
      };
      function o3(s4) {
        if (typeof s4 == "string") {
          var l4 = new TextEncoder;
          s4 = l4.encode(s4);
        } else {
          if (assert(s4.byteLength !== undefined), s4.byteLength == 0)
            return;
          s4 = new Uint8Array(s4);
        }
        var _3 = r2;
        if (r2 = false, _3 && s4.length === 10 && s4[0] === 255 && s4[1] === 255 && s4[2] === 255 && s4[3] === 255 && s4[4] === 112 && s4[5] === 111 && s4[6] === 114 && s4[7] === 116) {
          var n3 = s4[8] << 8 | s4[9];
          SOCKFS.websocket_sock_ops.removePeer(e, t), t.port = n3, SOCKFS.websocket_sock_ops.addPeer(e, t);
          return;
        }
        e.recv_queue.push({ addr: t.addr, port: t.port, data: s4 }), SOCKFS.emit("message", e.stream.fd);
      }
      ENVIRONMENT_IS_NODE ? (t.socket.on("open", a2), t.socket.on("message", function(s4, l4) {
        l4 && o3(new Uint8Array(s4).buffer);
      }), t.socket.on("close", function() {
        SOCKFS.emit("close", e.stream.fd);
      }), t.socket.on("error", function(s4) {
        e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]);
      })) : (t.socket.onopen = a2, t.socket.onclose = function() {
        SOCKFS.emit("close", e.stream.fd);
      }, t.socket.onmessage = function(l4) {
        o3(l4.data);
      }, t.socket.onerror = function(s4) {
        e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]);
      });
    }, poll(e) {
      if (e.type === 1 && e.server)
        return e.pending.length ? 65 : 0;
      var t = 0, r2 = e.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport) : null;
      return (e.recv_queue.length || !r2 || r2 && r2.socket.readyState === r2.socket.CLOSING || r2 && r2.socket.readyState === r2.socket.CLOSED) && (t |= 65), (!r2 || r2 && r2.socket.readyState === r2.socket.OPEN) && (t |= 4), (r2 && r2.socket.readyState === r2.socket.CLOSING || r2 && r2.socket.readyState === r2.socket.CLOSED) && (e.connecting ? t |= 4 : t |= 16), t;
    }, ioctl(e, t, r2) {
      switch (t) {
        case 21531:
          var a2 = 0;
          return e.recv_queue.length && (a2 = e.recv_queue[0].data.length), HEAP32[r2 >> 2] = a2, 0;
        default:
          return 28;
      }
    }, close(e) {
      if (e.server) {
        try {
          e.server.close();
        } catch {}
        e.server = null;
      }
      for (var t = Object.keys(e.peers), r2 = 0;r2 < t.length; r2++) {
        var a2 = e.peers[t[r2]];
        try {
          a2.socket.close();
        } catch {}
        SOCKFS.websocket_sock_ops.removePeer(e, a2);
      }
      return 0;
    }, bind(e, t, r2) {
      if (typeof e.saddr < "u" || typeof e.sport < "u")
        throw new FS.ErrnoError(28);
      if (e.saddr = t, e.sport = r2, e.type === 2) {
        e.server && (e.server.close(), e.server = null);
        try {
          e.sock_ops.listen(e, 0);
        } catch (a2) {
          if (a2.name !== "ErrnoError" || a2.errno !== 138)
            throw a2;
        }
      }
    }, connect(e, t, r2) {
      if (e.server)
        throw new FS.ErrnoError(138);
      if (typeof e.daddr < "u" && typeof e.dport < "u") {
        var a2 = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport);
        if (a2)
          throw a2.socket.readyState === a2.socket.CONNECTING ? new FS.ErrnoError(7) : new FS.ErrnoError(30);
      }
      var o3 = SOCKFS.websocket_sock_ops.createPeer(e, t, r2);
      e.daddr = o3.addr, e.dport = o3.port, e.connecting = true;
    }, listen(e, t) {
      if (!ENVIRONMENT_IS_NODE)
        throw new FS.ErrnoError(138);
      if (e.server)
        throw new FS.ErrnoError(28);
      var r2 = require("ws").Server, a2 = e.saddr;
      e.server = new r2({ host: a2, port: e.sport }), SOCKFS.emit("listen", e.stream.fd), e.server.on("connection", function(o3) {
        if (e.type === 1) {
          var s4 = SOCKFS.createSocket(e.family, e.type, e.protocol), l4 = SOCKFS.websocket_sock_ops.createPeer(s4, o3);
          s4.daddr = l4.addr, s4.dport = l4.port, e.pending.push(s4), SOCKFS.emit("connection", s4.stream.fd);
        } else
          SOCKFS.websocket_sock_ops.createPeer(e, o3), SOCKFS.emit("connection", e.stream.fd);
      }), e.server.on("close", function() {
        SOCKFS.emit("close", e.stream.fd), e.server = null;
      }), e.server.on("error", function(o3) {
        e.error = 23, SOCKFS.emit("error", [e.stream.fd, e.error, "EHOSTUNREACH: Host is unreachable"]);
      });
    }, accept(e) {
      if (!e.server || !e.pending.length)
        throw new FS.ErrnoError(28);
      var t = e.pending.shift();
      return t.stream.flags = e.stream.flags, t;
    }, getname(e, t) {
      var r2, a2;
      if (t) {
        if (e.daddr === undefined || e.dport === undefined)
          throw new FS.ErrnoError(53);
        r2 = e.daddr, a2 = e.dport;
      } else
        r2 = e.saddr || 0, a2 = e.sport || 0;
      return { addr: r2, port: a2 };
    }, sendmsg(e, t, r2, a2, o3, s4) {
      if (e.type === 2) {
        if ((o3 === undefined || s4 === undefined) && (o3 = e.daddr, s4 = e.dport), o3 === undefined || s4 === undefined)
          throw new FS.ErrnoError(17);
      } else
        o3 = e.daddr, s4 = e.dport;
      var l4 = SOCKFS.websocket_sock_ops.getPeer(e, o3, s4);
      if (e.type === 1 && (!l4 || l4.socket.readyState === l4.socket.CLOSING || l4.socket.readyState === l4.socket.CLOSED))
        throw new FS.ErrnoError(53);
      ArrayBuffer.isView(t) && (r2 += t.byteOffset, t = t.buffer);
      var _3 = t.slice(r2, r2 + a2);
      if (!l4 || l4.socket.readyState !== l4.socket.OPEN)
        return e.type === 2 && (!l4 || l4.socket.readyState === l4.socket.CLOSING || l4.socket.readyState === l4.socket.CLOSED) && (l4 = SOCKFS.websocket_sock_ops.createPeer(e, o3, s4)), l4.msg_send_queue.push(_3), a2;
      try {
        return l4.socket.send(_3), a2;
      } catch {
        throw new FS.ErrnoError(28);
      }
    }, recvmsg(e, t) {
      if (e.type === 1 && e.server)
        throw new FS.ErrnoError(53);
      var r2 = e.recv_queue.shift();
      if (!r2) {
        if (e.type === 1) {
          var a2 = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport);
          if (!a2)
            throw new FS.ErrnoError(53);
          if (a2.socket.readyState === a2.socket.CLOSING || a2.socket.readyState === a2.socket.CLOSED)
            return null;
          throw new FS.ErrnoError(6);
        }
        throw new FS.ErrnoError(6);
      }
      var o3 = r2.data.byteLength || r2.data.length, s4 = r2.data.byteOffset || 0, l4 = r2.data.buffer || r2.data, _3 = Math.min(t, o3), n3 = { buffer: new Uint8Array(l4, s4, _3), addr: r2.addr, port: r2.port };
      if (e.type === 1 && _3 < o3) {
        var m4 = o3 - _3;
        r2.data = new Uint8Array(l4, s4 + _3, m4), e.recv_queue.unshift(r2);
      }
      return n3;
    } } }, getSocketFromFD = (e) => {
      var t = SOCKFS.getSocket(e);
      if (!t)
        throw new FS.ErrnoError(8);
      return t;
    }, inetNtop4 = (e) => (e & 255) + "." + (e >> 8 & 255) + "." + (e >> 16 & 255) + "." + (e >> 24 & 255), inetNtop6 = (e) => {
      var t = "", r2 = 0, a2 = 0, o3 = 0, s4 = 0, l4 = 0, _3 = 0, n3 = [e[0] & 65535, e[0] >> 16, e[1] & 65535, e[1] >> 16, e[2] & 65535, e[2] >> 16, e[3] & 65535, e[3] >> 16], m4 = true, p3 = "";
      for (_3 = 0;_3 < 5; _3++)
        if (n3[_3] !== 0) {
          m4 = false;
          break;
        }
      if (m4) {
        if (p3 = inetNtop4(n3[6] | n3[7] << 16), n3[5] === -1)
          return t = "::ffff:", t += p3, t;
        if (n3[5] === 0)
          return t = "::", p3 === "0.0.0.0" && (p3 = ""), p3 === "0.0.0.1" && (p3 = "1"), t += p3, t;
      }
      for (r2 = 0;r2 < 8; r2++)
        n3[r2] === 0 && (r2 - o3 > 1 && (l4 = 0), o3 = r2, l4++), l4 > a2 && (a2 = l4, s4 = r2 - a2 + 1);
      for (r2 = 0;r2 < 8; r2++) {
        if (a2 > 1 && n3[r2] === 0 && r2 >= s4 && r2 < s4 + a2) {
          r2 === s4 && (t += ":", s4 === 0 && (t += ":"));
          continue;
        }
        t += Number(_ntohs(n3[r2] & 65535)).toString(16), t += r2 < 7 ? ":" : "";
      }
      return t;
    }, readSockaddr = (e, t) => {
      var r2 = HEAP16[e >> 1], a2 = _ntohs(HEAPU16[e + 2 >> 1]), o3;
      switch (r2) {
        case 2:
          if (t !== 16)
            return { errno: 28 };
          o3 = HEAP32[e + 4 >> 2], o3 = inetNtop4(o3);
          break;
        case 10:
          if (t !== 28)
            return { errno: 28 };
          o3 = [HEAP32[e + 8 >> 2], HEAP32[e + 12 >> 2], HEAP32[e + 16 >> 2], HEAP32[e + 20 >> 2]], o3 = inetNtop6(o3);
          break;
        default:
          return { errno: 5 };
      }
      return { family: r2, addr: o3, port: a2 };
    }, inetPton4 = (e) => {
      for (var t = e.split("."), r2 = 0;r2 < 4; r2++) {
        var a2 = Number(t[r2]);
        if (isNaN(a2))
          return null;
        t[r2] = a2;
      }
      return (t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24) >>> 0;
    }, jstoi_q = (e) => parseInt(e), inetPton6 = (e) => {
      var t, r2, a2, o3, s4 = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i, l4 = [];
      if (!s4.test(e))
        return null;
      if (e === "::")
        return [0, 0, 0, 0, 0, 0, 0, 0];
      for (e.startsWith("::") ? e = e.replace("::", "Z:") : e = e.replace("::", ":Z:"), e.indexOf(".") > 0 ? (e = e.replace(new RegExp("[.]", "g"), ":"), t = e.split(":"), t[t.length - 4] = jstoi_q(t[t.length - 4]) + jstoi_q(t[t.length - 3]) * 256, t[t.length - 3] = jstoi_q(t[t.length - 2]) + jstoi_q(t[t.length - 1]) * 256, t = t.slice(0, t.length - 2)) : t = e.split(":"), a2 = 0, o3 = 0, r2 = 0;r2 < t.length; r2++)
        if (typeof t[r2] == "string")
          if (t[r2] === "Z") {
            for (o3 = 0;o3 < 8 - t.length + 1; o3++)
              l4[r2 + o3] = 0;
            a2 = o3 - 1;
          } else
            l4[r2 + a2] = _htons(parseInt(t[r2], 16));
        else
          l4[r2 + a2] = t[r2];
      return [l4[1] << 16 | l4[0], l4[3] << 16 | l4[2], l4[5] << 16 | l4[4], l4[7] << 16 | l4[6]];
    }, DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name(e) {
      var t = inetPton4(e);
      if (t !== null || (t = inetPton6(e), t !== null))
        return e;
      var r2;
      if (DNS.address_map.addrs[e])
        r2 = DNS.address_map.addrs[e];
      else {
        var a2 = DNS.address_map.id++;
        assert(a2 < 65535, "exceeded max address mappings of 65535"), r2 = "172.29." + (a2 & 255) + "." + (a2 & 65280), DNS.address_map.names[r2] = e, DNS.address_map.addrs[e] = r2;
      }
      return r2;
    }, lookup_addr(e) {
      return DNS.address_map.names[e] ? DNS.address_map.names[e] : null;
    } }, getSocketAddress = (e, t) => {
      var r2 = readSockaddr(e, t);
      if (r2.errno)
        throw new FS.ErrnoError(r2.errno);
      return r2.addr = DNS.lookup_addr(r2.addr) || r2.addr, r2;
    };
    function ___syscall_bind(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e), _3 = getSocketAddress(t, r2);
        return l4.sock_ops.bind(l4, _3.addr, _3.port), 0;
      } catch (n3) {
        if (typeof FS > "u" || n3.name !== "ErrnoError")
          throw n3;
        return -n3.errno;
      }
    }
    ___syscall_bind.sig = "iippiii";
    function ___syscall_chdir(e) {
      try {
        return e = SYSCALLS.getStr(e), FS.chdir(e), 0;
      } catch (t) {
        if (typeof FS > "u" || t.name !== "ErrnoError")
          throw t;
        return -t.errno;
      }
    }
    ___syscall_chdir.sig = "ip";
    function ___syscall_chmod(e, t) {
      try {
        return e = SYSCALLS.getStr(e), FS.chmod(e, t), 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_chmod.sig = "ipi";
    function ___syscall_connect(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e), _3 = getSocketAddress(t, r2);
        return l4.sock_ops.connect(l4, _3.addr, _3.port), 0;
      } catch (n3) {
        if (typeof FS > "u" || n3.name !== "ErrnoError")
          throw n3;
        return -n3.errno;
      }
    }
    ___syscall_connect.sig = "iippiii";
    function ___syscall_dup(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return FS.dupStream(t).fd;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_dup.sig = "ii";
    function ___syscall_dup3(e, t, r2) {
      try {
        var a2 = SYSCALLS.getStreamFromFD(e);
        if (a2.fd === t)
          return -28;
        if (t < 0 || t >= FS.MAX_OPEN_FDS)
          return -8;
        var o3 = FS.getStream(t);
        return o3 && FS.close(o3), FS.dupStream(a2, t).fd;
      } catch (s4) {
        if (typeof FS > "u" || s4.name !== "ErrnoError")
          throw s4;
        return -s4.errno;
      }
    }
    ___syscall_dup3.sig = "iiii";
    function ___syscall_faccessat(e, t, r2, a2) {
      try {
        if (t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), r2 & -8)
          return -28;
        var o3 = FS.lookupPath(t, { follow: true }), s4 = o3.node;
        if (!s4)
          return -44;
        var l4 = "";
        return r2 & 4 && (l4 += "r"), r2 & 2 && (l4 += "w"), r2 & 1 && (l4 += "x"), l4 && FS.nodePermissions(s4, l4) ? -2 : 0;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return -_3.errno;
      }
    }
    ___syscall_faccessat.sig = "iipii";
    var ___syscall_fadvise64 = (e, t, r2, a2) => 0;
    ___syscall_fadvise64.sig = "iijji";
    var INT53_MAX = 9007199254740992, INT53_MIN = -9007199254740992, bigintToI53Checked = (e) => e < INT53_MIN || e > INT53_MAX ? NaN : Number(e);
    function ___syscall_fallocate(e, t, r2, a2) {
      r2 = bigintToI53Checked(r2), a2 = bigintToI53Checked(a2);
      try {
        if (isNaN(r2))
          return 61;
        var o3 = SYSCALLS.getStreamFromFD(e);
        return FS.allocate(o3, r2, a2), 0;
      } catch (s4) {
        if (typeof FS > "u" || s4.name !== "ErrnoError")
          throw s4;
        return -s4.errno;
      }
    }
    ___syscall_fallocate.sig = "iiijj";
    var syscallGetVarargI = () => {
      var e = HEAP32[+SYSCALLS.varargs >> 2];
      return SYSCALLS.varargs += 4, e;
    }, syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(e, t, r2) {
      SYSCALLS.varargs = r2;
      try {
        var a2 = SYSCALLS.getStreamFromFD(e);
        switch (t) {
          case 0: {
            var o3 = syscallGetVarargI();
            if (o3 < 0)
              return -28;
            for (;FS.streams[o3]; )
              o3++;
            var s4;
            return s4 = FS.dupStream(a2, o3), s4.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return a2.flags;
          case 4: {
            var o3 = syscallGetVarargI();
            return a2.flags |= o3, 0;
          }
          case 12: {
            var o3 = syscallGetVarargP(), l4 = 0;
            return HEAP16[o3 + l4 >> 1] = 2, 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return -_3.errno;
      }
    }
    ___syscall_fcntl64.sig = "iiip";
    function ___syscall_fdatasync(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_fdatasync.sig = "ii";
    function ___syscall_fstat64(e, t) {
      try {
        var r2 = SYSCALLS.getStreamFromFD(e);
        return SYSCALLS.doStat(FS.stat, r2.path, t);
      } catch (a2) {
        if (typeof FS > "u" || a2.name !== "ErrnoError")
          throw a2;
        return -a2.errno;
      }
    }
    ___syscall_fstat64.sig = "iip";
    function ___syscall_ftruncate64(e, t) {
      t = bigintToI53Checked(t);
      try {
        return isNaN(t) ? 61 : (FS.ftruncate(e, t), 0);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_ftruncate64.sig = "iij";
    var stringToUTF8 = (e, t, r2) => stringToUTF8Array(e, HEAPU8, t, r2);
    function ___syscall_getcwd(e, t) {
      try {
        if (t === 0)
          return -28;
        var r2 = FS.cwd(), a2 = lengthBytesUTF8(r2) + 1;
        return t < a2 ? -68 : (stringToUTF8(r2, e, t), a2);
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_getcwd.sig = "ipp";
    function ___syscall_getdents64(e, t, r2) {
      try {
        var a2 = SYSCALLS.getStreamFromFD(e);
        a2.getdents || (a2.getdents = FS.readdir(a2.path));
        for (var o3 = 280, s4 = 0, l4 = FS.llseek(a2, 0, 1), _3 = Math.floor(l4 / o3), n3 = Math.min(a2.getdents.length, _3 + Math.floor(r2 / o3)), m4 = _3;m4 < n3; m4++) {
          var p3, d3, g5 = a2.getdents[m4];
          if (g5 === ".")
            p3 = a2.node.id, d3 = 4;
          else if (g5 === "..") {
            var u3 = FS.lookupPath(a2.path, { parent: true });
            p3 = u3.node.id, d3 = 4;
          } else {
            var f3;
            try {
              f3 = FS.lookupNode(a2.node, g5);
            } catch (c2) {
              if (c2?.errno === 28)
                continue;
              throw c2;
            }
            p3 = f3.id, d3 = FS.isChrdev(f3.mode) ? 2 : FS.isDir(f3.mode) ? 4 : FS.isLink(f3.mode) ? 10 : 8;
          }
          HEAP64[t + s4 >> 3] = BigInt(p3), HEAP64[t + s4 + 8 >> 3] = BigInt((m4 + 1) * o3), HEAP16[t + s4 + 16 >> 1] = 280, HEAP8[t + s4 + 18] = d3, stringToUTF8(g5, t + s4 + 19, 256), s4 += o3;
        }
        return FS.llseek(a2, m4 * o3, 0), s4;
      } catch (c2) {
        if (typeof FS > "u" || c2.name !== "ErrnoError")
          throw c2;
        return -c2.errno;
      }
    }
    ___syscall_getdents64.sig = "iipp";
    var writeSockaddr = (e, t, r2, a2, o3) => {
      switch (t) {
        case 2:
          r2 = inetPton4(r2), zeroMemory(e, 16), o3 && (HEAP32[o3 >> 2] = 16), HEAP16[e >> 1] = t, HEAP32[e + 4 >> 2] = r2, HEAP16[e + 2 >> 1] = _htons(a2);
          break;
        case 10:
          r2 = inetPton6(r2), zeroMemory(e, 28), o3 && (HEAP32[o3 >> 2] = 28), HEAP32[e >> 2] = t, HEAP32[e + 8 >> 2] = r2[0], HEAP32[e + 12 >> 2] = r2[1], HEAP32[e + 16 >> 2] = r2[2], HEAP32[e + 20 >> 2] = r2[3], HEAP16[e + 2 >> 1] = _htons(a2);
          break;
        default:
          return 5;
      }
      return 0;
    };
    function ___syscall_getsockname(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e), _3 = writeSockaddr(t, l4.family, DNS.lookup_name(l4.saddr || "0.0.0.0"), l4.sport, r2);
        return 0;
      } catch (n3) {
        if (typeof FS > "u" || n3.name !== "ErrnoError")
          throw n3;
        return -n3.errno;
      }
    }
    ___syscall_getsockname.sig = "iippiii";
    function ___syscall_getsockopt(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e);
        return t === 1 && r2 === 4 ? (HEAP32[a2 >> 2] = l4.error, HEAP32[o3 >> 2] = 4, l4.error = null, 0) : -50;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return -_3.errno;
      }
    }
    ___syscall_getsockopt.sig = "iiiippi";
    function ___syscall_ioctl(e, t, r2) {
      SYSCALLS.varargs = r2;
      try {
        var a2 = SYSCALLS.getStreamFromFD(e);
        switch (t) {
          case 21509:
            return a2.tty ? 0 : -59;
          case 21505: {
            if (!a2.tty)
              return -59;
            if (a2.tty.ops.ioctl_tcgets) {
              var o3 = a2.tty.ops.ioctl_tcgets(a2), s4 = syscallGetVarargP();
              HEAP32[s4 >> 2] = o3.c_iflag || 0, HEAP32[s4 + 4 >> 2] = o3.c_oflag || 0, HEAP32[s4 + 8 >> 2] = o3.c_cflag || 0, HEAP32[s4 + 12 >> 2] = o3.c_lflag || 0;
              for (var l4 = 0;l4 < 32; l4++)
                HEAP8[s4 + l4 + 17] = o3.c_cc[l4] || 0;
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
            return a2.tty ? 0 : -59;
          case 21506:
          case 21507:
          case 21508: {
            if (!a2.tty)
              return -59;
            if (a2.tty.ops.ioctl_tcsets) {
              for (var s4 = syscallGetVarargP(), _3 = HEAP32[s4 >> 2], n3 = HEAP32[s4 + 4 >> 2], m4 = HEAP32[s4 + 8 >> 2], p3 = HEAP32[s4 + 12 >> 2], d3 = [], l4 = 0;l4 < 32; l4++)
                d3.push(HEAP8[s4 + l4 + 17]);
              return a2.tty.ops.ioctl_tcsets(a2.tty, t, { c_iflag: _3, c_oflag: n3, c_cflag: m4, c_lflag: p3, c_cc: d3 });
            }
            return 0;
          }
          case 21519: {
            if (!a2.tty)
              return -59;
            var s4 = syscallGetVarargP();
            return HEAP32[s4 >> 2] = 0, 0;
          }
          case 21520:
            return a2.tty ? -28 : -59;
          case 21531: {
            var s4 = syscallGetVarargP();
            return FS.ioctl(a2, t, s4);
          }
          case 21523: {
            if (!a2.tty)
              return -59;
            if (a2.tty.ops && a2.tty.ops.ioctl_tiocgwinsz) {
              var g5 = a2.tty.ops.ioctl_tiocgwinsz(a2.tty), s4 = syscallGetVarargP();
              HEAP16[s4 >> 1] = g5[0], HEAP16[s4 + 2 >> 1] = g5[1];
            }
            return 0;
          }
          case 21524:
            return a2.tty ? 0 : -59;
          case 21515:
            return a2.tty ? 0 : -59;
          default:
            return -28;
        }
      } catch (u3) {
        if (typeof FS > "u" || u3.name !== "ErrnoError")
          throw u3;
        return -u3.errno;
      }
    }
    ___syscall_ioctl.sig = "iiip";
    function ___syscall_lstat64(e, t) {
      try {
        return e = SYSCALLS.getStr(e), SYSCALLS.doStat(FS.lstat, e, t);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_lstat64.sig = "ipp";
    function ___syscall_mkdirat(e, t, r2) {
      try {
        return t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), FS.mkdir(t, r2, 0), 0;
      } catch (a2) {
        if (typeof FS > "u" || a2.name !== "ErrnoError")
          throw a2;
        return -a2.errno;
      }
    }
    ___syscall_mkdirat.sig = "iipi";
    function ___syscall_newfstatat(e, t, r2, a2) {
      try {
        t = SYSCALLS.getStr(t);
        var o3 = a2 & 256, s4 = a2 & 4096;
        return a2 = a2 & -6401, t = SYSCALLS.calculateAt(e, t, s4), SYSCALLS.doStat(o3 ? FS.lstat : FS.stat, t, r2);
      } catch (l4) {
        if (typeof FS > "u" || l4.name !== "ErrnoError")
          throw l4;
        return -l4.errno;
      }
    }
    ___syscall_newfstatat.sig = "iippi";
    function ___syscall_openat(e, t, r2, a2) {
      SYSCALLS.varargs = a2;
      try {
        t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t);
        var o3 = a2 ? syscallGetVarargI() : 0;
        return FS.open(t, r2, o3).fd;
      } catch (s4) {
        if (typeof FS > "u" || s4.name !== "ErrnoError")
          throw s4;
        return -s4.errno;
      }
    }
    ___syscall_openat.sig = "iipip";
    var PIPEFS = { BUCKET_BUFFER_SIZE: 8192, mount(e) {
      return FS.createNode(null, "/", 16895, 0);
    }, createPipe() {
      var e = { buckets: [], refcnt: 2 };
      e.buckets.push({ buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 });
      var t = PIPEFS.nextname(), r2 = PIPEFS.nextname(), a2 = FS.createNode(PIPEFS.root, t, 4096, 0), o3 = FS.createNode(PIPEFS.root, r2, 4096, 0);
      a2.pipe = e, o3.pipe = e;
      var s4 = FS.createStream({ path: t, node: a2, flags: 0, seekable: false, stream_ops: PIPEFS.stream_ops });
      a2.stream = s4;
      var l4 = FS.createStream({ path: r2, node: o3, flags: 1, seekable: false, stream_ops: PIPEFS.stream_ops });
      return o3.stream = l4, { readable_fd: s4.fd, writable_fd: l4.fd };
    }, stream_ops: { poll(e) {
      var t = e.node.pipe;
      if ((e.flags & 2097155) === 1)
        return 260;
      if (t.buckets.length > 0)
        for (var r2 = 0;r2 < t.buckets.length; r2++) {
          var a2 = t.buckets[r2];
          if (a2.offset - a2.roffset > 0)
            return 65;
        }
      return 0;
    }, ioctl(e, t, r2) {
      return 28;
    }, fsync(e) {
      return 28;
    }, read(e, t, r2, a2, o3) {
      for (var s4 = e.node.pipe, l4 = 0, _3 = 0;_3 < s4.buckets.length; _3++) {
        var n3 = s4.buckets[_3];
        l4 += n3.offset - n3.roffset;
      }
      var m4 = t.subarray(r2, r2 + a2);
      if (a2 <= 0)
        return 0;
      if (l4 == 0)
        throw new FS.ErrnoError(6);
      for (var p3 = Math.min(l4, a2), d3 = p3, g5 = 0, _3 = 0;_3 < s4.buckets.length; _3++) {
        var u3 = s4.buckets[_3], f3 = u3.offset - u3.roffset;
        if (p3 <= f3) {
          var c2 = u3.buffer.subarray(u3.roffset, u3.offset);
          p3 < f3 ? (c2 = c2.subarray(0, p3), u3.roffset += p3) : g5++, m4.set(c2);
          break;
        } else {
          var c2 = u3.buffer.subarray(u3.roffset, u3.offset);
          m4.set(c2), m4 = m4.subarray(c2.byteLength), p3 -= c2.byteLength, g5++;
        }
      }
      return g5 && g5 == s4.buckets.length && (g5--, s4.buckets[g5].offset = 0, s4.buckets[g5].roffset = 0), s4.buckets.splice(0, g5), d3;
    }, write(e, t, r2, a2, o3) {
      var s4 = e.node.pipe, l4 = t.subarray(r2, r2 + a2), _3 = l4.byteLength;
      if (_3 <= 0)
        return 0;
      var n3 = null;
      s4.buckets.length == 0 ? (n3 = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 }, s4.buckets.push(n3)) : n3 = s4.buckets[s4.buckets.length - 1], assert(n3.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
      var m4 = PIPEFS.BUCKET_BUFFER_SIZE - n3.offset;
      if (m4 >= _3)
        return n3.buffer.set(l4, n3.offset), n3.offset += _3, _3;
      m4 > 0 && (n3.buffer.set(l4.subarray(0, m4), n3.offset), n3.offset += m4, l4 = l4.subarray(m4, l4.byteLength));
      for (var p3 = l4.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0, d3 = l4.byteLength % PIPEFS.BUCKET_BUFFER_SIZE, g5 = 0;g5 < p3; g5++) {
        var u3 = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: PIPEFS.BUCKET_BUFFER_SIZE, roffset: 0 };
        s4.buckets.push(u3), u3.buffer.set(l4.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)), l4 = l4.subarray(PIPEFS.BUCKET_BUFFER_SIZE, l4.byteLength);
      }
      if (d3 > 0) {
        var u3 = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: l4.byteLength, roffset: 0 };
        s4.buckets.push(u3), u3.buffer.set(l4);
      }
      return _3;
    }, close(e) {
      var t = e.node.pipe;
      t.refcnt--, t.refcnt === 0 && (t.buckets = null);
    } }, nextname() {
      return PIPEFS.nextname.current || (PIPEFS.nextname.current = 0), "pipe[" + PIPEFS.nextname.current++ + "]";
    } };
    function ___syscall_pipe(e) {
      try {
        if (e == 0)
          throw new FS.ErrnoError(21);
        var t = PIPEFS.createPipe();
        return HEAP32[e >> 2] = t.readable_fd, HEAP32[e + 4 >> 2] = t.writable_fd, 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_pipe.sig = "ip";
    function ___syscall_poll(e, t, r2) {
      try {
        for (var a2 = 0, o3 = 0;o3 < t; o3++) {
          var s4 = e + 8 * o3, l4 = HEAP32[s4 >> 2], _3 = HEAP16[s4 + 4 >> 1], n3 = 32, m4 = FS.getStream(l4);
          m4 && (n3 = SYSCALLS.DEFAULT_POLLMASK, m4.stream_ops.poll && (n3 = m4.stream_ops.poll(m4, -1))), n3 &= _3 | 8 | 16, n3 && a2++, HEAP16[s4 + 6 >> 1] = n3;
        }
        return a2;
      } catch (p3) {
        if (typeof FS > "u" || p3.name !== "ErrnoError")
          throw p3;
        return -p3.errno;
      }
    }
    ___syscall_poll.sig = "ipii";
    function ___syscall_readlinkat(e, t, r2, a2) {
      try {
        if (t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), a2 <= 0)
          return -28;
        var o3 = FS.readlink(t), s4 = Math.min(a2, lengthBytesUTF8(o3)), l4 = HEAP8[r2 + s4];
        return stringToUTF8(o3, r2, a2 + 1), HEAP8[r2 + s4] = l4, s4;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return -_3.errno;
      }
    }
    ___syscall_readlinkat.sig = "iippp";
    function ___syscall_recvfrom(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e), _3 = l4.sock_ops.recvmsg(l4, r2);
        if (!_3)
          return 0;
        if (o3)
          var n3 = writeSockaddr(o3, l4.family, DNS.lookup_name(_3.addr), _3.port, s4);
        return HEAPU8.set(_3.buffer, t), _3.buffer.byteLength;
      } catch (m4) {
        if (typeof FS > "u" || m4.name !== "ErrnoError")
          throw m4;
        return -m4.errno;
      }
    }
    ___syscall_recvfrom.sig = "iippipp";
    function ___syscall_renameat(e, t, r2, a2) {
      try {
        return t = SYSCALLS.getStr(t), a2 = SYSCALLS.getStr(a2), t = SYSCALLS.calculateAt(e, t), a2 = SYSCALLS.calculateAt(r2, a2), FS.rename(t, a2), 0;
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_renameat.sig = "iipip";
    function ___syscall_rmdir(e) {
      try {
        return e = SYSCALLS.getStr(e), FS.rmdir(e), 0;
      } catch (t) {
        if (typeof FS > "u" || t.name !== "ErrnoError")
          throw t;
        return -t.errno;
      }
    }
    ___syscall_rmdir.sig = "ip";
    function ___syscall_sendto(e, t, r2, a2, o3, s4) {
      try {
        var l4 = getSocketFromFD(e);
        if (!o3)
          return FS.write(l4.stream, HEAP8, t, r2);
        var _3 = getSocketAddress(o3, s4);
        return l4.sock_ops.sendmsg(l4, HEAP8, t, r2, _3.addr, _3.port);
      } catch (n3) {
        if (typeof FS > "u" || n3.name !== "ErrnoError")
          throw n3;
        return -n3.errno;
      }
    }
    ___syscall_sendto.sig = "iippipp";
    function ___syscall_socket(e, t, r2) {
      try {
        var a2 = SOCKFS.createSocket(e, t, r2);
        return a2.stream.fd;
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_socket.sig = "iiiiiii";
    function ___syscall_stat64(e, t) {
      try {
        return e = SYSCALLS.getStr(e), SYSCALLS.doStat(FS.stat, e, t);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_stat64.sig = "ipp";
    function ___syscall_symlinkat(e, t, r2) {
      try {
        return e = SYSCALLS.getStr(e), r2 = SYSCALLS.getStr(r2), r2 = SYSCALLS.calculateAt(t, r2), FS.symlink(e, r2), 0;
      } catch (a2) {
        if (typeof FS > "u" || a2.name !== "ErrnoError")
          throw a2;
        return -a2.errno;
      }
    }
    ___syscall_symlinkat.sig = "ipip";
    function ___syscall_truncate64(e, t) {
      t = bigintToI53Checked(t);
      try {
        return isNaN(t) ? 61 : (e = SYSCALLS.getStr(e), FS.truncate(e, t), 0);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_truncate64.sig = "ipj";
    function ___syscall_unlinkat(e, t, r2) {
      try {
        return t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), r2 === 0 ? FS.unlink(t) : r2 === 512 ? FS.rmdir(t) : abort("Invalid flags passed to unlinkat"), 0;
      } catch (a2) {
        if (typeof FS > "u" || a2.name !== "ErrnoError")
          throw a2;
        return -a2.errno;
      }
    }
    ___syscall_unlinkat.sig = "iipi";
    var ___table_base = new WebAssembly.Global({ value: "i32", mutable: false }, 1), __abort_js = () => abort("");
    __abort_js.sig = "v";
    var ENV = {}, stackAlloc = (e) => __emscripten_stack_alloc(e), stringToUTF8OnStack = (e) => {
      var t = lengthBytesUTF8(e) + 1, r2 = stackAlloc(t);
      return stringToUTF8(e, r2, t), r2;
    }, dlSetError = (e) => {
      var t = stackSave(), r2 = stringToUTF8OnStack(e);
      ___dl_seterr(r2, 0), stackRestore(t);
    }, dlopenInternal = (e, t) => {
      var r2 = UTF8ToString(e + 36), a2 = HEAP32[e + 4 >> 2];
      r2 = PATH.normalize(r2);
      var o3 = !!(a2 & 256), s4 = o3 ? null : {}, l4 = { global: o3, nodelete: !!(a2 & 4096), loadAsync: t.loadAsync };
      if (t.loadAsync)
        return loadDynamicLibrary(r2, l4, s4, e);
      try {
        return loadDynamicLibrary(r2, l4, s4, e);
      } catch (_3) {
        return dlSetError(`Could not load dynamic lib: ${r2}
${_3}`), 0;
      }
    }, __dlopen_js = (e) => dlopenInternal(e, { loadAsync: false });
    __dlopen_js.sig = "pp";
    var __dlsym_js = (e, t, r2) => {
      t = UTF8ToString(t);
      var a2, o3, s4 = LDSO.loadedLibsByHandle[e];
      if (!s4.exports.hasOwnProperty(t) || s4.exports[t].stub)
        return dlSetError(`Tried to lookup unknown symbol "${t}" in dynamic lib: ${s4.name}`), 0;
      if (o3 = Object.keys(s4.exports).indexOf(t), a2 = s4.exports[t], typeof a2 == "function") {
        var l4 = getFunctionAddress(a2);
        l4 ? a2 = l4 : (a2 = addFunction(a2, a2.sig), HEAPU32[r2 >> 2] = o3);
      }
      return a2;
    };
    __dlsym_js.sig = "pppp";
    var getExecutableName = () => thisProgram || "./this.program", __emscripten_get_progname = (e, t) => stringToUTF8(getExecutableName(), e, t);
    __emscripten_get_progname.sig = "vpi";
    var __emscripten_memcpy_js = (e, t, r2) => HEAPU8.copyWithin(e, t, t + r2);
    __emscripten_memcpy_js.sig = "vppp";
    var runtimeKeepaliveCounter = 0, __emscripten_runtime_keepalive_clear = () => {
      noExitRuntime = false, runtimeKeepaliveCounter = 0;
    };
    __emscripten_runtime_keepalive_clear.sig = "v";
    var __emscripten_system = (e) => {
      if (ENVIRONMENT_IS_NODE) {
        if (!e)
          return 1;
        var t = UTF8ToString(e);
        if (!t.length)
          return 0;
        var r2 = require("child_process"), a2 = r2.spawnSync(t, [], { shell: true, stdio: "inherit" }), o3 = (l4, _3) => l4 << 8 | _3;
        if (a2.status === null) {
          var s4 = (l4) => {
            switch (l4) {
              case "SIGHUP":
                return 1;
              case "SIGQUIT":
                return 3;
              case "SIGFPE":
                return 8;
              case "SIGKILL":
                return 9;
              case "SIGALRM":
                return 14;
              case "SIGTERM":
                return 15;
              default:
                return 2;
            }
          };
          return o3(0, s4(a2.signal));
        }
        return o3(a2.status, 0);
      }
      return e ? -52 : 0;
    };
    __emscripten_system.sig = "ip";
    var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
    __emscripten_throw_longjmp.sig = "v";
    function __gmtime_js(e, t) {
      e = bigintToI53Checked(e);
      var r2 = new Date(e * 1000);
      HEAP32[t >> 2] = r2.getUTCSeconds(), HEAP32[t + 4 >> 2] = r2.getUTCMinutes(), HEAP32[t + 8 >> 2] = r2.getUTCHours(), HEAP32[t + 12 >> 2] = r2.getUTCDate(), HEAP32[t + 16 >> 2] = r2.getUTCMonth(), HEAP32[t + 20 >> 2] = r2.getUTCFullYear() - 1900, HEAP32[t + 24 >> 2] = r2.getUTCDay();
      var a2 = Date.UTC(r2.getUTCFullYear(), 0, 1, 0, 0, 0, 0), o3 = (r2.getTime() - a2) / 86400000 | 0;
      HEAP32[t + 28 >> 2] = o3;
    }
    __gmtime_js.sig = "vjp";
    var isLeapYear = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], ydayFromDate = (e) => {
      var t = isLeapYear(e.getFullYear()), r2 = t ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE, a2 = r2[e.getMonth()] + e.getDate() - 1;
      return a2;
    };
    function __localtime_js(e, t) {
      e = bigintToI53Checked(e);
      var r2 = new Date(e * 1000);
      HEAP32[t >> 2] = r2.getSeconds(), HEAP32[t + 4 >> 2] = r2.getMinutes(), HEAP32[t + 8 >> 2] = r2.getHours(), HEAP32[t + 12 >> 2] = r2.getDate(), HEAP32[t + 16 >> 2] = r2.getMonth(), HEAP32[t + 20 >> 2] = r2.getFullYear() - 1900, HEAP32[t + 24 >> 2] = r2.getDay();
      var a2 = ydayFromDate(r2) | 0;
      HEAP32[t + 28 >> 2] = a2, HEAP32[t + 36 >> 2] = -(r2.getTimezoneOffset() * 60);
      var o3 = new Date(r2.getFullYear(), 0, 1), s4 = new Date(r2.getFullYear(), 6, 1).getTimezoneOffset(), l4 = o3.getTimezoneOffset(), _3 = (s4 != l4 && r2.getTimezoneOffset() == Math.min(l4, s4)) | 0;
      HEAP32[t + 32 >> 2] = _3;
    }
    __localtime_js.sig = "vjp";
    function __mmap_js(e, t, r2, a2, o3, s4, l4) {
      o3 = bigintToI53Checked(o3);
      try {
        if (isNaN(o3))
          return 61;
        var _3 = SYSCALLS.getStreamFromFD(a2), n3 = FS.mmap(_3, e, o3, t, r2), m4 = n3.ptr;
        return HEAP32[s4 >> 2] = n3.allocated, HEAPU32[l4 >> 2] = m4, 0;
      } catch (p3) {
        if (typeof FS > "u" || p3.name !== "ErrnoError")
          throw p3;
        return -p3.errno;
      }
    }
    __mmap_js.sig = "ipiiijpp";
    function __munmap_js(e, t, r2, a2, o3, s4) {
      s4 = bigintToI53Checked(s4);
      try {
        var l4 = SYSCALLS.getStreamFromFD(o3);
        r2 & 2 && SYSCALLS.doMsync(e, l4, t, a2, s4);
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return -_3.errno;
      }
    }
    __munmap_js.sig = "ippiiij";
    var timers = {}, handleException = (e) => {
      if (e instanceof ExitStatus || e == "unwind")
        return EXITSTATUS;
      quit_(1, e);
    }, keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0, _proc_exit = (e) => {
      EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit?.(e), ABORT = true), quit_(e, new ExitStatus(e));
    };
    _proc_exit.sig = "vi";
    var exitJS = (e, t) => {
      EXITSTATUS = e, _proc_exit(e);
    }, _exit = exitJS;
    _exit.sig = "vi";
    var maybeExit = () => {
      if (!keepRuntimeAlive())
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
    }, callUserCallback = (e) => {
      if (!ABORT)
        try {
          e(), maybeExit();
        } catch (t) {
          handleException(t);
        }
    }, _emscripten_get_now = () => performance.now();
    _emscripten_get_now.sig = "d";
    var __setitimer_js = (e, t) => {
      if (timers[e] && (clearTimeout(timers[e].id), delete timers[e]), !t)
        return 0;
      var r2 = setTimeout(() => {
        delete timers[e], callUserCallback(() => __emscripten_timeout(e, _emscripten_get_now()));
      }, t);
      return timers[e] = { id: r2, timeout_ms: t }, 0;
    };
    __setitimer_js.sig = "iid";
    var __tzset_js = (e, t, r2, a2) => {
      var o3 = new Date().getFullYear(), s4 = new Date(o3, 0, 1), l4 = new Date(o3, 6, 1), _3 = s4.getTimezoneOffset(), n3 = l4.getTimezoneOffset(), m4 = Math.max(_3, n3);
      HEAPU32[e >> 2] = m4 * 60, HEAP32[t >> 2] = +(_3 != n3);
      var p3 = (u3) => {
        var f3 = u3 >= 0 ? "-" : "+", c2 = Math.abs(u3), w4 = String(Math.floor(c2 / 60)).padStart(2, "0"), h3 = String(c2 % 60).padStart(2, "0");
        return `UTC${f3}${w4}${h3}`;
      }, d3 = p3(_3), g5 = p3(n3);
      n3 < _3 ? (stringToUTF8(d3, r2, 17), stringToUTF8(g5, a2, 17)) : (stringToUTF8(d3, a2, 17), stringToUTF8(g5, r2, 17));
    };
    __tzset_js.sig = "vpppp";
    var _emscripten_date_now = () => Date.now();
    _emscripten_date_now.sig = "d";
    var nowIsMonotonic = 1, checkWasiClock = (e) => e >= 0 && e <= 3;
    function _clock_time_get(e, t, r2) {
      if (t = bigintToI53Checked(t), !checkWasiClock(e))
        return 28;
      var a2;
      if (e === 0)
        a2 = _emscripten_date_now();
      else if (nowIsMonotonic)
        a2 = _emscripten_get_now();
      else
        return 52;
      var o3 = Math.round(a2 * 1000 * 1000);
      return HEAP64[r2 >> 3] = BigInt(o3), 0;
    }
    _clock_time_get.sig = "iijp";
    var readEmAsmArgsArray = [], readEmAsmArgs = (e, t) => {
      readEmAsmArgsArray.length = 0;
      for (var r2;r2 = HEAPU8[e++]; ) {
        var a2 = r2 != 105;
        a2 &= r2 != 112, t += a2 && t % 8 ? 4 : 0, readEmAsmArgsArray.push(r2 == 112 ? HEAPU32[t >> 2] : r2 == 106 ? HEAP64[t >> 3] : r2 == 105 ? HEAP32[t >> 2] : HEAPF64[t >> 3]), t += a2 ? 8 : 4;
      }
      return readEmAsmArgsArray;
    }, runEmAsmFunction = (e, t, r2) => {
      var a2 = readEmAsmArgs(t, r2);
      return ASM_CONSTS[e](...a2);
    }, _emscripten_asm_const_int = (e, t, r2) => runEmAsmFunction(e, t, r2);
    _emscripten_asm_const_int.sig = "ippp";
    var _emscripten_force_exit = (e) => {
      __emscripten_runtime_keepalive_clear(), _exit(e);
    };
    _emscripten_force_exit.sig = "vi";
    var getHeapMax = () => 2147483648, growMemory = (e) => {
      var t = wasmMemory.buffer, r2 = (e - t.byteLength + 65535) / 65536 | 0;
      try {
        return wasmMemory.grow(r2), updateMemoryViews(), 1;
      } catch {}
    }, _emscripten_resize_heap = (e) => {
      var t = HEAPU8.length;
      e >>>= 0;
      var r2 = getHeapMax();
      if (e > r2)
        return false;
      for (var a2 = 1;a2 <= 4; a2 *= 2) {
        var o3 = t * (1 + 0.2 / a2);
        o3 = Math.min(o3, e + 100663296);
        var s4 = Math.min(r2, alignMemory(Math.max(e, o3), 65536)), l4 = growMemory(s4);
        if (l4)
          return true;
      }
      return false;
    };
    _emscripten_resize_heap.sig = "ip";
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: getExecutableName() };
        for (var r2 in ENV)
          ENV[r2] === undefined ? delete t[r2] : t[r2] = ENV[r2];
        var a2 = [];
        for (var r2 in t)
          a2.push(`${r2}=${t[r2]}`);
        getEnvStrings.strings = a2;
      }
      return getEnvStrings.strings;
    }, stringToAscii = (e, t) => {
      for (var r2 = 0;r2 < e.length; ++r2)
        HEAP8[t++] = e.charCodeAt(r2);
      HEAP8[t] = 0;
    }, _environ_get = (e, t) => {
      var r2 = 0;
      return getEnvStrings().forEach((a2, o3) => {
        var s4 = t + r2;
        HEAPU32[e + o3 * 4 >> 2] = s4, stringToAscii(a2, s4), r2 += a2.length + 1;
      }), 0;
    };
    _environ_get.sig = "ipp";
    var _environ_sizes_get = (e, t) => {
      var r2 = getEnvStrings();
      HEAPU32[e >> 2] = r2.length;
      var a2 = 0;
      return r2.forEach((o3) => a2 += o3.length + 1), HEAPU32[t >> 2] = a2, 0;
    };
    _environ_sizes_get.sig = "ipp";
    function _fd_close(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return FS.close(t), 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return r2.errno;
      }
    }
    _fd_close.sig = "ii";
    function _fd_fdstat_get(e, t) {
      try {
        var r2 = 0, a2 = 0, o3 = 0, s4 = SYSCALLS.getStreamFromFD(e), l4 = s4.tty ? 2 : FS.isDir(s4.mode) ? 3 : FS.isLink(s4.mode) ? 7 : 4;
        return HEAP8[t] = l4, HEAP16[t + 2 >> 1] = o3, HEAP64[t + 8 >> 3] = BigInt(r2), HEAP64[t + 16 >> 3] = BigInt(a2), 0;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return _3.errno;
      }
    }
    _fd_fdstat_get.sig = "iip";
    var doReadv = (e, t, r2, a2) => {
      for (var o3 = 0, s4 = 0;s4 < r2; s4++) {
        var l4 = HEAPU32[t >> 2], _3 = HEAPU32[t + 4 >> 2];
        t += 8;
        var n3 = FS.read(e, HEAP8, l4, _3, a2);
        if (n3 < 0)
          return -1;
        if (o3 += n3, n3 < _3)
          break;
        typeof a2 < "u" && (a2 += n3);
      }
      return o3;
    };
    function _fd_pread(e, t, r2, a2, o3) {
      a2 = bigintToI53Checked(a2);
      try {
        if (isNaN(a2))
          return 61;
        var s4 = SYSCALLS.getStreamFromFD(e), l4 = doReadv(s4, t, r2, a2);
        return HEAPU32[o3 >> 2] = l4, 0;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return _3.errno;
      }
    }
    _fd_pread.sig = "iippjp";
    var doWritev = (e, t, r2, a2) => {
      for (var o3 = 0, s4 = 0;s4 < r2; s4++) {
        var l4 = HEAPU32[t >> 2], _3 = HEAPU32[t + 4 >> 2];
        t += 8;
        var n3 = FS.write(e, HEAP8, l4, _3, a2);
        if (n3 < 0)
          return -1;
        if (o3 += n3, n3 < _3)
          break;
        typeof a2 < "u" && (a2 += n3);
      }
      return o3;
    };
    function _fd_pwrite(e, t, r2, a2, o3) {
      a2 = bigintToI53Checked(a2);
      try {
        if (isNaN(a2))
          return 61;
        var s4 = SYSCALLS.getStreamFromFD(e), l4 = doWritev(s4, t, r2, a2);
        return HEAPU32[o3 >> 2] = l4, 0;
      } catch (_3) {
        if (typeof FS > "u" || _3.name !== "ErrnoError")
          throw _3;
        return _3.errno;
      }
    }
    _fd_pwrite.sig = "iippjp";
    function _fd_read(e, t, r2, a2) {
      try {
        var o3 = SYSCALLS.getStreamFromFD(e), s4 = doReadv(o3, t, r2);
        return HEAPU32[a2 >> 2] = s4, 0;
      } catch (l4) {
        if (typeof FS > "u" || l4.name !== "ErrnoError")
          throw l4;
        return l4.errno;
      }
    }
    _fd_read.sig = "iippp";
    function _fd_seek(e, t, r2, a2) {
      t = bigintToI53Checked(t);
      try {
        if (isNaN(t))
          return 61;
        var o3 = SYSCALLS.getStreamFromFD(e);
        return FS.llseek(o3, t, r2), HEAP64[a2 >> 3] = BigInt(o3.position), o3.getdents && t === 0 && r2 === 0 && (o3.getdents = null), 0;
      } catch (s4) {
        if (typeof FS > "u" || s4.name !== "ErrnoError")
          throw s4;
        return s4.errno;
      }
    }
    _fd_seek.sig = "iijip";
    function _fd_sync(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return t.stream_ops?.fsync ? t.stream_ops.fsync(t) : 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return r2.errno;
      }
    }
    _fd_sync.sig = "ii";
    function _fd_write(e, t, r2, a2) {
      try {
        var o3 = SYSCALLS.getStreamFromFD(e), s4 = doWritev(o3, t, r2);
        return HEAPU32[a2 >> 2] = s4, 0;
      } catch (l4) {
        if (typeof FS > "u" || l4.name !== "ErrnoError")
          throw l4;
        return l4.errno;
      }
    }
    _fd_write.sig = "iippp";
    var _getaddrinfo = (e, t, r2, a2) => {
      var o3 = 0, s4 = 0, l4 = 0, _3 = 0, n3 = 0, m4 = 0, p3;
      function d3(g5, u3, f3, c2, w4, h3) {
        var v3, x5, y3, M3;
        return x5 = g5 === 10 ? 28 : 16, w4 = g5 === 10 ? inetNtop6(w4) : inetNtop4(w4), v3 = _malloc(x5), M3 = writeSockaddr(v3, g5, w4, h3), assert(!M3), y3 = _malloc(32), HEAP32[y3 + 4 >> 2] = g5, HEAP32[y3 + 8 >> 2] = u3, HEAP32[y3 + 12 >> 2] = f3, HEAPU32[y3 + 24 >> 2] = c2, HEAPU32[y3 + 20 >> 2] = v3, g5 === 10 ? HEAP32[y3 + 16 >> 2] = 28 : HEAP32[y3 + 16 >> 2] = 16, HEAP32[y3 + 28 >> 2] = 0, y3;
      }
      if (r2 && (l4 = HEAP32[r2 >> 2], _3 = HEAP32[r2 + 4 >> 2], n3 = HEAP32[r2 + 8 >> 2], m4 = HEAP32[r2 + 12 >> 2]), n3 && !m4 && (m4 = n3 === 2 ? 17 : 6), !n3 && m4 && (n3 = m4 === 17 ? 2 : 1), m4 === 0 && (m4 = 6), n3 === 0 && (n3 = 1), !e && !t)
        return -2;
      if (l4 & -1088 || r2 !== 0 && HEAP32[r2 >> 2] & 2 && !e)
        return -1;
      if (l4 & 32)
        return -2;
      if (n3 !== 0 && n3 !== 1 && n3 !== 2)
        return -7;
      if (_3 !== 0 && _3 !== 2 && _3 !== 10)
        return -6;
      if (t && (t = UTF8ToString(t), s4 = parseInt(t, 10), isNaN(s4)))
        return l4 & 1024 ? -2 : -8;
      if (!e)
        return _3 === 0 && (_3 = 2), l4 & 1 || (_3 === 2 ? o3 = _htonl(2130706433) : o3 = [0, 0, 0, _htonl(1)]), p3 = d3(_3, n3, m4, null, o3, s4), HEAPU32[a2 >> 2] = p3, 0;
      if (e = UTF8ToString(e), o3 = inetPton4(e), o3 !== null)
        if (_3 === 0 || _3 === 2)
          _3 = 2;
        else if (_3 === 10 && l4 & 8)
          o3 = [0, 0, _htonl(65535), o3], _3 = 10;
        else
          return -2;
      else if (o3 = inetPton6(e), o3 !== null)
        if (_3 === 0 || _3 === 10)
          _3 = 10;
        else
          return -2;
      return o3 != null ? (p3 = d3(_3, n3, m4, e, o3, s4), HEAPU32[a2 >> 2] = p3, 0) : l4 & 4 ? -2 : (e = DNS.lookup_name(e), o3 = inetPton4(e), _3 === 0 ? _3 = 2 : _3 === 10 && (o3 = [0, 0, _htonl(65535), o3]), p3 = d3(_3, n3, m4, null, o3, s4), HEAPU32[a2 >> 2] = p3, 0);
    };
    _getaddrinfo.sig = "ipppp";
    var _getnameinfo = (e, t, r2, a2, o3, s4, l4) => {
      var _3 = readSockaddr(e, t);
      if (_3.errno)
        return -6;
      var { port: n3, addr: m4 } = _3, p3 = false;
      if (r2 && a2) {
        var d3;
        if (l4 & 1 || !(d3 = DNS.lookup_addr(m4))) {
          if (l4 & 8)
            return -2;
        } else
          m4 = d3;
        var g5 = stringToUTF8(m4, r2, a2);
        g5 + 1 >= a2 && (p3 = true);
      }
      if (o3 && s4) {
        n3 = "" + n3;
        var g5 = stringToUTF8(n3, o3, s4);
        g5 + 1 >= s4 && (p3 = true);
      }
      return p3 ? -12 : 0;
    };
    _getnameinfo.sig = "ipipipii";
    var stringToNewUTF8 = (e) => {
      var t = lengthBytesUTF8(e) + 1, r2 = _malloc(t);
      return r2 && stringToUTF8(e, r2, t), r2;
    }, FS_createPath = FS.createPath, FS_unlink = (e) => FS.unlink(e), FS_createLazyFile = FS.createLazyFile, FS_createDevice = FS.createDevice, getTempRet0 = (e) => __emscripten_tempret_get();
    Module.getTempRet0 = getTempRet0;
    var setTempRet0 = (e) => __emscripten_tempret_set(e), _setTempRet0 = setTempRet0;
    Module._setTempRet0 = _setTempRet0;
    var _getTempRet0 = getTempRet0;
    Module._getTempRet0 = _getTempRet0;

    class ExceptionInfo {
      constructor(t) {
        this.excPtr = t, this.ptr = t - 24;
      }
      set_type(t) {
        HEAPU32[this.ptr + 4 >> 2] = t;
      }
      get_type() {
        return HEAPU32[this.ptr + 4 >> 2];
      }
      set_destructor(t) {
        HEAPU32[this.ptr + 8 >> 2] = t;
      }
      get_destructor() {
        return HEAPU32[this.ptr + 8 >> 2];
      }
      set_caught(t) {
        t = t ? 1 : 0, HEAP8[this.ptr + 12] = t;
      }
      get_caught() {
        return HEAP8[this.ptr + 12] != 0;
      }
      set_rethrown(t) {
        t = t ? 1 : 0, HEAP8[this.ptr + 13] = t;
      }
      get_rethrown() {
        return HEAP8[this.ptr + 13] != 0;
      }
      init(t, r2) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r2);
      }
      set_adjusted_ptr(t) {
        HEAPU32[this.ptr + 16 >> 2] = t;
      }
      get_adjusted_ptr() {
        return HEAPU32[this.ptr + 16 >> 2];
      }
    }
    var exceptionLast = 0, uncaughtExceptionCount = 0, ___cxa_throw = (e, t, r2) => {
      var a2 = new ExceptionInfo(e);
      throw a2.init(t, r2), exceptionLast = e, uncaughtExceptionCount++, exceptionLast;
    };
    Module.___cxa_throw = ___cxa_throw, ___cxa_throw.sig = "vppp", registerWasmPlugin(), FS.createPreloadedFile = FS_createPreloadedFile, FS.staticInit(), Module.FS_createPath = FS.createPath, Module.FS_createDataFile = FS.createDataFile, Module.FS_createPreloadedFile = FS.createPreloadedFile, Module.FS_unlink = FS.unlink, Module.FS_createLazyFile = FS.createLazyFile, Module.FS_createDevice = FS.createDevice, MEMFS.doesNotExistError = new FS.ErrnoError(44), MEMFS.doesNotExistError.stack = "<generic error, no stack>", ENVIRONMENT_IS_NODE && NODEFS.staticInit();
    var wasmImports = { __assert_fail: ___assert_fail, __call_sighandler: ___call_sighandler, __heap_base: ___heap_base, __indirect_function_table: wasmTable, __memory_base: ___memory_base, __stack_pointer: ___stack_pointer, __syscall__newselect: ___syscall__newselect, __syscall_bind: ___syscall_bind, __syscall_chdir: ___syscall_chdir, __syscall_chmod: ___syscall_chmod, __syscall_connect: ___syscall_connect, __syscall_dup: ___syscall_dup, __syscall_dup3: ___syscall_dup3, __syscall_faccessat: ___syscall_faccessat, __syscall_fadvise64: ___syscall_fadvise64, __syscall_fallocate: ___syscall_fallocate, __syscall_fcntl64: ___syscall_fcntl64, __syscall_fdatasync: ___syscall_fdatasync, __syscall_fstat64: ___syscall_fstat64, __syscall_ftruncate64: ___syscall_ftruncate64, __syscall_getcwd: ___syscall_getcwd, __syscall_getdents64: ___syscall_getdents64, __syscall_getsockname: ___syscall_getsockname, __syscall_getsockopt: ___syscall_getsockopt, __syscall_ioctl: ___syscall_ioctl, __syscall_lstat64: ___syscall_lstat64, __syscall_mkdirat: ___syscall_mkdirat, __syscall_newfstatat: ___syscall_newfstatat, __syscall_openat: ___syscall_openat, __syscall_pipe: ___syscall_pipe, __syscall_poll: ___syscall_poll, __syscall_readlinkat: ___syscall_readlinkat, __syscall_recvfrom: ___syscall_recvfrom, __syscall_renameat: ___syscall_renameat, __syscall_rmdir: ___syscall_rmdir, __syscall_sendto: ___syscall_sendto, __syscall_socket: ___syscall_socket, __syscall_stat64: ___syscall_stat64, __syscall_symlinkat: ___syscall_symlinkat, __syscall_truncate64: ___syscall_truncate64, __syscall_unlinkat: ___syscall_unlinkat, __table_base: ___table_base, _abort_js: __abort_js, _dlopen_js: __dlopen_js, _dlsym_js: __dlsym_js, _emscripten_get_progname: __emscripten_get_progname, _emscripten_memcpy_js: __emscripten_memcpy_js, _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear, _emscripten_system: __emscripten_system, _emscripten_throw_longjmp: __emscripten_throw_longjmp, _gmtime_js: __gmtime_js, _localtime_js: __localtime_js, _mmap_js: __mmap_js, _munmap_js: __munmap_js, _setitimer_js: __setitimer_js, _tzset_js: __tzset_js, clock_time_get: _clock_time_get, emscripten_asm_const_int: _emscripten_asm_const_int, emscripten_date_now: _emscripten_date_now, emscripten_force_exit: _emscripten_force_exit, emscripten_get_now: _emscripten_get_now, emscripten_resize_heap: _emscripten_resize_heap, environ_get: _environ_get, environ_sizes_get: _environ_sizes_get, exit: _exit, fd_close: _fd_close, fd_fdstat_get: _fd_fdstat_get, fd_pread: _fd_pread, fd_pwrite: _fd_pwrite, fd_read: _fd_read, fd_seek: _fd_seek, fd_sync: _fd_sync, fd_write: _fd_write, getaddrinfo: _getaddrinfo, getnameinfo: _getnameinfo, invoke_di, invoke_i, invoke_id, invoke_ii, invoke_iii, invoke_iiii, invoke_iiiii, invoke_iiiiii, invoke_iiiiiii, invoke_iiiiiiii, invoke_iiiiiiiii, invoke_iiiiiiiiii, invoke_iiiiiiiiiii, invoke_iiiiiiiiiiiiii, invoke_iiiiiiiiiiiiiiiiii, invoke_iiiiiji, invoke_iiiij, invoke_iiiijii, invoke_iiij, invoke_iiji, invoke_ij, invoke_ijiiiii, invoke_ijiiiiii, invoke_j, invoke_ji, invoke_jii, invoke_jiiii, invoke_jiiiiii, invoke_jiiiiiiiii, invoke_v, invoke_vi, invoke_vid, invoke_vii, invoke_viii, invoke_viiii, invoke_viiiii, invoke_viiiiii, invoke_viiiiiii, invoke_viiiiiiii, invoke_viiiiiiiii, invoke_viiiiiiiiiiii, invoke_viiiji, invoke_viij, invoke_viiji, invoke_viijii, invoke_viijiiii, invoke_vij, invoke_viji, invoke_vijiji, invoke_vj, invoke_vji, memory: wasmMemory, proc_exit: _proc_exit }, wasmExports;
    createWasm();
    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports.__wasm_call_ctors)(), _fiprintf = Module._fiprintf = (e, t, r2) => (_fiprintf = Module._fiprintf = wasmExports.fiprintf)(e, t, r2), _fopen = Module._fopen = (e, t) => (_fopen = Module._fopen = wasmExports.fopen)(e, t), _fflush = Module._fflush = (e) => (_fflush = Module._fflush = wasmExports.fflush)(e), _fclose = Module._fclose = (e) => (_fclose = Module._fclose = wasmExports.fclose)(e), _free = Module._free = (e) => (_free = Module._free = wasmExports.free)(e), ___errno_location = Module.___errno_location = () => (___errno_location = Module.___errno_location = wasmExports.__errno_location)(), _ProcessInterrupts = Module._ProcessInterrupts = () => (_ProcessInterrupts = Module._ProcessInterrupts = wasmExports.ProcessInterrupts)(), _errstart_cold = Module._errstart_cold = (e, t) => (_errstart_cold = Module._errstart_cold = wasmExports.errstart_cold)(e, t), _errcode = Module._errcode = (e) => (_errcode = Module._errcode = wasmExports.errcode)(e), _errmsg = Module._errmsg = (e, t) => (_errmsg = Module._errmsg = wasmExports.errmsg)(e, t), _errfinish = Module._errfinish = (e, t, r2) => (_errfinish = Module._errfinish = wasmExports.errfinish)(e, t, r2), _puts = Module._puts = (e) => (_puts = Module._puts = wasmExports.puts)(e), _errstart = Module._errstart = (e, t) => (_errstart = Module._errstart = wasmExports.errstart)(e, t), _errmsg_internal = Module._errmsg_internal = (e, t) => (_errmsg_internal = Module._errmsg_internal = wasmExports.errmsg_internal)(e, t), _errdetail = Module._errdetail = (e, t) => (_errdetail = Module._errdetail = wasmExports.errdetail)(e, t), _errhint = Module._errhint = (e, t) => (_errhint = Module._errhint = wasmExports.errhint)(e, t), _pg_parse_query = Module._pg_parse_query = (e) => (_pg_parse_query = Module._pg_parse_query = wasmExports.pg_parse_query)(e), _gettimeofday = Module._gettimeofday = (e, t) => (_gettimeofday = Module._gettimeofday = wasmExports.gettimeofday)(e, t), _raw_parser = Module._raw_parser = (e, t) => (_raw_parser = Module._raw_parser = wasmExports.raw_parser)(e, t), _initStringInfo = Module._initStringInfo = (e) => (_initStringInfo = Module._initStringInfo = wasmExports.initStringInfo)(e), _appendStringInfoString = Module._appendStringInfoString = (e, t) => (_appendStringInfoString = Module._appendStringInfoString = wasmExports.appendStringInfoString)(e, t), _appendStringInfo = Module._appendStringInfo = (e, t, r2) => (_appendStringInfo = Module._appendStringInfo = wasmExports.appendStringInfo)(e, t, r2), _errdetail_internal = Module._errdetail_internal = (e, t) => (_errdetail_internal = Module._errdetail_internal = wasmExports.errdetail_internal)(e, t), _pfree = Module._pfree = (e) => (_pfree = Module._pfree = wasmExports.pfree)(e), _list_make1_impl = Module._list_make1_impl = (e, t) => (_list_make1_impl = Module._list_make1_impl = wasmExports.list_make1_impl)(e, t), _QueryRewrite = Module._QueryRewrite = (e) => (_QueryRewrite = Module._QueryRewrite = wasmExports.QueryRewrite)(e), _pg_plan_query = Module._pg_plan_query = (e, t, r2, a2) => (_pg_plan_query = Module._pg_plan_query = wasmExports.pg_plan_query)(e, t, r2, a2), _palloc0 = Module._palloc0 = (e) => (_palloc0 = Module._palloc0 = wasmExports.palloc0)(e), _lappend = Module._lappend = (e, t) => (_lappend = Module._lappend = wasmExports.lappend)(e, t), _GetCurrentTimestamp = Module._GetCurrentTimestamp = () => (_GetCurrentTimestamp = Module._GetCurrentTimestamp = wasmExports.GetCurrentTimestamp)(), _pg_prng_double = Module._pg_prng_double = (e) => (_pg_prng_double = Module._pg_prng_double = wasmExports.pg_prng_double)(e), _pg_snprintf = Module._pg_snprintf = (e, t, r2, a2) => (_pg_snprintf = Module._pg_snprintf = wasmExports.pg_snprintf)(e, t, r2, a2), _sigaddset = Module._sigaddset = (e, t) => (_sigaddset = Module._sigaddset = wasmExports.sigaddset)(e, t), _die = Module._die = (e) => (_die = Module._die = wasmExports.die)(e), _check_stack_depth = Module._check_stack_depth = () => (_check_stack_depth = Module._check_stack_depth = wasmExports.check_stack_depth)(), _pre_format_elog_string = Module._pre_format_elog_string = (e, t) => (_pre_format_elog_string = Module._pre_format_elog_string = wasmExports.pre_format_elog_string)(e, t), _format_elog_string = Module._format_elog_string = (e, t) => (_format_elog_string = Module._format_elog_string = wasmExports.format_elog_string)(e, t), _pstrdup = Module._pstrdup = (e) => (_pstrdup = Module._pstrdup = wasmExports.pstrdup)(e), _SplitIdentifierString = Module._SplitIdentifierString = (e, t, r2) => (_SplitIdentifierString = Module._SplitIdentifierString = wasmExports.SplitIdentifierString)(e, t, r2), _list_free = Module._list_free = (e) => (_list_free = Module._list_free = wasmExports.list_free)(e), _pg_strcasecmp = Module._pg_strcasecmp = (e, t) => (_pg_strcasecmp = Module._pg_strcasecmp = wasmExports.pg_strcasecmp)(e, t), _guc_malloc = Module._guc_malloc = (e, t) => (_guc_malloc = Module._guc_malloc = wasmExports.guc_malloc)(e, t), _SetConfigOption = Module._SetConfigOption = (e, t, r2, a2) => (_SetConfigOption = Module._SetConfigOption = wasmExports.SetConfigOption)(e, t, r2, a2), _pg_sprintf = Module._pg_sprintf = (e, t, r2) => (_pg_sprintf = Module._pg_sprintf = wasmExports.pg_sprintf)(e, t, r2), _strcmp = Module._strcmp = (e, t) => (_strcmp = Module._strcmp = wasmExports.strcmp)(e, t), _strdup = Module._strdup = (e) => (_strdup = Module._strdup = wasmExports.strdup)(e), _atoi = Module._atoi = (e) => (_atoi = Module._atoi = wasmExports.atoi)(e), _strlcpy = Module._strlcpy = (e, t, r2) => (_strlcpy = Module._strlcpy = wasmExports.strlcpy)(e, t, r2), _pgl_shutdown = Module._pgl_shutdown = () => (_pgl_shutdown = Module._pgl_shutdown = wasmExports.pgl_shutdown)(), _pgl_closed = Module._pgl_closed = () => (_pgl_closed = Module._pgl_closed = wasmExports.pgl_closed)(), _resetStringInfo = Module._resetStringInfo = (e) => (_resetStringInfo = Module._resetStringInfo = wasmExports.resetStringInfo)(e), _getc = Module._getc = (e) => (_getc = Module._getc = wasmExports.getc)(e), _appendStringInfoChar = Module._appendStringInfoChar = (e, t) => (_appendStringInfoChar = Module._appendStringInfoChar = wasmExports.appendStringInfoChar)(e, t), _strlen = Module._strlen = (e) => (_strlen = Module._strlen = wasmExports.strlen)(e), _strncmp = Module._strncmp = (e, t, r2) => (_strncmp = Module._strncmp = wasmExports.strncmp)(e, t, r2), _pg_fprintf = Module._pg_fprintf = (e, t, r2) => (_pg_fprintf = Module._pg_fprintf = wasmExports.pg_fprintf)(e, t, r2), _pgstat_report_activity = Module._pgstat_report_activity = (e, t) => (_pgstat_report_activity = Module._pgstat_report_activity = wasmExports.pgstat_report_activity)(e, t), _errhidestmt = Module._errhidestmt = (e) => (_errhidestmt = Module._errhidestmt = wasmExports.errhidestmt)(e), _GetTransactionSnapshot = Module._GetTransactionSnapshot = () => (_GetTransactionSnapshot = Module._GetTransactionSnapshot = wasmExports.GetTransactionSnapshot)(), _PushActiveSnapshot = Module._PushActiveSnapshot = (e) => (_PushActiveSnapshot = Module._PushActiveSnapshot = wasmExports.PushActiveSnapshot)(e), _AllocSetContextCreateInternal = Module._AllocSetContextCreateInternal = (e, t, r2, a2, o3) => (_AllocSetContextCreateInternal = Module._AllocSetContextCreateInternal = wasmExports.AllocSetContextCreateInternal)(e, t, r2, a2, o3), _PopActiveSnapshot = Module._PopActiveSnapshot = () => (_PopActiveSnapshot = Module._PopActiveSnapshot = wasmExports.PopActiveSnapshot)(), _CreateDestReceiver = Module._CreateDestReceiver = (e) => (_CreateDestReceiver = Module._CreateDestReceiver = wasmExports.CreateDestReceiver)(e), _CommitTransactionCommand = Module._CommitTransactionCommand = () => (_CommitTransactionCommand = Module._CommitTransactionCommand = wasmExports.CommitTransactionCommand)(), _CommandCounterIncrement = Module._CommandCounterIncrement = () => (_CommandCounterIncrement = Module._CommandCounterIncrement = wasmExports.CommandCounterIncrement)(), _MemoryContextDelete = Module._MemoryContextDelete = (e) => (_MemoryContextDelete = Module._MemoryContextDelete = wasmExports.MemoryContextDelete)(e), _StartTransactionCommand = Module._StartTransactionCommand = () => (_StartTransactionCommand = Module._StartTransactionCommand = wasmExports.StartTransactionCommand)(), ___wasm_setjmp_test = Module.___wasm_setjmp_test = (e, t) => (___wasm_setjmp_test = Module.___wasm_setjmp_test = wasmExports.__wasm_setjmp_test)(e, t), _pg_printf = Module._pg_printf = (e, t) => (_pg_printf = Module._pg_printf = wasmExports.pg_printf)(e, t), ___wasm_setjmp = Module.___wasm_setjmp = (e, t, r2) => (___wasm_setjmp = Module.___wasm_setjmp = wasmExports.__wasm_setjmp)(e, t, r2), _FlushErrorState = Module._FlushErrorState = () => (_FlushErrorState = Module._FlushErrorState = wasmExports.FlushErrorState)(), _emscripten_longjmp = Module._emscripten_longjmp = (e, t) => (_emscripten_longjmp = Module._emscripten_longjmp = wasmExports.emscripten_longjmp)(e, t), _enlargeStringInfo = Module._enlargeStringInfo = (e, t) => (_enlargeStringInfo = Module._enlargeStringInfo = wasmExports.enlargeStringInfo)(e, t), _malloc = Module._malloc = (e) => (_malloc = Module._malloc = wasmExports.malloc)(e), _realloc = Module._realloc = (e, t) => (_realloc = Module._realloc = wasmExports.realloc)(e, t), _getenv = Module._getenv = (e) => (_getenv = Module._getenv = wasmExports.getenv)(e), _strspn = Module._strspn = (e, t) => (_strspn = Module._strspn = wasmExports.strspn)(e, t), _strnlen = Module._strnlen = (e, t) => (_strnlen = Module._strnlen = wasmExports.strnlen)(e, t), _setenv = Module._setenv = (e, t, r2) => (_setenv = Module._setenv = wasmExports.setenv)(e, t, r2), _fileno = Module._fileno = (e) => (_fileno = Module._fileno = wasmExports.fileno)(e), _isatty = Module._isatty = (e) => (_isatty = Module._isatty = wasmExports.isatty)(e), _strchr = Module._strchr = (e, t) => (_strchr = Module._strchr = wasmExports.strchr)(e, t), _pg_vsnprintf = Module._pg_vsnprintf = (e, t, r2, a2) => (_pg_vsnprintf = Module._pg_vsnprintf = wasmExports.pg_vsnprintf)(e, t, r2, a2), _strcpy = Module._strcpy = (e, t) => (_strcpy = Module._strcpy = wasmExports.strcpy)(e, t), _pg_get_encoding_from_locale = Module._pg_get_encoding_from_locale = (e, t) => (_pg_get_encoding_from_locale = Module._pg_get_encoding_from_locale = wasmExports.pg_get_encoding_from_locale)(e, t), _pg_encoding_to_char_private = Module._pg_encoding_to_char_private = (e) => (_pg_encoding_to_char_private = Module._pg_encoding_to_char_private = wasmExports.pg_encoding_to_char_private)(e), _psprintf = Module._psprintf = (e, t) => (_psprintf = Module._psprintf = wasmExports.psprintf)(e, t), _stat = Module._stat = (e, t) => (_stat = Module._stat = wasmExports.stat)(e, t), _pqsignal = Module._pqsignal = (e, t) => (_pqsignal = Module._pqsignal = wasmExports.pqsignal)(e, t), _fwrite = Module._fwrite = (e, t, r2, a2) => (_fwrite = Module._fwrite = wasmExports.fwrite)(e, t, r2, a2), _strftime = Module._strftime = (e, t, r2, a2) => (_strftime = Module._strftime = wasmExports.strftime)(e, t, r2, a2), _strstr = Module._strstr = (e, t) => (_strstr = Module._strstr = wasmExports.strstr)(e, t), _fputs = Module._fputs = (e, t) => (_fputs = Module._fputs = wasmExports.fputs)(e, t), _strtol = Module._strtol = (e, t, r2) => (_strtol = Module._strtol = wasmExports.strtol)(e, t, r2), _ferror = Module._ferror = (e) => (_ferror = Module._ferror = wasmExports.ferror)(e), _pg_strip_crlf = Module._pg_strip_crlf = (e) => (_pg_strip_crlf = Module._pg_strip_crlf = wasmExports.pg_strip_crlf)(e), _get_buffer_size = Module._get_buffer_size = (e) => (_get_buffer_size = Module._get_buffer_size = wasmExports.get_buffer_size)(e), _get_buffer_addr = Module._get_buffer_addr = (e) => (_get_buffer_addr = Module._get_buffer_addr = wasmExports.get_buffer_addr)(e), _get_channel = Module._get_channel = () => (_get_channel = Module._get_channel = wasmExports.get_channel)(), _interactive_read = Module._interactive_read = () => (_interactive_read = Module._interactive_read = wasmExports.interactive_read)(), _interactive_write = Module._interactive_write = (e) => (_interactive_write = Module._interactive_write = wasmExports.interactive_write)(e), _use_wire = Module._use_wire = (e) => (_use_wire = Module._use_wire = wasmExports.use_wire)(e), _clear_error = Module._clear_error = () => (_clear_error = Module._clear_error = wasmExports.clear_error)(), _interactive_one = Module._interactive_one = () => (_interactive_one = Module._interactive_one = wasmExports.interactive_one)(), _abort = Module._abort = () => (_abort = Module._abort = wasmExports.abort)(), _pq_recvbuf_fill = Module._pq_recvbuf_fill = (e, t) => (_pq_recvbuf_fill = Module._pq_recvbuf_fill = wasmExports.pq_recvbuf_fill)(e, t), _pq_getmsgint = Module._pq_getmsgint = (e, t) => (_pq_getmsgint = Module._pq_getmsgint = wasmExports.pq_getmsgint)(e, t), _palloc = Module._palloc = (e) => (_palloc = Module._palloc = wasmExports.palloc)(e), _makeParamList = Module._makeParamList = (e) => (_makeParamList = Module._makeParamList = wasmExports.makeParamList)(e), _getTypeInputInfo = Module._getTypeInputInfo = (e, t, r2) => (_getTypeInputInfo = Module._getTypeInputInfo = wasmExports.getTypeInputInfo)(e, t, r2), _pnstrdup = Module._pnstrdup = (e, t) => (_pnstrdup = Module._pnstrdup = wasmExports.pnstrdup)(e, t), _MemoryContextSetParent = Module._MemoryContextSetParent = (e, t) => (_MemoryContextSetParent = Module._MemoryContextSetParent = wasmExports.MemoryContextSetParent)(e, t), _unlink = Module._unlink = (e) => (_unlink = Module._unlink = wasmExports.unlink)(e), _pgl_backend = Module._pgl_backend = () => (_pgl_backend = Module._pgl_backend = wasmExports.pgl_backend)(), _pgl_initdb = Module._pgl_initdb = () => (_pgl_initdb = Module._pgl_initdb = wasmExports.pgl_initdb)(), _dup = Module._dup = (e) => (_dup = Module._dup = wasmExports.dup)(e), _main = Module._main = (e, t) => (_main = Module._main = wasmExports.__main_argc_argv)(e, t), _appendStringInfoStringQuoted = Module._appendStringInfoStringQuoted = (e, t, r2) => (_appendStringInfoStringQuoted = Module._appendStringInfoStringQuoted = wasmExports.appendStringInfoStringQuoted)(e, t, r2), _set_errcontext_domain = Module._set_errcontext_domain = (e) => (_set_errcontext_domain = Module._set_errcontext_domain = wasmExports.set_errcontext_domain)(e), _errcontext_msg = Module._errcontext_msg = (e, t) => (_errcontext_msg = Module._errcontext_msg = wasmExports.errcontext_msg)(e, t), _pg_is_ascii = Module._pg_is_ascii = (e) => (_pg_is_ascii = Module._pg_is_ascii = wasmExports.pg_is_ascii)(e), _memchr = Module._memchr = (e, t, r2) => (_memchr = Module._memchr = wasmExports.memchr)(e, t, r2), _strrchr = Module._strrchr = (e, t) => (_strrchr = Module._strrchr = wasmExports.strrchr)(e, t), _replace_percent_placeholders = Module._replace_percent_placeholders = (e, t, r2, a2) => (_replace_percent_placeholders = Module._replace_percent_placeholders = wasmExports.replace_percent_placeholders)(e, t, r2, a2), _pg_b64_encode = Module._pg_b64_encode = (e, t, r2, a2) => (_pg_b64_encode = Module._pg_b64_encode = wasmExports.pg_b64_encode)(e, t, r2, a2), _pg_b64_decode = Module._pg_b64_decode = (e, t, r2, a2) => (_pg_b64_decode = Module._pg_b64_decode = wasmExports.pg_b64_decode)(e, t, r2, a2), _pg_b64_enc_len = Module._pg_b64_enc_len = (e) => (_pg_b64_enc_len = Module._pg_b64_enc_len = wasmExports.pg_b64_enc_len)(e), _pg_b64_dec_len = Module._pg_b64_dec_len = (e) => (_pg_b64_dec_len = Module._pg_b64_dec_len = wasmExports.pg_b64_dec_len)(e), _MemoryContextAllocZero = Module._MemoryContextAllocZero = (e, t) => (_MemoryContextAllocZero = Module._MemoryContextAllocZero = wasmExports.MemoryContextAllocZero)(e, t), _MemoryContextAllocExtended = Module._MemoryContextAllocExtended = (e, t, r2) => (_MemoryContextAllocExtended = Module._MemoryContextAllocExtended = wasmExports.MemoryContextAllocExtended)(e, t, r2), _hash_bytes = Module._hash_bytes = (e, t) => (_hash_bytes = Module._hash_bytes = wasmExports.hash_bytes)(e, t), _memcmp = Module._memcmp = (e, t, r2) => (_memcmp = Module._memcmp = wasmExports.memcmp)(e, t, r2), _repalloc = Module._repalloc = (e, t) => (_repalloc = Module._repalloc = wasmExports.repalloc)(e, t), _pg_qsort = Module._pg_qsort = (e, t, r2, a2) => (_pg_qsort = Module._pg_qsort = wasmExports.pg_qsort)(e, t, r2, a2), _strlcat = Module._strlcat = (e, t, r2) => (_strlcat = Module._strlcat = wasmExports.strlcat)(e, t, r2), _OpenTransientFile = Module._OpenTransientFile = (e, t) => (_OpenTransientFile = Module._OpenTransientFile = wasmExports.OpenTransientFile)(e, t), _errcode_for_file_access = Module._errcode_for_file_access = () => (_errcode_for_file_access = Module._errcode_for_file_access = wasmExports.errcode_for_file_access)(), _read = Module._read = (e, t, r2) => (_read = Module._read = wasmExports.read)(e, t, r2), _CloseTransientFile = Module._CloseTransientFile = (e) => (_CloseTransientFile = Module._CloseTransientFile = wasmExports.CloseTransientFile)(e), _time = Module._time = (e) => (_time = Module._time = wasmExports.time)(e), _write = Module._write = (e, t, r2) => (_write = Module._write = wasmExports.write)(e, t, r2), _close = Module._close = (e) => (_close = Module._close = wasmExports.close)(e), ___multi3 = Module.___multi3 = (e, t, r2, a2, o3) => (___multi3 = Module.___multi3 = wasmExports.__multi3)(e, t, r2, a2, o3), _pg_char_to_encoding_private = Module._pg_char_to_encoding_private = (e) => (_pg_char_to_encoding_private = Module._pg_char_to_encoding_private = wasmExports.pg_char_to_encoding_private)(e), _isalnum = Module._isalnum = (e) => (_isalnum = Module._isalnum = wasmExports.isalnum)(e), _popen = Module._popen = (e, t) => (_popen = Module._popen = wasmExports.popen)(e, t), _pclose = Module._pclose = (e) => (_pclose = Module._pclose = wasmExports.pclose)(e), _wait_result_to_str = Module._wait_result_to_str = (e) => (_wait_result_to_str = Module._wait_result_to_str = wasmExports.wait_result_to_str)(e), _float_to_shortest_decimal_bufn = Module._float_to_shortest_decimal_bufn = (e, t) => (_float_to_shortest_decimal_bufn = Module._float_to_shortest_decimal_bufn = wasmExports.float_to_shortest_decimal_bufn)(e, t), _float_to_shortest_decimal_buf = Module._float_to_shortest_decimal_buf = (e, t) => (_float_to_shortest_decimal_buf = Module._float_to_shortest_decimal_buf = wasmExports.float_to_shortest_decimal_buf)(e, t), _pwrite = Module._pwrite = (e, t, r2, a2) => (_pwrite = Module._pwrite = wasmExports.pwrite)(e, t, r2, a2), _hash_bytes_extended = Module._hash_bytes_extended = (e, t, r2) => (_hash_bytes_extended = Module._hash_bytes_extended = wasmExports.hash_bytes_extended)(e, t, r2), _pg_getaddrinfo_all = Module._pg_getaddrinfo_all = (e, t, r2, a2) => (_pg_getaddrinfo_all = Module._pg_getaddrinfo_all = wasmExports.pg_getaddrinfo_all)(e, t, r2, a2), _calloc = Module._calloc = (e, t) => (_calloc = Module._calloc = wasmExports.calloc)(e, t), _pg_freeaddrinfo_all = Module._pg_freeaddrinfo_all = (e, t) => (_pg_freeaddrinfo_all = Module._pg_freeaddrinfo_all = wasmExports.pg_freeaddrinfo_all)(e, t), _pg_getnameinfo_all = Module._pg_getnameinfo_all = (e, t, r2, a2, o3, s4, l4) => (_pg_getnameinfo_all = Module._pg_getnameinfo_all = wasmExports.pg_getnameinfo_all)(e, t, r2, a2, o3, s4, l4), _IsValidJsonNumber = Module._IsValidJsonNumber = (e, t) => (_IsValidJsonNumber = Module._IsValidJsonNumber = wasmExports.IsValidJsonNumber)(e, t), _appendBinaryStringInfo = Module._appendBinaryStringInfo = (e, t, r2) => (_appendBinaryStringInfo = Module._appendBinaryStringInfo = wasmExports.appendBinaryStringInfo)(e, t, r2), _makeStringInfo = Module._makeStringInfo = () => (_makeStringInfo = Module._makeStringInfo = wasmExports.makeStringInfo)(), _pg_encoding_mblen = Module._pg_encoding_mblen = (e, t) => (_pg_encoding_mblen = Module._pg_encoding_mblen = wasmExports.pg_encoding_mblen)(e, t), _GetDatabaseEncodingName = Module._GetDatabaseEncodingName = () => (_GetDatabaseEncodingName = Module._GetDatabaseEncodingName = wasmExports.GetDatabaseEncodingName)(), _ScanKeywordLookup = Module._ScanKeywordLookup = (e, t) => (_ScanKeywordLookup = Module._ScanKeywordLookup = wasmExports.ScanKeywordLookup)(e, t), _pg_md5_encrypt = Module._pg_md5_encrypt = (e, t, r2, a2, o3) => (_pg_md5_encrypt = Module._pg_md5_encrypt = wasmExports.pg_md5_encrypt)(e, t, r2, a2, o3), _strtoul = Module._strtoul = (e, t, r2) => (_strtoul = Module._strtoul = wasmExports.strtoul)(e, t, r2), _sscanf = Module._sscanf = (e, t, r2) => (_sscanf = Module._sscanf = wasmExports.sscanf)(e, t, r2), _fgets = Module._fgets = (e, t, r2) => (_fgets = Module._fgets = wasmExports.fgets)(e, t, r2), _pg_prng_seed = Module._pg_prng_seed = (e, t) => (_pg_prng_seed = Module._pg_prng_seed = wasmExports.pg_prng_seed)(e, t), _pg_prng_seed_check = Module._pg_prng_seed_check = (e) => (_pg_prng_seed_check = Module._pg_prng_seed_check = wasmExports.pg_prng_seed_check)(e), _pg_prng_uint64 = Module._pg_prng_uint64 = (e) => (_pg_prng_uint64 = Module._pg_prng_uint64 = wasmExports.pg_prng_uint64)(e), _pg_prng_uint64_range = Module._pg_prng_uint64_range = (e, t, r2) => (_pg_prng_uint64_range = Module._pg_prng_uint64_range = wasmExports.pg_prng_uint64_range)(e, t, r2), _pg_prng_uint32 = Module._pg_prng_uint32 = (e) => (_pg_prng_uint32 = Module._pg_prng_uint32 = wasmExports.pg_prng_uint32)(e), _log = Module._log = (e) => (_log = Module._log = wasmExports.log)(e), _sin = Module._sin = (e) => (_sin = Module._sin = wasmExports.sin)(e), _forkname_to_number = Module._forkname_to_number = (e) => (_forkname_to_number = Module._forkname_to_number = wasmExports.forkname_to_number)(e), _pg_saslprep = Module._pg_saslprep = (e, t) => (_pg_saslprep = Module._pg_saslprep = wasmExports.pg_saslprep)(e, t), _pg_utf_mblen_private = Module._pg_utf_mblen_private = (e) => (_pg_utf_mblen_private = Module._pg_utf_mblen_private = wasmExports.pg_utf_mblen_private)(e), _pg_utf8_islegal = Module._pg_utf8_islegal = (e, t) => (_pg_utf8_islegal = Module._pg_utf8_islegal = wasmExports.pg_utf8_islegal)(e, t), _bsearch = Module._bsearch = (e, t, r2, a2, o3) => (_bsearch = Module._bsearch = wasmExports.bsearch)(e, t, r2, a2, o3), _scram_SaltedPassword = Module._scram_SaltedPassword = (e, t, r2, a2, o3, s4, l4, _3) => (_scram_SaltedPassword = Module._scram_SaltedPassword = wasmExports.scram_SaltedPassword)(e, t, r2, a2, o3, s4, l4, _3), _pg_hmac_create = Module._pg_hmac_create = (e) => (_pg_hmac_create = Module._pg_hmac_create = wasmExports.pg_hmac_create)(e), _pg_hmac_error = Module._pg_hmac_error = (e) => (_pg_hmac_error = Module._pg_hmac_error = wasmExports.pg_hmac_error)(e), _pg_hmac_init = Module._pg_hmac_init = (e, t, r2) => (_pg_hmac_init = Module._pg_hmac_init = wasmExports.pg_hmac_init)(e, t, r2), _pg_hmac_update = Module._pg_hmac_update = (e, t, r2) => (_pg_hmac_update = Module._pg_hmac_update = wasmExports.pg_hmac_update)(e, t, r2), _pg_hmac_final = Module._pg_hmac_final = (e, t, r2) => (_pg_hmac_final = Module._pg_hmac_final = wasmExports.pg_hmac_final)(e, t, r2), _pg_hmac_free = Module._pg_hmac_free = (e) => (_pg_hmac_free = Module._pg_hmac_free = wasmExports.pg_hmac_free)(e), _scram_H = Module._scram_H = (e, t, r2, a2, o3) => (_scram_H = Module._scram_H = wasmExports.scram_H)(e, t, r2, a2, o3), _scram_ClientKey = Module._scram_ClientKey = (e, t, r2, a2, o3) => (_scram_ClientKey = Module._scram_ClientKey = wasmExports.scram_ClientKey)(e, t, r2, a2, o3), _scram_ServerKey = Module._scram_ServerKey = (e, t, r2, a2, o3) => (_scram_ServerKey = Module._scram_ServerKey = wasmExports.scram_ServerKey)(e, t, r2, a2, o3), _scram_build_secret = Module._scram_build_secret = (e, t, r2, a2, o3, s4, l4) => (_scram_build_secret = Module._scram_build_secret = wasmExports.scram_build_secret)(e, t, r2, a2, o3, s4, l4), _palloc_extended = Module._palloc_extended = (e, t) => (_palloc_extended = Module._palloc_extended = wasmExports.palloc_extended)(e, t), _appendStringInfoSpaces = Module._appendStringInfoSpaces = (e, t) => (_appendStringInfoSpaces = Module._appendStringInfoSpaces = wasmExports.appendStringInfoSpaces)(e, t), _geteuid = Module._geteuid = () => (_geteuid = Module._geteuid = wasmExports.geteuid)(), _pg_encoding_set_invalid = Module._pg_encoding_set_invalid = (e, t) => (_pg_encoding_set_invalid = Module._pg_encoding_set_invalid = wasmExports.pg_encoding_set_invalid)(e, t), _pg_encoding_dsplen = Module._pg_encoding_dsplen = (e, t) => (_pg_encoding_dsplen = Module._pg_encoding_dsplen = wasmExports.pg_encoding_dsplen)(e, t), _pg_encoding_verifymbchar = Module._pg_encoding_verifymbchar = (e, t, r2) => (_pg_encoding_verifymbchar = Module._pg_encoding_verifymbchar = wasmExports.pg_encoding_verifymbchar)(e, t, r2), _pg_encoding_verifymbstr = Module._pg_encoding_verifymbstr = (e, t, r2) => (_pg_encoding_verifymbstr = Module._pg_encoding_verifymbstr = wasmExports.pg_encoding_verifymbstr)(e, t, r2), _pg_encoding_max_length = Module._pg_encoding_max_length = (e) => (_pg_encoding_max_length = Module._pg_encoding_max_length = wasmExports.pg_encoding_max_length)(e), _explicit_bzero = Module._explicit_bzero = (e, t) => (_explicit_bzero = Module._explicit_bzero = wasmExports.explicit_bzero)(e, t), _getpeereid = Module._getpeereid = (e, t, r2) => (_getpeereid = Module._getpeereid = wasmExports.getpeereid)(e, t, r2), _getsockopt = Module._getsockopt = (e, t, r2, a2, o3) => (_getsockopt = Module._getsockopt = wasmExports.getsockopt)(e, t, r2, a2, o3), _pg_inet_net_ntop = Module._pg_inet_net_ntop = (e, t, r2, a2, o3) => (_pg_inet_net_ntop = Module._pg_inet_net_ntop = wasmExports.pg_inet_net_ntop)(e, t, r2, a2, o3), _fcntl = Module._fcntl = (e, t, r2) => (_fcntl = Module._fcntl = wasmExports.fcntl)(e, t, r2), _getcwd = Module._getcwd = (e, t) => (_getcwd = Module._getcwd = wasmExports.getcwd)(e, t), _pg_get_user_home_dir = Module._pg_get_user_home_dir = (e, t, r2) => (_pg_get_user_home_dir = Module._pg_get_user_home_dir = wasmExports.pg_get_user_home_dir)(e, t, r2), _pg_popcount_optimized = Module._pg_popcount_optimized = (e, t) => (_pg_popcount_optimized = Module._pg_popcount_optimized = wasmExports.pg_popcount_optimized)(e, t), _pg_strong_random = Module._pg_strong_random = (e, t) => (_pg_strong_random = Module._pg_strong_random = wasmExports.pg_strong_random)(e, t), _open = Module._open = (e, t, r2) => (_open = Module._open = wasmExports.open)(e, t, r2), _pg_usleep = Module._pg_usleep = (e) => (_pg_usleep = Module._pg_usleep = wasmExports.pg_usleep)(e), _nanosleep = Module._nanosleep = (e, t) => (_nanosleep = Module._nanosleep = wasmExports.nanosleep)(e, t), _pg_tolower = Module._pg_tolower = (e) => (_pg_tolower = Module._pg_tolower = wasmExports.pg_tolower)(e), _sigemptyset = Module._sigemptyset = (e) => (_sigemptyset = Module._sigemptyset = wasmExports.sigemptyset)(e), _getpid = Module._getpid = () => (_getpid = Module._getpid = wasmExports.getpid)(), _qsort_arg = Module._qsort_arg = (e, t, r2, a2, o3) => (_qsort_arg = Module._qsort_arg = wasmExports.qsort_arg)(e, t, r2, a2, o3), _snprintf = Module._snprintf = (e, t, r2, a2) => (_snprintf = Module._snprintf = wasmExports.snprintf)(e, t, r2, a2), _pg_strerror_r = Module._pg_strerror_r = (e, t, r2) => (_pg_strerror_r = Module._pg_strerror_r = wasmExports.pg_strerror_r)(e, t, r2), _RelationGetNumberOfBlocksInFork = Module._RelationGetNumberOfBlocksInFork = (e, t) => (_RelationGetNumberOfBlocksInFork = Module._RelationGetNumberOfBlocksInFork = wasmExports.RelationGetNumberOfBlocksInFork)(e, t), _ExtendBufferedRel = Module._ExtendBufferedRel = (e, t, r2, a2) => (_ExtendBufferedRel = Module._ExtendBufferedRel = wasmExports.ExtendBufferedRel)(e, t, r2, a2), _MarkBufferDirty = Module._MarkBufferDirty = (e) => (_MarkBufferDirty = Module._MarkBufferDirty = wasmExports.MarkBufferDirty)(e), _XLogBeginInsert = Module._XLogBeginInsert = () => (_XLogBeginInsert = Module._XLogBeginInsert = wasmExports.XLogBeginInsert)(), _XLogRegisterData = Module._XLogRegisterData = (e, t) => (_XLogRegisterData = Module._XLogRegisterData = wasmExports.XLogRegisterData)(e, t), _XLogInsert = Module._XLogInsert = (e, t) => (_XLogInsert = Module._XLogInsert = wasmExports.XLogInsert)(e, t), _UnlockReleaseBuffer = Module._UnlockReleaseBuffer = (e) => (_UnlockReleaseBuffer = Module._UnlockReleaseBuffer = wasmExports.UnlockReleaseBuffer)(e), _brin_build_desc = Module._brin_build_desc = (e) => (_brin_build_desc = Module._brin_build_desc = wasmExports.brin_build_desc)(e), _EnterParallelMode = Module._EnterParallelMode = () => (_EnterParallelMode = Module._EnterParallelMode = wasmExports.EnterParallelMode)(), _CreateParallelContext = Module._CreateParallelContext = (e, t, r2) => (_CreateParallelContext = Module._CreateParallelContext = wasmExports.CreateParallelContext)(e, t, r2), _RegisterSnapshot = Module._RegisterSnapshot = (e) => (_RegisterSnapshot = Module._RegisterSnapshot = wasmExports.RegisterSnapshot)(e), _table_parallelscan_estimate = Module._table_parallelscan_estimate = (e, t) => (_table_parallelscan_estimate = Module._table_parallelscan_estimate = wasmExports.table_parallelscan_estimate)(e, t), _add_size = Module._add_size = (e, t) => (_add_size = Module._add_size = wasmExports.add_size)(e, t), _tuplesort_estimate_shared = Module._tuplesort_estimate_shared = (e) => (_tuplesort_estimate_shared = Module._tuplesort_estimate_shared = wasmExports.tuplesort_estimate_shared)(e), _InitializeParallelDSM = Module._InitializeParallelDSM = (e) => (_InitializeParallelDSM = Module._InitializeParallelDSM = wasmExports.InitializeParallelDSM)(e), _UnregisterSnapshot = Module._UnregisterSnapshot = (e) => (_UnregisterSnapshot = Module._UnregisterSnapshot = wasmExports.UnregisterSnapshot)(e), _DestroyParallelContext = Module._DestroyParallelContext = (e) => (_DestroyParallelContext = Module._DestroyParallelContext = wasmExports.DestroyParallelContext)(e), _ExitParallelMode = Module._ExitParallelMode = () => (_ExitParallelMode = Module._ExitParallelMode = wasmExports.ExitParallelMode)(), _shm_toc_allocate = Module._shm_toc_allocate = (e, t) => (_shm_toc_allocate = Module._shm_toc_allocate = wasmExports.shm_toc_allocate)(e, t), _ConditionVariableInit = Module._ConditionVariableInit = (e) => (_ConditionVariableInit = Module._ConditionVariableInit = wasmExports.ConditionVariableInit)(e), _s_init_lock_sema = Module._s_init_lock_sema = (e, t) => (_s_init_lock_sema = Module._s_init_lock_sema = wasmExports.s_init_lock_sema)(e, t), _table_parallelscan_initialize = Module._table_parallelscan_initialize = (e, t, r2) => (_table_parallelscan_initialize = Module._table_parallelscan_initialize = wasmExports.table_parallelscan_initialize)(e, t, r2), _tuplesort_initialize_shared = Module._tuplesort_initialize_shared = (e, t, r2) => (_tuplesort_initialize_shared = Module._tuplesort_initialize_shared = wasmExports.tuplesort_initialize_shared)(e, t, r2), _shm_toc_insert = Module._shm_toc_insert = (e, t, r2) => (_shm_toc_insert = Module._shm_toc_insert = wasmExports.shm_toc_insert)(e, t, r2), _LaunchParallelWorkers = Module._LaunchParallelWorkers = (e) => (_LaunchParallelWorkers = Module._LaunchParallelWorkers = wasmExports.LaunchParallelWorkers)(e), _WaitForParallelWorkersToAttach = Module._WaitForParallelWorkersToAttach = (e) => (_WaitForParallelWorkersToAttach = Module._WaitForParallelWorkersToAttach = wasmExports.WaitForParallelWorkersToAttach)(e), _tas_sema = Module._tas_sema = (e) => (_tas_sema = Module._tas_sema = wasmExports.tas_sema)(e), _s_lock = Module._s_lock = (e, t, r2, a2) => (_s_lock = Module._s_lock = wasmExports.s_lock)(e, t, r2, a2), _s_unlock_sema = Module._s_unlock_sema = (e) => (_s_unlock_sema = Module._s_unlock_sema = wasmExports.s_unlock_sema)(e), _ConditionVariableSleep = Module._ConditionVariableSleep = (e, t) => (_ConditionVariableSleep = Module._ConditionVariableSleep = wasmExports.ConditionVariableSleep)(e, t), _ConditionVariableCancelSleep = Module._ConditionVariableCancelSleep = () => (_ConditionVariableCancelSleep = Module._ConditionVariableCancelSleep = wasmExports.ConditionVariableCancelSleep)(), _tuplesort_performsort = Module._tuplesort_performsort = (e) => (_tuplesort_performsort = Module._tuplesort_performsort = wasmExports.tuplesort_performsort)(e), _tuplesort_end = Module._tuplesort_end = (e) => (_tuplesort_end = Module._tuplesort_end = wasmExports.tuplesort_end)(e), _MemoryContextReset = Module._MemoryContextReset = (e) => (_MemoryContextReset = Module._MemoryContextReset = wasmExports.MemoryContextReset)(e), _brin_deform_tuple = Module._brin_deform_tuple = (e, t, r2) => (_brin_deform_tuple = Module._brin_deform_tuple = wasmExports.brin_deform_tuple)(e, t, r2), _log_newpage_buffer = Module._log_newpage_buffer = (e, t) => (_log_newpage_buffer = Module._log_newpage_buffer = wasmExports.log_newpage_buffer)(e, t), _LockBuffer = Module._LockBuffer = (e, t) => (_LockBuffer = Module._LockBuffer = wasmExports.LockBuffer)(e, t), _ReleaseBuffer = Module._ReleaseBuffer = (e) => (_ReleaseBuffer = Module._ReleaseBuffer = wasmExports.ReleaseBuffer)(e), _IndexGetRelation = Module._IndexGetRelation = (e, t) => (_IndexGetRelation = Module._IndexGetRelation = wasmExports.IndexGetRelation)(e, t), _table_open = Module._table_open = (e, t) => (_table_open = Module._table_open = wasmExports.table_open)(e, t), _ReadBufferExtended = Module._ReadBufferExtended = (e, t, r2, a2, o3) => (_ReadBufferExtended = Module._ReadBufferExtended = wasmExports.ReadBufferExtended)(e, t, r2, a2, o3), _table_close = Module._table_close = (e, t) => (_table_close = Module._table_close = wasmExports.table_close)(e, t), _build_reloptions = Module._build_reloptions = (e, t, r2, a2, o3, s4) => (_build_reloptions = Module._build_reloptions = wasmExports.build_reloptions)(e, t, r2, a2, o3, s4), _RelationGetIndexScan = Module._RelationGetIndexScan = (e, t, r2) => (_RelationGetIndexScan = Module._RelationGetIndexScan = wasmExports.RelationGetIndexScan)(e, t, r2), _pgstat_assoc_relation = Module._pgstat_assoc_relation = (e) => (_pgstat_assoc_relation = Module._pgstat_assoc_relation = wasmExports.pgstat_assoc_relation)(e), _index_getprocinfo = Module._index_getprocinfo = (e, t, r2) => (_index_getprocinfo = Module._index_getprocinfo = wasmExports.index_getprocinfo)(e, t, r2), _fmgr_info_copy = Module._fmgr_info_copy = (e, t, r2) => (_fmgr_info_copy = Module._fmgr_info_copy = wasmExports.fmgr_info_copy)(e, t, r2), _FunctionCall4Coll = Module._FunctionCall4Coll = (e, t, r2, a2, o3, s4) => (_FunctionCall4Coll = Module._FunctionCall4Coll = wasmExports.FunctionCall4Coll)(e, t, r2, a2, o3, s4), _FunctionCall1Coll = Module._FunctionCall1Coll = (e, t, r2) => (_FunctionCall1Coll = Module._FunctionCall1Coll = wasmExports.FunctionCall1Coll)(e, t, r2), _brin_free_desc = Module._brin_free_desc = (e) => (_brin_free_desc = Module._brin_free_desc = wasmExports.brin_free_desc)(e), _WaitForParallelWorkersToFinish = Module._WaitForParallelWorkersToFinish = (e) => (_WaitForParallelWorkersToFinish = Module._WaitForParallelWorkersToFinish = wasmExports.WaitForParallelWorkersToFinish)(e), _PageGetFreeSpace = Module._PageGetFreeSpace = (e) => (_PageGetFreeSpace = Module._PageGetFreeSpace = wasmExports.PageGetFreeSpace)(e), _BufferGetBlockNumber = Module._BufferGetBlockNumber = (e) => (_BufferGetBlockNumber = Module._BufferGetBlockNumber = wasmExports.BufferGetBlockNumber)(e), _BuildIndexInfo = Module._BuildIndexInfo = (e) => (_BuildIndexInfo = Module._BuildIndexInfo = wasmExports.BuildIndexInfo)(e), _Int64GetDatum = Module._Int64GetDatum = (e) => (_Int64GetDatum = Module._Int64GetDatum = wasmExports.Int64GetDatum)(e), _DirectFunctionCall2Coll = Module._DirectFunctionCall2Coll = (e, t, r2, a2) => (_DirectFunctionCall2Coll = Module._DirectFunctionCall2Coll = wasmExports.DirectFunctionCall2Coll)(e, t, r2, a2), _RecoveryInProgress = Module._RecoveryInProgress = () => (_RecoveryInProgress = Module._RecoveryInProgress = wasmExports.RecoveryInProgress)(), _GetUserIdAndSecContext = Module._GetUserIdAndSecContext = (e, t) => (_GetUserIdAndSecContext = Module._GetUserIdAndSecContext = wasmExports.GetUserIdAndSecContext)(e, t), _SetUserIdAndSecContext = Module._SetUserIdAndSecContext = (e, t) => (_SetUserIdAndSecContext = Module._SetUserIdAndSecContext = wasmExports.SetUserIdAndSecContext)(e, t), _NewGUCNestLevel = Module._NewGUCNestLevel = () => (_NewGUCNestLevel = Module._NewGUCNestLevel = wasmExports.NewGUCNestLevel)(), _RestrictSearchPath = Module._RestrictSearchPath = () => (_RestrictSearchPath = Module._RestrictSearchPath = wasmExports.RestrictSearchPath)(), _index_open = Module._index_open = (e, t) => (_index_open = Module._index_open = wasmExports.index_open)(e, t), _object_ownercheck = Module._object_ownercheck = (e, t, r2) => (_object_ownercheck = Module._object_ownercheck = wasmExports.object_ownercheck)(e, t, r2), _aclcheck_error = Module._aclcheck_error = (e, t, r2) => (_aclcheck_error = Module._aclcheck_error = wasmExports.aclcheck_error)(e, t, r2), _AtEOXact_GUC = Module._AtEOXact_GUC = (e, t) => (_AtEOXact_GUC = Module._AtEOXact_GUC = wasmExports.AtEOXact_GUC)(e, t), _relation_close = Module._relation_close = (e, t) => (_relation_close = Module._relation_close = wasmExports.relation_close)(e, t), _GetUserId = Module._GetUserId = () => (_GetUserId = Module._GetUserId = wasmExports.GetUserId)(), _ReadBuffer = Module._ReadBuffer = (e, t) => (_ReadBuffer = Module._ReadBuffer = wasmExports.ReadBuffer)(e, t), _shm_toc_lookup = Module._shm_toc_lookup = (e, t, r2) => (_shm_toc_lookup = Module._shm_toc_lookup = wasmExports.shm_toc_lookup)(e, t, r2), _tuplesort_attach_shared = Module._tuplesort_attach_shared = (e, t) => (_tuplesort_attach_shared = Module._tuplesort_attach_shared = wasmExports.tuplesort_attach_shared)(e, t), _index_close = Module._index_close = (e, t) => (_index_close = Module._index_close = wasmExports.index_close)(e, t), _table_beginscan_parallel = Module._table_beginscan_parallel = (e, t) => (_table_beginscan_parallel = Module._table_beginscan_parallel = wasmExports.table_beginscan_parallel)(e, t), _ConditionVariableSignal = Module._ConditionVariableSignal = (e) => (_ConditionVariableSignal = Module._ConditionVariableSignal = wasmExports.ConditionVariableSignal)(e), _datumCopy = Module._datumCopy = (e, t, r2) => (_datumCopy = Module._datumCopy = wasmExports.datumCopy)(e, t, r2), _lookup_type_cache = Module._lookup_type_cache = (e, t) => (_lookup_type_cache = Module._lookup_type_cache = wasmExports.lookup_type_cache)(e, t), _get_fn_opclass_options = Module._get_fn_opclass_options = (e) => (_get_fn_opclass_options = Module._get_fn_opclass_options = wasmExports.get_fn_opclass_options)(e), _pg_detoast_datum = Module._pg_detoast_datum = (e) => (_pg_detoast_datum = Module._pg_detoast_datum = wasmExports.pg_detoast_datum)(e), _index_getprocid = Module._index_getprocid = (e, t, r2) => (_index_getprocid = Module._index_getprocid = wasmExports.index_getprocid)(e, t, r2), _init_local_reloptions = Module._init_local_reloptions = (e, t) => (_init_local_reloptions = Module._init_local_reloptions = wasmExports.init_local_reloptions)(e, t), _FunctionCall2Coll = Module._FunctionCall2Coll = (e, t, r2, a2) => (_FunctionCall2Coll = Module._FunctionCall2Coll = wasmExports.FunctionCall2Coll)(e, t, r2, a2), _SysCacheGetAttrNotNull = Module._SysCacheGetAttrNotNull = (e, t, r2) => (_SysCacheGetAttrNotNull = Module._SysCacheGetAttrNotNull = wasmExports.SysCacheGetAttrNotNull)(e, t, r2), _ReleaseSysCache = Module._ReleaseSysCache = (e) => (_ReleaseSysCache = Module._ReleaseSysCache = wasmExports.ReleaseSysCache)(e), _fmgr_info_cxt = Module._fmgr_info_cxt = (e, t, r2) => (_fmgr_info_cxt = Module._fmgr_info_cxt = wasmExports.fmgr_info_cxt)(e, t, r2), _Float8GetDatum = Module._Float8GetDatum = (e) => (_Float8GetDatum = Module._Float8GetDatum = wasmExports.Float8GetDatum)(e), _numeric_sub = Module._numeric_sub = (e) => (_numeric_sub = Module._numeric_sub = wasmExports.numeric_sub)(e), _DirectFunctionCall1Coll = Module._DirectFunctionCall1Coll = (e, t, r2) => (_DirectFunctionCall1Coll = Module._DirectFunctionCall1Coll = wasmExports.DirectFunctionCall1Coll)(e, t, r2), _pg_detoast_datum_packed = Module._pg_detoast_datum_packed = (e) => (_pg_detoast_datum_packed = Module._pg_detoast_datum_packed = wasmExports.pg_detoast_datum_packed)(e), _add_local_int_reloption = Module._add_local_int_reloption = (e, t, r2, a2, o3, s4, l4) => (_add_local_int_reloption = Module._add_local_int_reloption = wasmExports.add_local_int_reloption)(e, t, r2, a2, o3, s4, l4), _getTypeOutputInfo = Module._getTypeOutputInfo = (e, t, r2) => (_getTypeOutputInfo = Module._getTypeOutputInfo = wasmExports.getTypeOutputInfo)(e, t, r2), _fmgr_info = Module._fmgr_info = (e, t) => (_fmgr_info = Module._fmgr_info = wasmExports.fmgr_info)(e, t), _OutputFunctionCall = Module._OutputFunctionCall = (e, t) => (_OutputFunctionCall = Module._OutputFunctionCall = wasmExports.OutputFunctionCall)(e, t), _cstring_to_text_with_len = Module._cstring_to_text_with_len = (e, t) => (_cstring_to_text_with_len = Module._cstring_to_text_with_len = wasmExports.cstring_to_text_with_len)(e, t), _accumArrayResult = Module._accumArrayResult = (e, t, r2, a2, o3) => (_accumArrayResult = Module._accumArrayResult = wasmExports.accumArrayResult)(e, t, r2, a2, o3), _makeArrayResult = Module._makeArrayResult = (e, t) => (_makeArrayResult = Module._makeArrayResult = wasmExports.makeArrayResult)(e, t), _OidOutputFunctionCall = Module._OidOutputFunctionCall = (e, t) => (_OidOutputFunctionCall = Module._OidOutputFunctionCall = wasmExports.OidOutputFunctionCall)(e, t), _cstring_to_text = Module._cstring_to_text = (e) => (_cstring_to_text = Module._cstring_to_text = wasmExports.cstring_to_text)(e), _PageGetExactFreeSpace = Module._PageGetExactFreeSpace = (e) => (_PageGetExactFreeSpace = Module._PageGetExactFreeSpace = wasmExports.PageGetExactFreeSpace)(e), _PageIndexTupleOverwrite = Module._PageIndexTupleOverwrite = (e, t, r2, a2) => (_PageIndexTupleOverwrite = Module._PageIndexTupleOverwrite = wasmExports.PageIndexTupleOverwrite)(e, t, r2, a2), _PageInit = Module._PageInit = (e, t, r2) => (_PageInit = Module._PageInit = wasmExports.PageInit)(e, t, r2), _PageAddItemExtended = Module._PageAddItemExtended = (e, t, r2, a2, o3) => (_PageAddItemExtended = Module._PageAddItemExtended = wasmExports.PageAddItemExtended)(e, t, r2, a2, o3), _LockRelationForExtension = Module._LockRelationForExtension = (e, t) => (_LockRelationForExtension = Module._LockRelationForExtension = wasmExports.LockRelationForExtension)(e, t), _UnlockRelationForExtension = Module._UnlockRelationForExtension = (e, t) => (_UnlockRelationForExtension = Module._UnlockRelationForExtension = wasmExports.UnlockRelationForExtension)(e, t), _smgropen = Module._smgropen = (e, t) => (_smgropen = Module._smgropen = wasmExports.smgropen)(e, t), _smgrpin = Module._smgrpin = (e) => (_smgrpin = Module._smgrpin = wasmExports.smgrpin)(e), _ItemPointerEquals = Module._ItemPointerEquals = (e, t) => (_ItemPointerEquals = Module._ItemPointerEquals = wasmExports.ItemPointerEquals)(e, t), _detoast_external_attr = Module._detoast_external_attr = (e) => (_detoast_external_attr = Module._detoast_external_attr = wasmExports.detoast_external_attr)(e), _CreateTemplateTupleDesc = Module._CreateTemplateTupleDesc = (e) => (_CreateTemplateTupleDesc = Module._CreateTemplateTupleDesc = wasmExports.CreateTemplateTupleDesc)(e), _TupleDescInitEntry = Module._TupleDescInitEntry = (e, t, r2, a2, o3, s4) => (_TupleDescInitEntry = Module._TupleDescInitEntry = wasmExports.TupleDescInitEntry)(e, t, r2, a2, o3, s4), _SearchSysCache1 = Module._SearchSysCache1 = (e, t) => (_SearchSysCache1 = Module._SearchSysCache1 = wasmExports.SearchSysCache1)(e, t), _SearchSysCacheList = Module._SearchSysCacheList = (e, t, r2, a2, o3) => (_SearchSysCacheList = Module._SearchSysCacheList = wasmExports.SearchSysCacheList)(e, t, r2, a2, o3), _check_amproc_signature = Module._check_amproc_signature = (e, t, r2, a2, o3, s4) => (_check_amproc_signature = Module._check_amproc_signature = wasmExports.check_amproc_signature)(e, t, r2, a2, o3, s4), _check_amoptsproc_signature = Module._check_amoptsproc_signature = (e) => (_check_amoptsproc_signature = Module._check_amoptsproc_signature = wasmExports.check_amoptsproc_signature)(e), _format_procedure = Module._format_procedure = (e) => (_format_procedure = Module._format_procedure = wasmExports.format_procedure)(e), _format_operator = Module._format_operator = (e) => (_format_operator = Module._format_operator = wasmExports.format_operator)(e), _check_amop_signature = Module._check_amop_signature = (e, t, r2, a2) => (_check_amop_signature = Module._check_amop_signature = wasmExports.check_amop_signature)(e, t, r2, a2), _identify_opfamily_groups = Module._identify_opfamily_groups = (e, t) => (_identify_opfamily_groups = Module._identify_opfamily_groups = wasmExports.identify_opfamily_groups)(e, t), _format_type_be = Module._format_type_be = (e) => (_format_type_be = Module._format_type_be = wasmExports.format_type_be)(e), _ReleaseCatCacheList = Module._ReleaseCatCacheList = (e) => (_ReleaseCatCacheList = Module._ReleaseCatCacheList = wasmExports.ReleaseCatCacheList)(e), _free_attrmap = Module._free_attrmap = (e) => (_free_attrmap = Module._free_attrmap = wasmExports.free_attrmap)(e), _format_type_with_typemod = Module._format_type_with_typemod = (e, t) => (_format_type_with_typemod = Module._format_type_with_typemod = wasmExports.format_type_with_typemod)(e, t), _build_attrmap_by_name_if_req = Module._build_attrmap_by_name_if_req = (e, t, r2) => (_build_attrmap_by_name_if_req = Module._build_attrmap_by_name_if_req = wasmExports.build_attrmap_by_name_if_req)(e, t, r2), _DatumGetEOHP = Module._DatumGetEOHP = (e) => (_DatumGetEOHP = Module._DatumGetEOHP = wasmExports.DatumGetEOHP)(e), _EOH_get_flat_size = Module._EOH_get_flat_size = (e) => (_EOH_get_flat_size = Module._EOH_get_flat_size = wasmExports.EOH_get_flat_size)(e), _EOH_flatten_into = Module._EOH_flatten_into = (e, t, r2) => (_EOH_flatten_into = Module._EOH_flatten_into = wasmExports.EOH_flatten_into)(e, t, r2), _getmissingattr = Module._getmissingattr = (e, t, r2) => (_getmissingattr = Module._getmissingattr = wasmExports.getmissingattr)(e, t, r2), _hash_create = Module._hash_create = (e, t, r2, a2) => (_hash_create = Module._hash_create = wasmExports.hash_create)(e, t, r2, a2), _hash_search = Module._hash_search = (e, t, r2, a2) => (_hash_search = Module._hash_search = wasmExports.hash_search)(e, t, r2, a2), _nocachegetattr = Module._nocachegetattr = (e, t, r2) => (_nocachegetattr = Module._nocachegetattr = wasmExports.nocachegetattr)(e, t, r2), _heap_form_tuple = Module._heap_form_tuple = (e, t, r2) => (_heap_form_tuple = Module._heap_form_tuple = wasmExports.heap_form_tuple)(e, t, r2), _heap_modify_tuple = Module._heap_modify_tuple = (e, t, r2, a2, o3) => (_heap_modify_tuple = Module._heap_modify_tuple = wasmExports.heap_modify_tuple)(e, t, r2, a2, o3), _heap_deform_tuple = Module._heap_deform_tuple = (e, t, r2, a2) => (_heap_deform_tuple = Module._heap_deform_tuple = wasmExports.heap_deform_tuple)(e, t, r2, a2), _heap_modify_tuple_by_cols = Module._heap_modify_tuple_by_cols = (e, t, r2, a2, o3, s4) => (_heap_modify_tuple_by_cols = Module._heap_modify_tuple_by_cols = wasmExports.heap_modify_tuple_by_cols)(e, t, r2, a2, o3, s4), _heap_freetuple = Module._heap_freetuple = (e) => (_heap_freetuple = Module._heap_freetuple = wasmExports.heap_freetuple)(e), _index_form_tuple = Module._index_form_tuple = (e, t, r2) => (_index_form_tuple = Module._index_form_tuple = wasmExports.index_form_tuple)(e, t, r2), _nocache_index_getattr = Module._nocache_index_getattr = (e, t, r2) => (_nocache_index_getattr = Module._nocache_index_getattr = wasmExports.nocache_index_getattr)(e, t, r2), _index_deform_tuple = Module._index_deform_tuple = (e, t, r2, a2) => (_index_deform_tuple = Module._index_deform_tuple = wasmExports.index_deform_tuple)(e, t, r2, a2), _slot_getsomeattrs_int = Module._slot_getsomeattrs_int = (e, t) => (_slot_getsomeattrs_int = Module._slot_getsomeattrs_int = wasmExports.slot_getsomeattrs_int)(e, t), _pg_ltoa = Module._pg_ltoa = (e, t) => (_pg_ltoa = Module._pg_ltoa = wasmExports.pg_ltoa)(e, t), _relation_open = Module._relation_open = (e, t) => (_relation_open = Module._relation_open = wasmExports.relation_open)(e, t), _LockRelationOid = Module._LockRelationOid = (e, t) => (_LockRelationOid = Module._LockRelationOid = wasmExports.LockRelationOid)(e, t), _RelationIdGetRelation = Module._RelationIdGetRelation = (e) => (_RelationIdGetRelation = Module._RelationIdGetRelation = wasmExports.RelationIdGetRelation)(e), _try_relation_open = Module._try_relation_open = (e, t) => (_try_relation_open = Module._try_relation_open = wasmExports.try_relation_open)(e, t), _SearchSysCacheExists = Module._SearchSysCacheExists = (e, t, r2, a2, o3) => (_SearchSysCacheExists = Module._SearchSysCacheExists = wasmExports.SearchSysCacheExists)(e, t, r2, a2, o3), _relation_openrv = Module._relation_openrv = (e, t) => (_relation_openrv = Module._relation_openrv = wasmExports.relation_openrv)(e, t), _RangeVarGetRelidExtended = Module._RangeVarGetRelidExtended = (e, t, r2, a2, o3) => (_RangeVarGetRelidExtended = Module._RangeVarGetRelidExtended = wasmExports.RangeVarGetRelidExtended)(e, t, r2, a2, o3), _RelationClose = Module._RelationClose = (e) => (_RelationClose = Module._RelationClose = wasmExports.RelationClose)(e), _add_reloption_kind = Module._add_reloption_kind = () => (_add_reloption_kind = Module._add_reloption_kind = wasmExports.add_reloption_kind)(), _register_reloptions_validator = Module._register_reloptions_validator = (e, t) => (_register_reloptions_validator = Module._register_reloptions_validator = wasmExports.register_reloptions_validator)(e, t), _add_int_reloption = Module._add_int_reloption = (e, t, r2, a2, o3, s4, l4) => (_add_int_reloption = Module._add_int_reloption = wasmExports.add_int_reloption)(e, t, r2, a2, o3, s4, l4), _MemoryContextStrdup = Module._MemoryContextStrdup = (e, t) => (_MemoryContextStrdup = Module._MemoryContextStrdup = wasmExports.MemoryContextStrdup)(e, t), _transformRelOptions = Module._transformRelOptions = (e, t, r2, a2, o3, s4) => (_transformRelOptions = Module._transformRelOptions = wasmExports.transformRelOptions)(e, t, r2, a2, o3, s4), _deconstruct_array_builtin = Module._deconstruct_array_builtin = (e, t, r2, a2, o3) => (_deconstruct_array_builtin = Module._deconstruct_array_builtin = wasmExports.deconstruct_array_builtin)(e, t, r2, a2, o3), _defGetString = Module._defGetString = (e) => (_defGetString = Module._defGetString = wasmExports.defGetString)(e), _defGetBoolean = Module._defGetBoolean = (e) => (_defGetBoolean = Module._defGetBoolean = wasmExports.defGetBoolean)(e), _untransformRelOptions = Module._untransformRelOptions = (e) => (_untransformRelOptions = Module._untransformRelOptions = wasmExports.untransformRelOptions)(e), _text_to_cstring = Module._text_to_cstring = (e) => (_text_to_cstring = Module._text_to_cstring = wasmExports.text_to_cstring)(e), _makeString = Module._makeString = (e) => (_makeString = Module._makeString = wasmExports.makeString)(e), _makeDefElem = Module._makeDefElem = (e, t, r2) => (_makeDefElem = Module._makeDefElem = wasmExports.makeDefElem)(e, t, r2), _heap_reloptions = Module._heap_reloptions = (e, t, r2) => (_heap_reloptions = Module._heap_reloptions = wasmExports.heap_reloptions)(e, t, r2), _MemoryContextAlloc = Module._MemoryContextAlloc = (e, t) => (_MemoryContextAlloc = Module._MemoryContextAlloc = wasmExports.MemoryContextAlloc)(e, t), _parse_bool = Module._parse_bool = (e, t) => (_parse_bool = Module._parse_bool = wasmExports.parse_bool)(e, t), _parse_int = Module._parse_int = (e, t, r2, a2) => (_parse_int = Module._parse_int = wasmExports.parse_int)(e, t, r2, a2), _parse_real = Module._parse_real = (e, t, r2, a2) => (_parse_real = Module._parse_real = wasmExports.parse_real)(e, t, r2, a2), _ScanKeyInit = Module._ScanKeyInit = (e, t, r2, a2, o3) => (_ScanKeyInit = Module._ScanKeyInit = wasmExports.ScanKeyInit)(e, t, r2, a2, o3), _dsm_segment_handle = Module._dsm_segment_handle = (e) => (_dsm_segment_handle = Module._dsm_segment_handle = wasmExports.dsm_segment_handle)(e), _dsm_create = Module._dsm_create = (e, t) => (_dsm_create = Module._dsm_create = wasmExports.dsm_create)(e, t), _dsm_segment_address = Module._dsm_segment_address = (e) => (_dsm_segment_address = Module._dsm_segment_address = wasmExports.dsm_segment_address)(e), _dsm_attach = Module._dsm_attach = (e) => (_dsm_attach = Module._dsm_attach = wasmExports.dsm_attach)(e), _dsm_detach = Module._dsm_detach = (e) => (_dsm_detach = Module._dsm_detach = wasmExports.dsm_detach)(e), _ShmemInitStruct = Module._ShmemInitStruct = (e, t, r2) => (_ShmemInitStruct = Module._ShmemInitStruct = wasmExports.ShmemInitStruct)(e, t, r2), _LWLockAcquire = Module._LWLockAcquire = (e, t) => (_LWLockAcquire = Module._LWLockAcquire = wasmExports.LWLockAcquire)(e, t), _LWLockRelease = Module._LWLockRelease = (e) => (_LWLockRelease = Module._LWLockRelease = wasmExports.LWLockRelease)(e), _LWLockInitialize = Module._LWLockInitialize = (e, t) => (_LWLockInitialize = Module._LWLockInitialize = wasmExports.LWLockInitialize)(e, t), _MemoryContextMemAllocated = Module._MemoryContextMemAllocated = (e, t) => (_MemoryContextMemAllocated = Module._MemoryContextMemAllocated = wasmExports.MemoryContextMemAllocated)(e, t), _GetCurrentCommandId = Module._GetCurrentCommandId = (e) => (_GetCurrentCommandId = Module._GetCurrentCommandId = wasmExports.GetCurrentCommandId)(e), _toast_open_indexes = Module._toast_open_indexes = (e, t, r2, a2) => (_toast_open_indexes = Module._toast_open_indexes = wasmExports.toast_open_indexes)(e, t, r2, a2), _RelationGetIndexList = Module._RelationGetIndexList = (e) => (_RelationGetIndexList = Module._RelationGetIndexList = wasmExports.RelationGetIndexList)(e), _systable_beginscan = Module._systable_beginscan = (e, t, r2, a2, o3, s4) => (_systable_beginscan = Module._systable_beginscan = wasmExports.systable_beginscan)(e, t, r2, a2, o3, s4), _systable_getnext = Module._systable_getnext = (e) => (_systable_getnext = Module._systable_getnext = wasmExports.systable_getnext)(e), _systable_endscan = Module._systable_endscan = (e) => (_systable_endscan = Module._systable_endscan = wasmExports.systable_endscan)(e), _toast_close_indexes = Module._toast_close_indexes = (e, t, r2) => (_toast_close_indexes = Module._toast_close_indexes = wasmExports.toast_close_indexes)(e, t, r2), _systable_beginscan_ordered = Module._systable_beginscan_ordered = (e, t, r2, a2, o3) => (_systable_beginscan_ordered = Module._systable_beginscan_ordered = wasmExports.systable_beginscan_ordered)(e, t, r2, a2, o3), _systable_getnext_ordered = Module._systable_getnext_ordered = (e, t) => (_systable_getnext_ordered = Module._systable_getnext_ordered = wasmExports.systable_getnext_ordered)(e, t), _systable_endscan_ordered = Module._systable_endscan_ordered = (e) => (_systable_endscan_ordered = Module._systable_endscan_ordered = wasmExports.systable_endscan_ordered)(e), _init_toast_snapshot = Module._init_toast_snapshot = (e) => (_init_toast_snapshot = Module._init_toast_snapshot = wasmExports.init_toast_snapshot)(e), _convert_tuples_by_position = Module._convert_tuples_by_position = (e, t, r2) => (_convert_tuples_by_position = Module._convert_tuples_by_position = wasmExports.convert_tuples_by_position)(e, t, r2), _execute_attr_map_tuple = Module._execute_attr_map_tuple = (e, t) => (_execute_attr_map_tuple = Module._execute_attr_map_tuple = wasmExports.execute_attr_map_tuple)(e, t), _execute_attr_map_slot = Module._execute_attr_map_slot = (e, t, r2) => (_execute_attr_map_slot = Module._execute_attr_map_slot = wasmExports.execute_attr_map_slot)(e, t, r2), _ExecStoreVirtualTuple = Module._ExecStoreVirtualTuple = (e) => (_ExecStoreVirtualTuple = Module._ExecStoreVirtualTuple = wasmExports.ExecStoreVirtualTuple)(e), _bms_is_member = Module._bms_is_member = (e, t) => (_bms_is_member = Module._bms_is_member = wasmExports.bms_is_member)(e, t), _bms_add_member = Module._bms_add_member = (e, t) => (_bms_add_member = Module._bms_add_member = wasmExports.bms_add_member)(e, t), _CreateTupleDescCopy = Module._CreateTupleDescCopy = (e) => (_CreateTupleDescCopy = Module._CreateTupleDescCopy = wasmExports.CreateTupleDescCopy)(e), _CreateTupleDescCopyConstr = Module._CreateTupleDescCopyConstr = (e) => (_CreateTupleDescCopyConstr = Module._CreateTupleDescCopyConstr = wasmExports.CreateTupleDescCopyConstr)(e), _FreeTupleDesc = Module._FreeTupleDesc = (e) => (_FreeTupleDesc = Module._FreeTupleDesc = wasmExports.FreeTupleDesc)(e), _ResourceOwnerEnlarge = Module._ResourceOwnerEnlarge = (e) => (_ResourceOwnerEnlarge = Module._ResourceOwnerEnlarge = wasmExports.ResourceOwnerEnlarge)(e), _ResourceOwnerRemember = Module._ResourceOwnerRemember = (e, t, r2) => (_ResourceOwnerRemember = Module._ResourceOwnerRemember = wasmExports.ResourceOwnerRemember)(e, t, r2), _DecrTupleDescRefCount = Module._DecrTupleDescRefCount = (e) => (_DecrTupleDescRefCount = Module._DecrTupleDescRefCount = wasmExports.DecrTupleDescRefCount)(e), _ResourceOwnerForget = Module._ResourceOwnerForget = (e, t, r2) => (_ResourceOwnerForget = Module._ResourceOwnerForget = wasmExports.ResourceOwnerForget)(e, t, r2), _datumIsEqual = Module._datumIsEqual = (e, t, r2, a2) => (_datumIsEqual = Module._datumIsEqual = wasmExports.datumIsEqual)(e, t, r2, a2), _TupleDescInitEntryCollation = Module._TupleDescInitEntryCollation = (e, t, r2) => (_TupleDescInitEntryCollation = Module._TupleDescInitEntryCollation = wasmExports.TupleDescInitEntryCollation)(e, t, r2), _stringToNode = Module._stringToNode = (e) => (_stringToNode = Module._stringToNode = wasmExports.stringToNode)(e), _pg_detoast_datum_copy = Module._pg_detoast_datum_copy = (e) => (_pg_detoast_datum_copy = Module._pg_detoast_datum_copy = wasmExports.pg_detoast_datum_copy)(e), _get_typlenbyvalalign = Module._get_typlenbyvalalign = (e, t, r2, a2) => (_get_typlenbyvalalign = Module._get_typlenbyvalalign = wasmExports.get_typlenbyvalalign)(e, t, r2, a2), _deconstruct_array = Module._deconstruct_array = (e, t, r2, a2, o3, s4, l4, _3) => (_deconstruct_array = Module._deconstruct_array = wasmExports.deconstruct_array)(e, t, r2, a2, o3, s4, l4, _3), _tbm_add_tuples = Module._tbm_add_tuples = (e, t, r2, a2) => (_tbm_add_tuples = Module._tbm_add_tuples = wasmExports.tbm_add_tuples)(e, t, r2, a2), _ginPostingListDecode = Module._ginPostingListDecode = (e, t) => (_ginPostingListDecode = Module._ginPostingListDecode = wasmExports.ginPostingListDecode)(e, t), _ItemPointerCompare = Module._ItemPointerCompare = (e, t) => (_ItemPointerCompare = Module._ItemPointerCompare = wasmExports.ItemPointerCompare)(e, t), _LockPage = Module._LockPage = (e, t, r2) => (_LockPage = Module._LockPage = wasmExports.LockPage)(e, t, r2), _UnlockPage = Module._UnlockPage = (e, t, r2) => (_UnlockPage = Module._UnlockPage = wasmExports.UnlockPage)(e, t, r2), _vacuum_delay_point = Module._vacuum_delay_point = () => (_vacuum_delay_point = Module._vacuum_delay_point = wasmExports.vacuum_delay_point)(), _RecordFreeIndexPage = Module._RecordFreeIndexPage = (e, t) => (_RecordFreeIndexPage = Module._RecordFreeIndexPage = wasmExports.RecordFreeIndexPage)(e, t), _IndexFreeSpaceMapVacuum = Module._IndexFreeSpaceMapVacuum = (e) => (_IndexFreeSpaceMapVacuum = Module._IndexFreeSpaceMapVacuum = wasmExports.IndexFreeSpaceMapVacuum)(e), _log_newpage_range = Module._log_newpage_range = (e, t, r2, a2, o3) => (_log_newpage_range = Module._log_newpage_range = wasmExports.log_newpage_range)(e, t, r2, a2, o3), _GetFreeIndexPage = Module._GetFreeIndexPage = (e) => (_GetFreeIndexPage = Module._GetFreeIndexPage = wasmExports.GetFreeIndexPage)(e), _ConditionalLockBuffer = Module._ConditionalLockBuffer = (e) => (_ConditionalLockBuffer = Module._ConditionalLockBuffer = wasmExports.ConditionalLockBuffer)(e), _LockBufferForCleanup = Module._LockBufferForCleanup = (e) => (_LockBufferForCleanup = Module._LockBufferForCleanup = wasmExports.LockBufferForCleanup)(e), _gistcheckpage = Module._gistcheckpage = (e, t) => (_gistcheckpage = Module._gistcheckpage = wasmExports.gistcheckpage)(e, t), _PageIndexMultiDelete = Module._PageIndexMultiDelete = (e, t, r2) => (_PageIndexMultiDelete = Module._PageIndexMultiDelete = wasmExports.PageIndexMultiDelete)(e, t, r2), _pow = Module._pow = (e, t) => (_pow = Module._pow = wasmExports.pow)(e, t), _smgrnblocks = Module._smgrnblocks = (e, t) => (_smgrnblocks = Module._smgrnblocks = wasmExports.smgrnblocks)(e, t), _list_free_deep = Module._list_free_deep = (e) => (_list_free_deep = Module._list_free_deep = wasmExports.list_free_deep)(e), _pairingheap_remove_first = Module._pairingheap_remove_first = (e) => (_pairingheap_remove_first = Module._pairingheap_remove_first = wasmExports.pairingheap_remove_first)(e), _pairingheap_add = Module._pairingheap_add = (e, t) => (_pairingheap_add = Module._pairingheap_add = wasmExports.pairingheap_add)(e, t), _float_overflow_error = Module._float_overflow_error = () => (_float_overflow_error = Module._float_overflow_error = wasmExports.float_overflow_error)(), _float_underflow_error = Module._float_underflow_error = () => (_float_underflow_error = Module._float_underflow_error = wasmExports.float_underflow_error)(), _DirectFunctionCall5Coll = Module._DirectFunctionCall5Coll = (e, t, r2, a2, o3, s4, l4) => (_DirectFunctionCall5Coll = Module._DirectFunctionCall5Coll = wasmExports.DirectFunctionCall5Coll)(e, t, r2, a2, o3, s4, l4), _pairingheap_allocate = Module._pairingheap_allocate = (e, t) => (_pairingheap_allocate = Module._pairingheap_allocate = wasmExports.pairingheap_allocate)(e, t), _GenerationContextCreate = Module._GenerationContextCreate = (e, t, r2, a2, o3) => (_GenerationContextCreate = Module._GenerationContextCreate = wasmExports.GenerationContextCreate)(e, t, r2, a2, o3), _pgstat_progress_update_param = Module._pgstat_progress_update_param = (e, t) => (_pgstat_progress_update_param = Module._pgstat_progress_update_param = wasmExports.pgstat_progress_update_param)(e, t), __hash_getbuf = Module.__hash_getbuf = (e, t, r2, a2) => (__hash_getbuf = Module.__hash_getbuf = wasmExports._hash_getbuf)(e, t, r2, a2), __hash_relbuf = Module.__hash_relbuf = (e, t) => (__hash_relbuf = Module.__hash_relbuf = wasmExports._hash_relbuf)(e, t), __hash_get_indextuple_hashkey = Module.__hash_get_indextuple_hashkey = (e) => (__hash_get_indextuple_hashkey = Module.__hash_get_indextuple_hashkey = wasmExports._hash_get_indextuple_hashkey)(e), __hash_getbuf_with_strategy = Module.__hash_getbuf_with_strategy = (e, t, r2, a2, o3) => (__hash_getbuf_with_strategy = Module.__hash_getbuf_with_strategy = wasmExports._hash_getbuf_with_strategy)(e, t, r2, a2, o3), __hash_ovflblkno_to_bitno = Module.__hash_ovflblkno_to_bitno = (e, t) => (__hash_ovflblkno_to_bitno = Module.__hash_ovflblkno_to_bitno = wasmExports._hash_ovflblkno_to_bitno)(e, t), _hash_destroy = Module._hash_destroy = (e) => (_hash_destroy = Module._hash_destroy = wasmExports.hash_destroy)(e), _list_member_oid = Module._list_member_oid = (e, t) => (_list_member_oid = Module._list_member_oid = wasmExports.list_member_oid)(e, t), _HeapTupleSatisfiesVisibility = Module._HeapTupleSatisfiesVisibility = (e, t, r2) => (_HeapTupleSatisfiesVisibility = Module._HeapTupleSatisfiesVisibility = wasmExports.HeapTupleSatisfiesVisibility)(e, t, r2), _read_stream_begin_relation = Module._read_stream_begin_relation = (e, t, r2, a2, o3, s4, l4) => (_read_stream_begin_relation = Module._read_stream_begin_relation = wasmExports.read_stream_begin_relation)(e, t, r2, a2, o3, s4, l4), _GetAccessStrategy = Module._GetAccessStrategy = (e) => (_GetAccessStrategy = Module._GetAccessStrategy = wasmExports.GetAccessStrategy)(e), _FreeAccessStrategy = Module._FreeAccessStrategy = (e) => (_FreeAccessStrategy = Module._FreeAccessStrategy = wasmExports.FreeAccessStrategy)(e), _read_stream_end = Module._read_stream_end = (e) => (_read_stream_end = Module._read_stream_end = wasmExports.read_stream_end)(e), _heap_getnext = Module._heap_getnext = (e, t) => (_heap_getnext = Module._heap_getnext = wasmExports.heap_getnext)(e, t), _HeapTupleSatisfiesVacuum = Module._HeapTupleSatisfiesVacuum = (e, t, r2) => (_HeapTupleSatisfiesVacuum = Module._HeapTupleSatisfiesVacuum = wasmExports.HeapTupleSatisfiesVacuum)(e, t, r2), _GetMultiXactIdMembers = Module._GetMultiXactIdMembers = (e, t, r2, a2) => (_GetMultiXactIdMembers = Module._GetMultiXactIdMembers = wasmExports.GetMultiXactIdMembers)(e, t, r2, a2), _TransactionIdPrecedes = Module._TransactionIdPrecedes = (e, t) => (_TransactionIdPrecedes = Module._TransactionIdPrecedes = wasmExports.TransactionIdPrecedes)(e, t), _HeapTupleGetUpdateXid = Module._HeapTupleGetUpdateXid = (e) => (_HeapTupleGetUpdateXid = Module._HeapTupleGetUpdateXid = wasmExports.HeapTupleGetUpdateXid)(e), _visibilitymap_clear = Module._visibilitymap_clear = (e, t, r2, a2) => (_visibilitymap_clear = Module._visibilitymap_clear = wasmExports.visibilitymap_clear)(e, t, r2, a2), _pgstat_count_heap_insert = Module._pgstat_count_heap_insert = (e, t) => (_pgstat_count_heap_insert = Module._pgstat_count_heap_insert = wasmExports.pgstat_count_heap_insert)(e, t), _ExecFetchSlotHeapTuple = Module._ExecFetchSlotHeapTuple = (e, t, r2) => (_ExecFetchSlotHeapTuple = Module._ExecFetchSlotHeapTuple = wasmExports.ExecFetchSlotHeapTuple)(e, t, r2), _PageGetHeapFreeSpace = Module._PageGetHeapFreeSpace = (e) => (_PageGetHeapFreeSpace = Module._PageGetHeapFreeSpace = wasmExports.PageGetHeapFreeSpace)(e), _visibilitymap_pin = Module._visibilitymap_pin = (e, t, r2) => (_visibilitymap_pin = Module._visibilitymap_pin = wasmExports.visibilitymap_pin)(e, t, r2), _HeapTupleSatisfiesUpdate = Module._HeapTupleSatisfiesUpdate = (e, t, r2) => (_HeapTupleSatisfiesUpdate = Module._HeapTupleSatisfiesUpdate = wasmExports.HeapTupleSatisfiesUpdate)(e, t, r2), _TransactionIdIsCurrentTransactionId = Module._TransactionIdIsCurrentTransactionId = (e) => (_TransactionIdIsCurrentTransactionId = Module._TransactionIdIsCurrentTransactionId = wasmExports.TransactionIdIsCurrentTransactionId)(e), _TransactionIdDidCommit = Module._TransactionIdDidCommit = (e) => (_TransactionIdDidCommit = Module._TransactionIdDidCommit = wasmExports.TransactionIdDidCommit)(e), _TransactionIdIsInProgress = Module._TransactionIdIsInProgress = (e) => (_TransactionIdIsInProgress = Module._TransactionIdIsInProgress = wasmExports.TransactionIdIsInProgress)(e), _bms_free = Module._bms_free = (e) => (_bms_free = Module._bms_free = wasmExports.bms_free)(e), _bms_add_members = Module._bms_add_members = (e, t) => (_bms_add_members = Module._bms_add_members = wasmExports.bms_add_members)(e, t), _bms_next_member = Module._bms_next_member = (e, t) => (_bms_next_member = Module._bms_next_member = wasmExports.bms_next_member)(e, t), _bms_overlap = Module._bms_overlap = (e, t) => (_bms_overlap = Module._bms_overlap = wasmExports.bms_overlap)(e, t), _MultiXactIdPrecedes = Module._MultiXactIdPrecedes = (e, t) => (_MultiXactIdPrecedes = Module._MultiXactIdPrecedes = wasmExports.MultiXactIdPrecedes)(e, t), _heap_tuple_needs_eventual_freeze = Module._heap_tuple_needs_eventual_freeze = (e) => (_heap_tuple_needs_eventual_freeze = Module._heap_tuple_needs_eventual_freeze = wasmExports.heap_tuple_needs_eventual_freeze)(e), _PrefetchBuffer = Module._PrefetchBuffer = (e, t, r2, a2) => (_PrefetchBuffer = Module._PrefetchBuffer = wasmExports.PrefetchBuffer)(e, t, r2, a2), _XLogRecGetBlockTagExtended = Module._XLogRecGetBlockTagExtended = (e, t, r2, a2, o3, s4) => (_XLogRecGetBlockTagExtended = Module._XLogRecGetBlockTagExtended = wasmExports.XLogRecGetBlockTagExtended)(e, t, r2, a2, o3, s4), _read_stream_next_buffer = Module._read_stream_next_buffer = (e, t) => (_read_stream_next_buffer = Module._read_stream_next_buffer = wasmExports.read_stream_next_buffer)(e, t), _smgrexists = Module._smgrexists = (e, t) => (_smgrexists = Module._smgrexists = wasmExports.smgrexists)(e, t), _table_slot_create = Module._table_slot_create = (e, t) => (_table_slot_create = Module._table_slot_create = wasmExports.table_slot_create)(e, t), _ExecDropSingleTupleTableSlot = Module._ExecDropSingleTupleTableSlot = (e) => (_ExecDropSingleTupleTableSlot = Module._ExecDropSingleTupleTableSlot = wasmExports.ExecDropSingleTupleTableSlot)(e), _CreateExecutorState = Module._CreateExecutorState = () => (_CreateExecutorState = Module._CreateExecutorState = wasmExports.CreateExecutorState)(), _MakePerTupleExprContext = Module._MakePerTupleExprContext = (e) => (_MakePerTupleExprContext = Module._MakePerTupleExprContext = wasmExports.MakePerTupleExprContext)(e), _GetOldestNonRemovableTransactionId = Module._GetOldestNonRemovableTransactionId = (e) => (_GetOldestNonRemovableTransactionId = Module._GetOldestNonRemovableTransactionId = wasmExports.GetOldestNonRemovableTransactionId)(e), _FreeExecutorState = Module._FreeExecutorState = (e) => (_FreeExecutorState = Module._FreeExecutorState = wasmExports.FreeExecutorState)(e), _MakeSingleTupleTableSlot = Module._MakeSingleTupleTableSlot = (e, t) => (_MakeSingleTupleTableSlot = Module._MakeSingleTupleTableSlot = wasmExports.MakeSingleTupleTableSlot)(e, t), _ExecStoreHeapTuple = Module._ExecStoreHeapTuple = (e, t, r2) => (_ExecStoreHeapTuple = Module._ExecStoreHeapTuple = wasmExports.ExecStoreHeapTuple)(e, t, r2), _visibilitymap_get_status = Module._visibilitymap_get_status = (e, t, r2) => (_visibilitymap_get_status = Module._visibilitymap_get_status = wasmExports.visibilitymap_get_status)(e, t, r2), _ExecStoreAllNullTuple = Module._ExecStoreAllNullTuple = (e) => (_ExecStoreAllNullTuple = Module._ExecStoreAllNullTuple = wasmExports.ExecStoreAllNullTuple)(e), _XidInMVCCSnapshot = Module._XidInMVCCSnapshot = (e, t) => (_XidInMVCCSnapshot = Module._XidInMVCCSnapshot = wasmExports.XidInMVCCSnapshot)(e, t), _hash_seq_init = Module._hash_seq_init = (e, t) => (_hash_seq_init = Module._hash_seq_init = wasmExports.hash_seq_init)(e, t), _hash_seq_search = Module._hash_seq_search = (e) => (_hash_seq_search = Module._hash_seq_search = wasmExports.hash_seq_search)(e), _ftruncate = Module._ftruncate = (e, t) => (_ftruncate = Module._ftruncate = wasmExports.ftruncate)(e, t), _fd_fsync_fname = Module._fd_fsync_fname = (e, t) => (_fd_fsync_fname = Module._fd_fsync_fname = wasmExports.fd_fsync_fname)(e, t), _get_namespace_name = Module._get_namespace_name = (e) => (_get_namespace_name = Module._get_namespace_name = wasmExports.get_namespace_name)(e), _GetRecordedFreeSpace = Module._GetRecordedFreeSpace = (e, t) => (_GetRecordedFreeSpace = Module._GetRecordedFreeSpace = wasmExports.GetRecordedFreeSpace)(e, t), _vac_estimate_reltuples = Module._vac_estimate_reltuples = (e, t, r2, a2) => (_vac_estimate_reltuples = Module._vac_estimate_reltuples = wasmExports.vac_estimate_reltuples)(e, t, r2, a2), _WaitLatch = Module._WaitLatch = (e, t, r2, a2) => (_WaitLatch = Module._WaitLatch = wasmExports.WaitLatch)(e, t, r2, a2), _ResetLatch = Module._ResetLatch = (e) => (_ResetLatch = Module._ResetLatch = wasmExports.ResetLatch)(e), _clock_gettime = Module._clock_gettime = (e, t) => (_clock_gettime = Module._clock_gettime = wasmExports.clock_gettime)(e, t), _WalUsageAccumDiff = Module._WalUsageAccumDiff = (e, t, r2) => (_WalUsageAccumDiff = Module._WalUsageAccumDiff = wasmExports.WalUsageAccumDiff)(e, t, r2), _BufferUsageAccumDiff = Module._BufferUsageAccumDiff = (e, t, r2) => (_BufferUsageAccumDiff = Module._BufferUsageAccumDiff = wasmExports.BufferUsageAccumDiff)(e, t, r2), _visibilitymap_prepare_truncate = Module._visibilitymap_prepare_truncate = (e, t) => (_visibilitymap_prepare_truncate = Module._visibilitymap_prepare_truncate = wasmExports.visibilitymap_prepare_truncate)(e, t), _pg_class_aclcheck = Module._pg_class_aclcheck = (e, t, r2) => (_pg_class_aclcheck = Module._pg_class_aclcheck = wasmExports.pg_class_aclcheck)(e, t, r2), _btboolcmp = Module._btboolcmp = (e) => (_btboolcmp = Module._btboolcmp = wasmExports.btboolcmp)(e), _btint2cmp = Module._btint2cmp = (e) => (_btint2cmp = Module._btint2cmp = wasmExports.btint2cmp)(e), _btint4cmp = Module._btint4cmp = (e) => (_btint4cmp = Module._btint4cmp = wasmExports.btint4cmp)(e), _btint8cmp = Module._btint8cmp = (e) => (_btint8cmp = Module._btint8cmp = wasmExports.btint8cmp)(e), _btoidcmp = Module._btoidcmp = (e) => (_btoidcmp = Module._btoidcmp = wasmExports.btoidcmp)(e), _btcharcmp = Module._btcharcmp = (e) => (_btcharcmp = Module._btcharcmp = wasmExports.btcharcmp)(e), __bt_form_posting = Module.__bt_form_posting = (e, t, r2) => (__bt_form_posting = Module.__bt_form_posting = wasmExports._bt_form_posting)(e, t, r2), __bt_mkscankey = Module.__bt_mkscankey = (e, t) => (__bt_mkscankey = Module.__bt_mkscankey = wasmExports._bt_mkscankey)(e, t), __bt_checkpage = Module.__bt_checkpage = (e, t) => (__bt_checkpage = Module.__bt_checkpage = wasmExports._bt_checkpage)(e, t), __bt_compare = Module.__bt_compare = (e, t, r2, a2) => (__bt_compare = Module.__bt_compare = wasmExports._bt_compare)(e, t, r2, a2), __bt_relbuf = Module.__bt_relbuf = (e, t) => (__bt_relbuf = Module.__bt_relbuf = wasmExports._bt_relbuf)(e, t), __bt_search = Module.__bt_search = (e, t, r2, a2, o3) => (__bt_search = Module.__bt_search = wasmExports._bt_search)(e, t, r2, a2, o3), __bt_binsrch_insert = Module.__bt_binsrch_insert = (e, t) => (__bt_binsrch_insert = Module.__bt_binsrch_insert = wasmExports._bt_binsrch_insert)(e, t), __bt_freestack = Module.__bt_freestack = (e) => (__bt_freestack = Module.__bt_freestack = wasmExports._bt_freestack)(e), __bt_metaversion = Module.__bt_metaversion = (e, t, r2) => (__bt_metaversion = Module.__bt_metaversion = wasmExports._bt_metaversion)(e, t, r2), __bt_allequalimage = Module.__bt_allequalimage = (e, t) => (__bt_allequalimage = Module.__bt_allequalimage = wasmExports._bt_allequalimage)(e, t), _before_shmem_exit = Module._before_shmem_exit = (e, t) => (_before_shmem_exit = Module._before_shmem_exit = wasmExports.before_shmem_exit)(e, t), _cancel_before_shmem_exit = Module._cancel_before_shmem_exit = (e, t) => (_cancel_before_shmem_exit = Module._cancel_before_shmem_exit = wasmExports.cancel_before_shmem_exit)(e, t), _pg_re_throw = Module._pg_re_throw = () => (_pg_re_throw = Module._pg_re_throw = wasmExports.pg_re_throw)(), _get_opfamily_member = Module._get_opfamily_member = (e, t, r2, a2) => (_get_opfamily_member = Module._get_opfamily_member = wasmExports.get_opfamily_member)(e, t, r2, a2), __bt_check_natts = Module.__bt_check_natts = (e, t, r2, a2) => (__bt_check_natts = Module.__bt_check_natts = wasmExports._bt_check_natts)(e, t, r2, a2), _strncpy = Module._strncpy = (e, t, r2) => (_strncpy = Module._strncpy = wasmExports.strncpy)(e, t, r2), _timestamptz_to_str = Module._timestamptz_to_str = (e) => (_timestamptz_to_str = Module._timestamptz_to_str = wasmExports.timestamptz_to_str)(e), _XLogRecGetBlockRefInfo = Module._XLogRecGetBlockRefInfo = (e, t, r2, a2, o3) => (_XLogRecGetBlockRefInfo = Module._XLogRecGetBlockRefInfo = wasmExports.XLogRecGetBlockRefInfo)(e, t, r2, a2, o3), _varstr_cmp = Module._varstr_cmp = (e, t, r2, a2, o3) => (_varstr_cmp = Module._varstr_cmp = wasmExports.varstr_cmp)(e, t, r2, a2, o3), _exprType = Module._exprType = (e) => (_exprType = Module._exprType = wasmExports.exprType)(e), _GetActiveSnapshot = Module._GetActiveSnapshot = () => (_GetActiveSnapshot = Module._GetActiveSnapshot = wasmExports.GetActiveSnapshot)(), _errdetail_relkind_not_supported = Module._errdetail_relkind_not_supported = (e) => (_errdetail_relkind_not_supported = Module._errdetail_relkind_not_supported = wasmExports.errdetail_relkind_not_supported)(e), _table_openrv = Module._table_openrv = (e, t) => (_table_openrv = Module._table_openrv = wasmExports.table_openrv)(e, t), _table_slot_callbacks = Module._table_slot_callbacks = (e) => (_table_slot_callbacks = Module._table_slot_callbacks = wasmExports.table_slot_callbacks)(e), _estimate_expression_value = Module._estimate_expression_value = (e, t) => (_estimate_expression_value = Module._estimate_expression_value = wasmExports.estimate_expression_value)(e, t), _clamp_row_est = Module._clamp_row_est = (e) => (_clamp_row_est = Module._clamp_row_est = wasmExports.clamp_row_est)(e), _XLogFlush = Module._XLogFlush = (e) => (_XLogFlush = Module._XLogFlush = wasmExports.XLogFlush)(e), _get_call_result_type = Module._get_call_result_type = (e, t, r2) => (_get_call_result_type = Module._get_call_result_type = wasmExports.get_call_result_type)(e, t, r2), _HeapTupleHeaderGetDatum = Module._HeapTupleHeaderGetDatum = (e) => (_HeapTupleHeaderGetDatum = Module._HeapTupleHeaderGetDatum = wasmExports.HeapTupleHeaderGetDatum)(e), _GenericXLogStart = Module._GenericXLogStart = (e) => (_GenericXLogStart = Module._GenericXLogStart = wasmExports.GenericXLogStart)(e), _GenericXLogRegisterBuffer = Module._GenericXLogRegisterBuffer = (e, t, r2) => (_GenericXLogRegisterBuffer = Module._GenericXLogRegisterBuffer = wasmExports.GenericXLogRegisterBuffer)(e, t, r2), _GenericXLogFinish = Module._GenericXLogFinish = (e) => (_GenericXLogFinish = Module._GenericXLogFinish = wasmExports.GenericXLogFinish)(e), _GenericXLogAbort = Module._GenericXLogAbort = (e) => (_GenericXLogAbort = Module._GenericXLogAbort = wasmExports.GenericXLogAbort)(e), _errmsg_plural = Module._errmsg_plural = (e, t, r2, a2) => (_errmsg_plural = Module._errmsg_plural = wasmExports.errmsg_plural)(e, t, r2, a2), _ReadNextMultiXactId = Module._ReadNextMultiXactId = () => (_ReadNextMultiXactId = Module._ReadNextMultiXactId = wasmExports.ReadNextMultiXactId)(), _ReadMultiXactIdRange = Module._ReadMultiXactIdRange = (e, t) => (_ReadMultiXactIdRange = Module._ReadMultiXactIdRange = wasmExports.ReadMultiXactIdRange)(e, t), _MultiXactIdPrecedesOrEquals = Module._MultiXactIdPrecedesOrEquals = (e, t) => (_MultiXactIdPrecedesOrEquals = Module._MultiXactIdPrecedesOrEquals = wasmExports.MultiXactIdPrecedesOrEquals)(e, t), _init_MultiFuncCall = Module._init_MultiFuncCall = (e) => (_init_MultiFuncCall = Module._init_MultiFuncCall = wasmExports.init_MultiFuncCall)(e), _TupleDescGetAttInMetadata = Module._TupleDescGetAttInMetadata = (e) => (_TupleDescGetAttInMetadata = Module._TupleDescGetAttInMetadata = wasmExports.TupleDescGetAttInMetadata)(e), _per_MultiFuncCall = Module._per_MultiFuncCall = (e) => (_per_MultiFuncCall = Module._per_MultiFuncCall = wasmExports.per_MultiFuncCall)(e), _BuildTupleFromCStrings = Module._BuildTupleFromCStrings = (e, t) => (_BuildTupleFromCStrings = Module._BuildTupleFromCStrings = wasmExports.BuildTupleFromCStrings)(e, t), _end_MultiFuncCall = Module._end_MultiFuncCall = (e, t) => (_end_MultiFuncCall = Module._end_MultiFuncCall = wasmExports.end_MultiFuncCall)(e, t), _GetCurrentSubTransactionId = Module._GetCurrentSubTransactionId = () => (_GetCurrentSubTransactionId = Module._GetCurrentSubTransactionId = wasmExports.GetCurrentSubTransactionId)(), _WaitForBackgroundWorkerShutdown = Module._WaitForBackgroundWorkerShutdown = (e) => (_WaitForBackgroundWorkerShutdown = Module._WaitForBackgroundWorkerShutdown = wasmExports.WaitForBackgroundWorkerShutdown)(e), _RegisterDynamicBackgroundWorker = Module._RegisterDynamicBackgroundWorker = (e, t) => (_RegisterDynamicBackgroundWorker = Module._RegisterDynamicBackgroundWorker = wasmExports.RegisterDynamicBackgroundWorker)(e, t), _BackgroundWorkerUnblockSignals = Module._BackgroundWorkerUnblockSignals = () => (_BackgroundWorkerUnblockSignals = Module._BackgroundWorkerUnblockSignals = wasmExports.BackgroundWorkerUnblockSignals)(), _BackgroundWorkerInitializeConnectionByOid = Module._BackgroundWorkerInitializeConnectionByOid = (e, t, r2) => (_BackgroundWorkerInitializeConnectionByOid = Module._BackgroundWorkerInitializeConnectionByOid = wasmExports.BackgroundWorkerInitializeConnectionByOid)(e, t, r2), _GetDatabaseEncoding = Module._GetDatabaseEncoding = () => (_GetDatabaseEncoding = Module._GetDatabaseEncoding = wasmExports.GetDatabaseEncoding)(), _RmgrNotFound = Module._RmgrNotFound = (e) => (_RmgrNotFound = Module._RmgrNotFound = wasmExports.RmgrNotFound)(e), _InitMaterializedSRF = Module._InitMaterializedSRF = (e, t) => (_InitMaterializedSRF = Module._InitMaterializedSRF = wasmExports.InitMaterializedSRF)(e, t), _tuplestore_putvalues = Module._tuplestore_putvalues = (e, t, r2, a2) => (_tuplestore_putvalues = Module._tuplestore_putvalues = wasmExports.tuplestore_putvalues)(e, t, r2, a2), _lseek = Module._lseek = (e, t, r2) => (_lseek = Module._lseek = wasmExports.lseek)(e, t, r2), _AllocateFile = Module._AllocateFile = (e, t) => (_AllocateFile = Module._AllocateFile = wasmExports.AllocateFile)(e, t), _FreeFile = Module._FreeFile = (e) => (_FreeFile = Module._FreeFile = wasmExports.FreeFile)(e), _fd_durable_rename = Module._fd_durable_rename = (e, t, r2) => (_fd_durable_rename = Module._fd_durable_rename = wasmExports.fd_durable_rename)(e, t, r2), _BlessTupleDesc = Module._BlessTupleDesc = (e) => (_BlessTupleDesc = Module._BlessTupleDesc = wasmExports.BlessTupleDesc)(e), _fstat = Module._fstat = (e, t) => (_fstat = Module._fstat = wasmExports.fstat)(e, t), _superuser_arg = Module._superuser_arg = (e) => (_superuser_arg = Module._superuser_arg = wasmExports.superuser_arg)(e), _wal_segment_close = Module._wal_segment_close = (e) => (_wal_segment_close = Module._wal_segment_close = wasmExports.wal_segment_close)(e), _wal_segment_open = Module._wal_segment_open = (e, t, r2) => (_wal_segment_open = Module._wal_segment_open = wasmExports.wal_segment_open)(e, t, r2), _XLogReaderAllocate = Module._XLogReaderAllocate = (e, t, r2, a2) => (_XLogReaderAllocate = Module._XLogReaderAllocate = wasmExports.XLogReaderAllocate)(e, t, r2, a2), _XLogReadRecord = Module._XLogReadRecord = (e, t) => (_XLogReadRecord = Module._XLogReadRecord = wasmExports.XLogReadRecord)(e, t), _XLogReaderFree = Module._XLogReaderFree = (e) => (_XLogReaderFree = Module._XLogReaderFree = wasmExports.XLogReaderFree)(e), _GetTopFullTransactionId = Module._GetTopFullTransactionId = () => (_GetTopFullTransactionId = Module._GetTopFullTransactionId = wasmExports.GetTopFullTransactionId)(), _GetCurrentTransactionNestLevel = Module._GetCurrentTransactionNestLevel = () => (_GetCurrentTransactionNestLevel = Module._GetCurrentTransactionNestLevel = wasmExports.GetCurrentTransactionNestLevel)(), _ResourceOwnerCreate = Module._ResourceOwnerCreate = (e, t) => (_ResourceOwnerCreate = Module._ResourceOwnerCreate = wasmExports.ResourceOwnerCreate)(e, t), _RegisterXactCallback = Module._RegisterXactCallback = (e, t) => (_RegisterXactCallback = Module._RegisterXactCallback = wasmExports.RegisterXactCallback)(e, t), _RegisterSubXactCallback = Module._RegisterSubXactCallback = (e, t) => (_RegisterSubXactCallback = Module._RegisterSubXactCallback = wasmExports.RegisterSubXactCallback)(e, t), _BeginInternalSubTransaction = Module._BeginInternalSubTransaction = (e) => (_BeginInternalSubTransaction = Module._BeginInternalSubTransaction = wasmExports.BeginInternalSubTransaction)(e), _ReleaseCurrentSubTransaction = Module._ReleaseCurrentSubTransaction = () => (_ReleaseCurrentSubTransaction = Module._ReleaseCurrentSubTransaction = wasmExports.ReleaseCurrentSubTransaction)(), _ResourceOwnerDelete = Module._ResourceOwnerDelete = (e) => (_ResourceOwnerDelete = Module._ResourceOwnerDelete = wasmExports.ResourceOwnerDelete)(e), _RollbackAndReleaseCurrentSubTransaction = Module._RollbackAndReleaseCurrentSubTransaction = () => (_RollbackAndReleaseCurrentSubTransaction = Module._RollbackAndReleaseCurrentSubTransaction = wasmExports.RollbackAndReleaseCurrentSubTransaction)(), _ReleaseExternalFD = Module._ReleaseExternalFD = () => (_ReleaseExternalFD = Module._ReleaseExternalFD = wasmExports.ReleaseExternalFD)(), _GetFlushRecPtr = Module._GetFlushRecPtr = (e) => (_GetFlushRecPtr = Module._GetFlushRecPtr = wasmExports.GetFlushRecPtr)(e), _GetXLogReplayRecPtr = Module._GetXLogReplayRecPtr = (e) => (_GetXLogReplayRecPtr = Module._GetXLogReplayRecPtr = wasmExports.GetXLogReplayRecPtr)(e), _TimestampDifferenceMilliseconds = Module._TimestampDifferenceMilliseconds = (e, t) => (_TimestampDifferenceMilliseconds = Module._TimestampDifferenceMilliseconds = wasmExports.TimestampDifferenceMilliseconds)(e, t), _numeric_in = Module._numeric_in = (e) => (_numeric_in = Module._numeric_in = wasmExports.numeric_in)(e), _DirectFunctionCall3Coll = Module._DirectFunctionCall3Coll = (e, t, r2, a2, o3) => (_DirectFunctionCall3Coll = Module._DirectFunctionCall3Coll = wasmExports.DirectFunctionCall3Coll)(e, t, r2, a2, o3), _XLogFindNextRecord = Module._XLogFindNextRecord = (e, t) => (_XLogFindNextRecord = Module._XLogFindNextRecord = wasmExports.XLogFindNextRecord)(e, t), _RestoreBlockImage = Module._RestoreBlockImage = (e, t, r2) => (_RestoreBlockImage = Module._RestoreBlockImage = wasmExports.RestoreBlockImage)(e, t, r2), _timestamptz_in = Module._timestamptz_in = (e) => (_timestamptz_in = Module._timestamptz_in = wasmExports.timestamptz_in)(e), _fscanf = Module._fscanf = (e, t, r2) => (_fscanf = Module._fscanf = wasmExports.fscanf)(e, t, r2), _XLogRecStoreStats = Module._XLogRecStoreStats = (e, t) => (_XLogRecStoreStats = Module._XLogRecStoreStats = wasmExports.XLogRecStoreStats)(e, t), _hash_get_num_entries = Module._hash_get_num_entries = (e) => (_hash_get_num_entries = Module._hash_get_num_entries = wasmExports.hash_get_num_entries)(e), _read_local_xlog_page_no_wait = Module._read_local_xlog_page_no_wait = (e, t, r2, a2, o3) => (_read_local_xlog_page_no_wait = Module._read_local_xlog_page_no_wait = wasmExports.read_local_xlog_page_no_wait)(e, t, r2, a2, o3), _escape_json = Module._escape_json = (e, t) => (_escape_json = Module._escape_json = wasmExports.escape_json)(e, t), _list_sort = Module._list_sort = (e, t) => (_list_sort = Module._list_sort = wasmExports.list_sort)(e, t), _pg_checksum_page = Module._pg_checksum_page = (e, t) => (_pg_checksum_page = Module._pg_checksum_page = wasmExports.pg_checksum_page)(e, t), _bbsink_forward_end_archive = Module._bbsink_forward_end_archive = (e) => (_bbsink_forward_end_archive = Module._bbsink_forward_end_archive = wasmExports.bbsink_forward_end_archive)(e), _bbsink_forward_begin_manifest = Module._bbsink_forward_begin_manifest = (e) => (_bbsink_forward_begin_manifest = Module._bbsink_forward_begin_manifest = wasmExports.bbsink_forward_begin_manifest)(e), _bbsink_forward_end_manifest = Module._bbsink_forward_end_manifest = (e) => (_bbsink_forward_end_manifest = Module._bbsink_forward_end_manifest = wasmExports.bbsink_forward_end_manifest)(e), _bbsink_forward_end_backup = Module._bbsink_forward_end_backup = (e, t, r2) => (_bbsink_forward_end_backup = Module._bbsink_forward_end_backup = wasmExports.bbsink_forward_end_backup)(e, t, r2), _bbsink_forward_cleanup = Module._bbsink_forward_cleanup = (e) => (_bbsink_forward_cleanup = Module._bbsink_forward_cleanup = wasmExports.bbsink_forward_cleanup)(e), _list_concat = Module._list_concat = (e, t) => (_list_concat = Module._list_concat = wasmExports.list_concat)(e, t), _bbsink_forward_begin_backup = Module._bbsink_forward_begin_backup = (e) => (_bbsink_forward_begin_backup = Module._bbsink_forward_begin_backup = wasmExports.bbsink_forward_begin_backup)(e), _bbsink_forward_archive_contents = Module._bbsink_forward_archive_contents = (e, t) => (_bbsink_forward_archive_contents = Module._bbsink_forward_archive_contents = wasmExports.bbsink_forward_archive_contents)(e, t), _bbsink_forward_begin_archive = Module._bbsink_forward_begin_archive = (e, t) => (_bbsink_forward_begin_archive = Module._bbsink_forward_begin_archive = wasmExports.bbsink_forward_begin_archive)(e, t), _bbsink_forward_manifest_contents = Module._bbsink_forward_manifest_contents = (e, t) => (_bbsink_forward_manifest_contents = Module._bbsink_forward_manifest_contents = wasmExports.bbsink_forward_manifest_contents)(e, t), _has_privs_of_role = Module._has_privs_of_role = (e, t) => (_has_privs_of_role = Module._has_privs_of_role = wasmExports.has_privs_of_role)(e, t), _BaseBackupAddTarget = Module._BaseBackupAddTarget = (e, t, r2) => (_BaseBackupAddTarget = Module._BaseBackupAddTarget = wasmExports.BaseBackupAddTarget)(e, t, r2), _list_copy = Module._list_copy = (e) => (_list_copy = Module._list_copy = wasmExports.list_copy)(e), _tuplestore_puttuple = Module._tuplestore_puttuple = (e, t) => (_tuplestore_puttuple = Module._tuplestore_puttuple = wasmExports.tuplestore_puttuple)(e, t), _makeRangeVar = Module._makeRangeVar = (e, t, r2) => (_makeRangeVar = Module._makeRangeVar = wasmExports.makeRangeVar)(e, t, r2), _DefineIndex = Module._DefineIndex = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3) => (_DefineIndex = Module._DefineIndex = wasmExports.DefineIndex)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3), _fread = Module._fread = (e, t, r2, a2) => (_fread = Module._fread = wasmExports.fread)(e, t, r2, a2), _clearerr = Module._clearerr = (e) => (_clearerr = Module._clearerr = wasmExports.clearerr)(e), _copyObjectImpl = Module._copyObjectImpl = (e) => (_copyObjectImpl = Module._copyObjectImpl = wasmExports.copyObjectImpl)(e), _lappend_oid = Module._lappend_oid = (e, t) => (_lappend_oid = Module._lappend_oid = wasmExports.lappend_oid)(e, t), _makeTypeNameFromNameList = Module._makeTypeNameFromNameList = (e) => (_makeTypeNameFromNameList = Module._makeTypeNameFromNameList = wasmExports.makeTypeNameFromNameList)(e), _SearchSysCache2 = Module._SearchSysCache2 = (e, t, r2) => (_SearchSysCache2 = Module._SearchSysCache2 = wasmExports.SearchSysCache2)(e, t, r2), _SysCacheGetAttr = Module._SysCacheGetAttr = (e, t, r2, a2) => (_SysCacheGetAttr = Module._SysCacheGetAttr = wasmExports.SysCacheGetAttr)(e, t, r2, a2), _CatalogTupleUpdate = Module._CatalogTupleUpdate = (e, t, r2) => (_CatalogTupleUpdate = Module._CatalogTupleUpdate = wasmExports.CatalogTupleUpdate)(e, t, r2), _get_rel_name = Module._get_rel_name = (e) => (_get_rel_name = Module._get_rel_name = wasmExports.get_rel_name)(e), _CatalogTupleDelete = Module._CatalogTupleDelete = (e, t) => (_CatalogTupleDelete = Module._CatalogTupleDelete = wasmExports.CatalogTupleDelete)(e, t), _CatalogTupleInsert = Module._CatalogTupleInsert = (e, t) => (_CatalogTupleInsert = Module._CatalogTupleInsert = wasmExports.CatalogTupleInsert)(e, t), _recordDependencyOn = Module._recordDependencyOn = (e, t, r2) => (_recordDependencyOn = Module._recordDependencyOn = wasmExports.recordDependencyOn)(e, t, r2), _get_element_type = Module._get_element_type = (e) => (_get_element_type = Module._get_element_type = wasmExports.get_element_type)(e), _object_aclcheck = Module._object_aclcheck = (e, t, r2, a2) => (_object_aclcheck = Module._object_aclcheck = wasmExports.object_aclcheck)(e, t, r2, a2), _superuser = Module._superuser = () => (_superuser = Module._superuser = wasmExports.superuser)(), _SearchSysCacheAttName = Module._SearchSysCacheAttName = (e, t) => (_SearchSysCacheAttName = Module._SearchSysCacheAttName = wasmExports.SearchSysCacheAttName)(e, t), _new_object_addresses = Module._new_object_addresses = () => (_new_object_addresses = Module._new_object_addresses = wasmExports.new_object_addresses)(), _free_object_addresses = Module._free_object_addresses = (e) => (_free_object_addresses = Module._free_object_addresses = wasmExports.free_object_addresses)(e), _performMultipleDeletions = Module._performMultipleDeletions = (e, t, r2) => (_performMultipleDeletions = Module._performMultipleDeletions = wasmExports.performMultipleDeletions)(e, t, r2), _recordDependencyOnExpr = Module._recordDependencyOnExpr = (e, t, r2, a2) => (_recordDependencyOnExpr = Module._recordDependencyOnExpr = wasmExports.recordDependencyOnExpr)(e, t, r2, a2), _query_tree_walker_impl = Module._query_tree_walker_impl = (e, t, r2, a2) => (_query_tree_walker_impl = Module._query_tree_walker_impl = wasmExports.query_tree_walker_impl)(e, t, r2, a2), _expression_tree_walker_impl = Module._expression_tree_walker_impl = (e, t, r2) => (_expression_tree_walker_impl = Module._expression_tree_walker_impl = wasmExports.expression_tree_walker_impl)(e, t, r2), _add_exact_object_address = Module._add_exact_object_address = (e, t) => (_add_exact_object_address = Module._add_exact_object_address = wasmExports.add_exact_object_address)(e, t), _get_rel_relkind = Module._get_rel_relkind = (e) => (_get_rel_relkind = Module._get_rel_relkind = wasmExports.get_rel_relkind)(e), _get_typtype = Module._get_typtype = (e) => (_get_typtype = Module._get_typtype = wasmExports.get_typtype)(e), _list_delete_last = Module._list_delete_last = (e) => (_list_delete_last = Module._list_delete_last = wasmExports.list_delete_last)(e), _type_is_collatable = Module._type_is_collatable = (e) => (_type_is_collatable = Module._type_is_collatable = wasmExports.type_is_collatable)(e), _GetSysCacheOid = Module._GetSysCacheOid = (e, t, r2, a2, o3, s4) => (_GetSysCacheOid = Module._GetSysCacheOid = wasmExports.GetSysCacheOid)(e, t, r2, a2, o3, s4), _CheckTableNotInUse = Module._CheckTableNotInUse = (e, t) => (_CheckTableNotInUse = Module._CheckTableNotInUse = wasmExports.CheckTableNotInUse)(e, t), _make_parsestate = Module._make_parsestate = (e) => (_make_parsestate = Module._make_parsestate = wasmExports.make_parsestate)(e), _transformExpr = Module._transformExpr = (e, t, r2) => (_transformExpr = Module._transformExpr = wasmExports.transformExpr)(e, t, r2), _equal = Module._equal = (e, t) => (_equal = Module._equal = wasmExports.equal)(e, t), _pull_var_clause = Module._pull_var_clause = (e, t) => (_pull_var_clause = Module._pull_var_clause = wasmExports.pull_var_clause)(e, t), _get_attname = Module._get_attname = (e, t, r2) => (_get_attname = Module._get_attname = wasmExports.get_attname)(e, t, r2), _coerce_to_target_type = Module._coerce_to_target_type = (e, t, r2, a2, o3, s4, l4, _3) => (_coerce_to_target_type = Module._coerce_to_target_type = wasmExports.coerce_to_target_type)(e, t, r2, a2, o3, s4, l4, _3), _nodeToString = Module._nodeToString = (e) => (_nodeToString = Module._nodeToString = wasmExports.nodeToString)(e), _parser_errposition = Module._parser_errposition = (e, t) => (_parser_errposition = Module._parser_errposition = wasmExports.parser_errposition)(e, t), _exprTypmod = Module._exprTypmod = (e) => (_exprTypmod = Module._exprTypmod = wasmExports.exprTypmod)(e), _get_base_element_type = Module._get_base_element_type = (e) => (_get_base_element_type = Module._get_base_element_type = wasmExports.get_base_element_type)(e), _SystemFuncName = Module._SystemFuncName = (e) => (_SystemFuncName = Module._SystemFuncName = wasmExports.SystemFuncName)(e), _CreateTrigger = Module._CreateTrigger = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3) => (_CreateTrigger = Module._CreateTrigger = wasmExports.CreateTrigger)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3), _plan_create_index_workers = Module._plan_create_index_workers = (e, t) => (_plan_create_index_workers = Module._plan_create_index_workers = wasmExports.plan_create_index_workers)(e, t), _get_rel_relispartition = Module._get_rel_relispartition = (e) => (_get_rel_relispartition = Module._get_rel_relispartition = wasmExports.get_rel_relispartition)(e), _get_partition_ancestors = Module._get_partition_ancestors = (e) => (_get_partition_ancestors = Module._get_partition_ancestors = wasmExports.get_partition_ancestors)(e), _get_rel_namespace = Module._get_rel_namespace = (e) => (_get_rel_namespace = Module._get_rel_namespace = wasmExports.get_rel_namespace)(e), _ConditionalLockRelationOid = Module._ConditionalLockRelationOid = (e, t) => (_ConditionalLockRelationOid = Module._ConditionalLockRelationOid = wasmExports.ConditionalLockRelationOid)(e, t), _RelnameGetRelid = Module._RelnameGetRelid = (e) => (_RelnameGetRelid = Module._RelnameGetRelid = wasmExports.RelnameGetRelid)(e), _get_relkind_objtype = Module._get_relkind_objtype = (e) => (_get_relkind_objtype = Module._get_relkind_objtype = wasmExports.get_relkind_objtype)(e), _RelationIsVisible = Module._RelationIsVisible = (e) => (_RelationIsVisible = Module._RelationIsVisible = wasmExports.RelationIsVisible)(e), _get_func_arg_info = Module._get_func_arg_info = (e, t, r2, a2) => (_get_func_arg_info = Module._get_func_arg_info = wasmExports.get_func_arg_info)(e, t, r2, a2), _NameListToString = Module._NameListToString = (e) => (_NameListToString = Module._NameListToString = wasmExports.NameListToString)(e), _OpernameGetOprid = Module._OpernameGetOprid = (e, t, r2) => (_OpernameGetOprid = Module._OpernameGetOprid = wasmExports.OpernameGetOprid)(e, t, r2), _makeRangeVarFromNameList = Module._makeRangeVarFromNameList = (e) => (_makeRangeVarFromNameList = Module._makeRangeVarFromNameList = wasmExports.makeRangeVarFromNameList)(e), _quote_identifier = Module._quote_identifier = (e) => (_quote_identifier = Module._quote_identifier = wasmExports.quote_identifier)(e), _GetSearchPathMatcher = Module._GetSearchPathMatcher = (e) => (_GetSearchPathMatcher = Module._GetSearchPathMatcher = wasmExports.GetSearchPathMatcher)(e), _SearchPathMatchesCurrentEnvironment = Module._SearchPathMatchesCurrentEnvironment = (e) => (_SearchPathMatchesCurrentEnvironment = Module._SearchPathMatchesCurrentEnvironment = wasmExports.SearchPathMatchesCurrentEnvironment)(e), _get_collation_oid = Module._get_collation_oid = (e, t) => (_get_collation_oid = Module._get_collation_oid = wasmExports.get_collation_oid)(e, t), _CacheRegisterSyscacheCallback = Module._CacheRegisterSyscacheCallback = (e, t, r2) => (_CacheRegisterSyscacheCallback = Module._CacheRegisterSyscacheCallback = wasmExports.CacheRegisterSyscacheCallback)(e, t, r2), _get_extension_oid = Module._get_extension_oid = (e, t) => (_get_extension_oid = Module._get_extension_oid = wasmExports.get_extension_oid)(e, t), _get_role_oid = Module._get_role_oid = (e, t) => (_get_role_oid = Module._get_role_oid = wasmExports.get_role_oid)(e, t), _GetForeignServerByName = Module._GetForeignServerByName = (e, t) => (_GetForeignServerByName = Module._GetForeignServerByName = wasmExports.GetForeignServerByName)(e, t), _GetPublicationByName = Module._GetPublicationByName = (e, t) => (_GetPublicationByName = Module._GetPublicationByName = wasmExports.GetPublicationByName)(e, t), _typeStringToTypeName = Module._typeStringToTypeName = (e, t) => (_typeStringToTypeName = Module._typeStringToTypeName = wasmExports.typeStringToTypeName)(e, t), _list_make2_impl = Module._list_make2_impl = (e, t, r2) => (_list_make2_impl = Module._list_make2_impl = wasmExports.list_make2_impl)(e, t, r2), _GetUserNameFromId = Module._GetUserNameFromId = (e, t) => (_GetUserNameFromId = Module._GetUserNameFromId = wasmExports.GetUserNameFromId)(e, t), _format_type_extended = Module._format_type_extended = (e, t, r2) => (_format_type_extended = Module._format_type_extended = wasmExports.format_type_extended)(e, t, r2), _quote_qualified_identifier = Module._quote_qualified_identifier = (e, t) => (_quote_qualified_identifier = Module._quote_qualified_identifier = wasmExports.quote_qualified_identifier)(e, t), _get_tablespace_name = Module._get_tablespace_name = (e) => (_get_tablespace_name = Module._get_tablespace_name = wasmExports.get_tablespace_name)(e), _GetForeignServerExtended = Module._GetForeignServerExtended = (e, t) => (_GetForeignServerExtended = Module._GetForeignServerExtended = wasmExports.GetForeignServerExtended)(e, t), _GetForeignServer = Module._GetForeignServer = (e) => (_GetForeignServer = Module._GetForeignServer = wasmExports.GetForeignServer)(e), _construct_empty_array = Module._construct_empty_array = (e) => (_construct_empty_array = Module._construct_empty_array = wasmExports.construct_empty_array)(e), _format_type_be_qualified = Module._format_type_be_qualified = (e) => (_format_type_be_qualified = Module._format_type_be_qualified = wasmExports.format_type_be_qualified)(e), _get_namespace_name_or_temp = Module._get_namespace_name_or_temp = (e) => (_get_namespace_name_or_temp = Module._get_namespace_name_or_temp = wasmExports.get_namespace_name_or_temp)(e), _list_make3_impl = Module._list_make3_impl = (e, t, r2, a2) => (_list_make3_impl = Module._list_make3_impl = wasmExports.list_make3_impl)(e, t, r2, a2), _construct_md_array = Module._construct_md_array = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_construct_md_array = Module._construct_md_array = wasmExports.construct_md_array)(e, t, r2, a2, o3, s4, l4, _3, n3), _pull_varattnos = Module._pull_varattnos = (e, t, r2) => (_pull_varattnos = Module._pull_varattnos = wasmExports.pull_varattnos)(e, t, r2), _get_func_name = Module._get_func_name = (e) => (_get_func_name = Module._get_func_name = wasmExports.get_func_name)(e), _ExecPrepareExpr = Module._ExecPrepareExpr = (e, t) => (_ExecPrepareExpr = Module._ExecPrepareExpr = wasmExports.ExecPrepareExpr)(e, t), _construct_array = Module._construct_array = (e, t, r2, a2, o3, s4) => (_construct_array = Module._construct_array = wasmExports.construct_array)(e, t, r2, a2, o3, s4), _construct_array_builtin = Module._construct_array_builtin = (e, t, r2) => (_construct_array_builtin = Module._construct_array_builtin = wasmExports.construct_array_builtin)(e, t, r2), _makeObjectName = Module._makeObjectName = (e, t, r2) => (_makeObjectName = Module._makeObjectName = wasmExports.makeObjectName)(e, t, r2), _get_primary_key_attnos = Module._get_primary_key_attnos = (e, t, r2) => (_get_primary_key_attnos = Module._get_primary_key_attnos = wasmExports.get_primary_key_attnos)(e, t, r2), _bms_is_subset = Module._bms_is_subset = (e, t) => (_bms_is_subset = Module._bms_is_subset = wasmExports.bms_is_subset)(e, t), _getExtensionOfObject = Module._getExtensionOfObject = (e, t) => (_getExtensionOfObject = Module._getExtensionOfObject = wasmExports.getExtensionOfObject)(e, t), _find_inheritance_children = Module._find_inheritance_children = (e, t) => (_find_inheritance_children = Module._find_inheritance_children = wasmExports.find_inheritance_children)(e, t), _lappend_int = Module._lappend_int = (e, t) => (_lappend_int = Module._lappend_int = wasmExports.lappend_int)(e, t), _has_superclass = Module._has_superclass = (e) => (_has_superclass = Module._has_superclass = wasmExports.has_superclass)(e), _CheckFunctionValidatorAccess = Module._CheckFunctionValidatorAccess = (e, t) => (_CheckFunctionValidatorAccess = Module._CheckFunctionValidatorAccess = wasmExports.CheckFunctionValidatorAccess)(e, t), _AcquireRewriteLocks = Module._AcquireRewriteLocks = (e, t, r2) => (_AcquireRewriteLocks = Module._AcquireRewriteLocks = wasmExports.AcquireRewriteLocks)(e, t, r2), _function_parse_error_transpose = Module._function_parse_error_transpose = (e) => (_function_parse_error_transpose = Module._function_parse_error_transpose = wasmExports.function_parse_error_transpose)(e), _geterrposition = Module._geterrposition = () => (_geterrposition = Module._geterrposition = wasmExports.geterrposition)(), _getinternalerrposition = Module._getinternalerrposition = () => (_getinternalerrposition = Module._getinternalerrposition = wasmExports.getinternalerrposition)(), _pg_mblen = Module._pg_mblen = (e) => (_pg_mblen = Module._pg_mblen = wasmExports.pg_mblen)(e), _pg_mbstrlen_with_len = Module._pg_mbstrlen_with_len = (e, t) => (_pg_mbstrlen_with_len = Module._pg_mbstrlen_with_len = wasmExports.pg_mbstrlen_with_len)(e, t), _errposition = Module._errposition = (e) => (_errposition = Module._errposition = wasmExports.errposition)(e), _internalerrposition = Module._internalerrposition = (e) => (_internalerrposition = Module._internalerrposition = wasmExports.internalerrposition)(e), _internalerrquery = Module._internalerrquery = (e) => (_internalerrquery = Module._internalerrquery = wasmExports.internalerrquery)(e), _is_publishable_relation = Module._is_publishable_relation = (e) => (_is_publishable_relation = Module._is_publishable_relation = wasmExports.is_publishable_relation)(e), _GetTopMostAncestorInPublication = Module._GetTopMostAncestorInPublication = (e, t, r2) => (_GetTopMostAncestorInPublication = Module._GetTopMostAncestorInPublication = wasmExports.GetTopMostAncestorInPublication)(e, t, r2), _GetRelationPublications = Module._GetRelationPublications = (e) => (_GetRelationPublications = Module._GetRelationPublications = wasmExports.GetRelationPublications)(e), _GetSchemaPublications = Module._GetSchemaPublications = (e) => (_GetSchemaPublications = Module._GetSchemaPublications = wasmExports.GetSchemaPublications)(e), _pub_collist_to_bitmapset = Module._pub_collist_to_bitmapset = (e, t, r2) => (_pub_collist_to_bitmapset = Module._pub_collist_to_bitmapset = wasmExports.pub_collist_to_bitmapset)(e, t, r2), _list_delete_nth_cell = Module._list_delete_nth_cell = (e, t) => (_list_delete_nth_cell = Module._list_delete_nth_cell = wasmExports.list_delete_nth_cell)(e, t), _get_array_type = Module._get_array_type = (e) => (_get_array_type = Module._get_array_type = wasmExports.get_array_type)(e), _smgrtruncate2 = Module._smgrtruncate2 = (e, t, r2, a2, o3) => (_smgrtruncate2 = Module._smgrtruncate2 = wasmExports.smgrtruncate2)(e, t, r2, a2, o3), _smgrreadv = Module._smgrreadv = (e, t, r2, a2, o3) => (_smgrreadv = Module._smgrreadv = wasmExports.smgrreadv)(e, t, r2, a2, o3), _NewRelationCreateToastTable = Module._NewRelationCreateToastTable = (e, t) => (_NewRelationCreateToastTable = Module._NewRelationCreateToastTable = wasmExports.NewRelationCreateToastTable)(e, t), _transformStmt = Module._transformStmt = (e, t) => (_transformStmt = Module._transformStmt = wasmExports.transformStmt)(e, t), _exprLocation = Module._exprLocation = (e) => (_exprLocation = Module._exprLocation = wasmExports.exprLocation)(e), _ParseFuncOrColumn = Module._ParseFuncOrColumn = (e, t, r2, a2, o3, s4, l4) => (_ParseFuncOrColumn = Module._ParseFuncOrColumn = wasmExports.ParseFuncOrColumn)(e, t, r2, a2, o3, s4, l4), _exprCollation = Module._exprCollation = (e) => (_exprCollation = Module._exprCollation = wasmExports.exprCollation)(e), _transformDistinctClause = Module._transformDistinctClause = (e, t, r2, a2) => (_transformDistinctClause = Module._transformDistinctClause = wasmExports.transformDistinctClause)(e, t, r2, a2), _makeTargetEntry = Module._makeTargetEntry = (e, t, r2, a2) => (_makeTargetEntry = Module._makeTargetEntry = wasmExports.makeTargetEntry)(e, t, r2, a2), _makeAlias = Module._makeAlias = (e, t) => (_makeAlias = Module._makeAlias = wasmExports.makeAlias)(e, t), _addRangeTableEntryForSubquery = Module._addRangeTableEntryForSubquery = (e, t, r2, a2, o3) => (_addRangeTableEntryForSubquery = Module._addRangeTableEntryForSubquery = wasmExports.addRangeTableEntryForSubquery)(e, t, r2, a2, o3), _makeVar = Module._makeVar = (e, t, r2, a2, o3, s4) => (_makeVar = Module._makeVar = wasmExports.makeVar)(e, t, r2, a2, o3, s4), _makeBoolean = Module._makeBoolean = (e) => (_makeBoolean = Module._makeBoolean = wasmExports.makeBoolean)(e), _makeInteger = Module._makeInteger = (e) => (_makeInteger = Module._makeInteger = wasmExports.makeInteger)(e), _makeTypeName = Module._makeTypeName = (e) => (_makeTypeName = Module._makeTypeName = wasmExports.makeTypeName)(e), _makeFuncCall = Module._makeFuncCall = (e, t, r2, a2) => (_makeFuncCall = Module._makeFuncCall = wasmExports.makeFuncCall)(e, t, r2, a2), _list_make4_impl = Module._list_make4_impl = (e, t, r2, a2, o3) => (_list_make4_impl = Module._list_make4_impl = wasmExports.list_make4_impl)(e, t, r2, a2, o3), _get_sortgroupclause_tle = Module._get_sortgroupclause_tle = (e, t) => (_get_sortgroupclause_tle = Module._get_sortgroupclause_tle = wasmExports.get_sortgroupclause_tle)(e, t), _flatten_join_alias_vars = Module._flatten_join_alias_vars = (e, t, r2) => (_flatten_join_alias_vars = Module._flatten_join_alias_vars = wasmExports.flatten_join_alias_vars)(e, t, r2), _list_member_int = Module._list_member_int = (e, t) => (_list_member_int = Module._list_member_int = wasmExports.list_member_int)(e, t), _addRangeTableEntryForENR = Module._addRangeTableEntryForENR = (e, t, r2) => (_addRangeTableEntryForENR = Module._addRangeTableEntryForENR = wasmExports.addRangeTableEntryForENR)(e, t, r2), _typenameTypeIdAndMod = Module._typenameTypeIdAndMod = (e, t, r2, a2) => (_typenameTypeIdAndMod = Module._typenameTypeIdAndMod = wasmExports.typenameTypeIdAndMod)(e, t, r2, a2), _get_typcollation = Module._get_typcollation = (e) => (_get_typcollation = Module._get_typcollation = wasmExports.get_typcollation)(e), _strip_implicit_coercions = Module._strip_implicit_coercions = (e) => (_strip_implicit_coercions = Module._strip_implicit_coercions = wasmExports.strip_implicit_coercions)(e), _get_sortgroupref_tle = Module._get_sortgroupref_tle = (e, t) => (_get_sortgroupref_tle = Module._get_sortgroupref_tle = wasmExports.get_sortgroupref_tle)(e, t), _contain_aggs_of_level = Module._contain_aggs_of_level = (e, t) => (_contain_aggs_of_level = Module._contain_aggs_of_level = wasmExports.contain_aggs_of_level)(e, t), _typeidType = Module._typeidType = (e) => (_typeidType = Module._typeidType = wasmExports.typeidType)(e), _typeTypeCollation = Module._typeTypeCollation = (e) => (_typeTypeCollation = Module._typeTypeCollation = wasmExports.typeTypeCollation)(e), _typeLen = Module._typeLen = (e) => (_typeLen = Module._typeLen = wasmExports.typeLen)(e), _typeByVal = Module._typeByVal = (e) => (_typeByVal = Module._typeByVal = wasmExports.typeByVal)(e), _makeConst = Module._makeConst = (e, t, r2, a2, o3, s4, l4) => (_makeConst = Module._makeConst = wasmExports.makeConst)(e, t, r2, a2, o3, s4, l4), _lookup_rowtype_tupdesc = Module._lookup_rowtype_tupdesc = (e, t) => (_lookup_rowtype_tupdesc = Module._lookup_rowtype_tupdesc = wasmExports.lookup_rowtype_tupdesc)(e, t), _bms_del_member = Module._bms_del_member = (e, t) => (_bms_del_member = Module._bms_del_member = wasmExports.bms_del_member)(e, t), _list_member = Module._list_member = (e, t) => (_list_member = Module._list_member = wasmExports.list_member)(e, t), _type_is_rowtype = Module._type_is_rowtype = (e) => (_type_is_rowtype = Module._type_is_rowtype = wasmExports.type_is_rowtype)(e), _bit_in = Module._bit_in = (e) => (_bit_in = Module._bit_in = wasmExports.bit_in)(e), _bms_union = Module._bms_union = (e, t) => (_bms_union = Module._bms_union = wasmExports.bms_union)(e, t), _varstr_levenshtein_less_equal = Module._varstr_levenshtein_less_equal = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_varstr_levenshtein_less_equal = Module._varstr_levenshtein_less_equal = wasmExports.varstr_levenshtein_less_equal)(e, t, r2, a2, o3, s4, l4, _3, n3), _addRTEPermissionInfo = Module._addRTEPermissionInfo = (e, t) => (_addRTEPermissionInfo = Module._addRTEPermissionInfo = wasmExports.addRTEPermissionInfo)(e, t), _errsave_start = Module._errsave_start = (e, t) => (_errsave_start = Module._errsave_start = wasmExports.errsave_start)(e, t), _errsave_finish = Module._errsave_finish = (e, t, r2, a2) => (_errsave_finish = Module._errsave_finish = wasmExports.errsave_finish)(e, t, r2, a2), _makeColumnDef = Module._makeColumnDef = (e, t, r2, a2) => (_makeColumnDef = Module._makeColumnDef = wasmExports.makeColumnDef)(e, t, r2, a2), _GetDefaultOpClass = Module._GetDefaultOpClass = (e, t) => (_GetDefaultOpClass = Module._GetDefaultOpClass = wasmExports.GetDefaultOpClass)(e, t), _scanner_init = Module._scanner_init = (e, t, r2, a2) => (_scanner_init = Module._scanner_init = wasmExports.scanner_init)(e, t, r2, a2), _scanner_finish = Module._scanner_finish = (e) => (_scanner_finish = Module._scanner_finish = wasmExports.scanner_finish)(e), _core_yylex = Module._core_yylex = (e, t, r2) => (_core_yylex = Module._core_yylex = wasmExports.core_yylex)(e, t, r2), _isxdigit = Module._isxdigit = (e) => (_isxdigit = Module._isxdigit = wasmExports.isxdigit)(e), _scanner_isspace = Module._scanner_isspace = (e) => (_scanner_isspace = Module._scanner_isspace = wasmExports.scanner_isspace)(e), _truncate_identifier = Module._truncate_identifier = (e, t, r2) => (_truncate_identifier = Module._truncate_identifier = wasmExports.truncate_identifier)(e, t, r2), _downcase_truncate_identifier = Module._downcase_truncate_identifier = (e, t, r2) => (_downcase_truncate_identifier = Module._downcase_truncate_identifier = wasmExports.downcase_truncate_identifier)(e, t, r2), _pg_database_encoding_max_length = Module._pg_database_encoding_max_length = () => (_pg_database_encoding_max_length = Module._pg_database_encoding_max_length = wasmExports.pg_database_encoding_max_length)(), _namein = Module._namein = (e) => (_namein = Module._namein = wasmExports.namein)(e), _BlockSampler_Init = Module._BlockSampler_Init = (e, t, r2, a2) => (_BlockSampler_Init = Module._BlockSampler_Init = wasmExports.BlockSampler_Init)(e, t, r2, a2), _reservoir_init_selection_state = Module._reservoir_init_selection_state = (e, t) => (_reservoir_init_selection_state = Module._reservoir_init_selection_state = wasmExports.reservoir_init_selection_state)(e, t), _reservoir_get_next_S = Module._reservoir_get_next_S = (e, t, r2) => (_reservoir_get_next_S = Module._reservoir_get_next_S = wasmExports.reservoir_get_next_S)(e, t, r2), _sampler_random_fract = Module._sampler_random_fract = (e) => (_sampler_random_fract = Module._sampler_random_fract = wasmExports.sampler_random_fract)(e), _BlockSampler_HasMore = Module._BlockSampler_HasMore = (e) => (_BlockSampler_HasMore = Module._BlockSampler_HasMore = wasmExports.BlockSampler_HasMore)(e), _BlockSampler_Next = Module._BlockSampler_Next = (e) => (_BlockSampler_Next = Module._BlockSampler_Next = wasmExports.BlockSampler_Next)(e), _Async_Notify = Module._Async_Notify = (e, t) => (_Async_Notify = Module._Async_Notify = wasmExports.Async_Notify)(e, t), _RangeVarCallbackMaintainsTable = Module._RangeVarCallbackMaintainsTable = (e, t, r2, a2) => (_RangeVarCallbackMaintainsTable = Module._RangeVarCallbackMaintainsTable = wasmExports.RangeVarCallbackMaintainsTable)(e, t, r2, a2), _make_new_heap = Module._make_new_heap = (e, t, r2, a2, o3) => (_make_new_heap = Module._make_new_heap = wasmExports.make_new_heap)(e, t, r2, a2, o3), _finish_heap_swap = Module._finish_heap_swap = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_finish_heap_swap = Module._finish_heap_swap = wasmExports.finish_heap_swap)(e, t, r2, a2, o3, s4, l4, _3, n3), _wasm_OpenPipeStream = Module._wasm_OpenPipeStream = (e, t) => (_wasm_OpenPipeStream = Module._wasm_OpenPipeStream = wasmExports.wasm_OpenPipeStream)(e, t), _ClosePipeStream = Module._ClosePipeStream = (e) => (_ClosePipeStream = Module._ClosePipeStream = wasmExports.ClosePipeStream)(e), _BeginCopyFrom = Module._BeginCopyFrom = (e, t, r2, a2, o3, s4, l4, _3) => (_BeginCopyFrom = Module._BeginCopyFrom = wasmExports.BeginCopyFrom)(e, t, r2, a2, o3, s4, l4, _3), _EndCopyFrom = Module._EndCopyFrom = (e) => (_EndCopyFrom = Module._EndCopyFrom = wasmExports.EndCopyFrom)(e), _ProcessCopyOptions = Module._ProcessCopyOptions = (e, t, r2, a2) => (_ProcessCopyOptions = Module._ProcessCopyOptions = wasmExports.ProcessCopyOptions)(e, t, r2, a2), _CopyFromErrorCallback = Module._CopyFromErrorCallback = (e) => (_CopyFromErrorCallback = Module._CopyFromErrorCallback = wasmExports.CopyFromErrorCallback)(e), _ExecInitRangeTable = Module._ExecInitRangeTable = (e, t, r2) => (_ExecInitRangeTable = Module._ExecInitRangeTable = wasmExports.ExecInitRangeTable)(e, t, r2), _NextCopyFrom = Module._NextCopyFrom = (e, t, r2, a2) => (_NextCopyFrom = Module._NextCopyFrom = wasmExports.NextCopyFrom)(e, t, r2, a2), _ExecInitExpr = Module._ExecInitExpr = (e, t) => (_ExecInitExpr = Module._ExecInitExpr = wasmExports.ExecInitExpr)(e, t), _report_invalid_encoding = Module._report_invalid_encoding = (e, t, r2) => (_report_invalid_encoding = Module._report_invalid_encoding = wasmExports.report_invalid_encoding)(e, t, r2), _tolower = Module._tolower = (e) => (_tolower = Module._tolower = wasmExports.tolower)(e), _PushCopiedSnapshot = Module._PushCopiedSnapshot = (e) => (_PushCopiedSnapshot = Module._PushCopiedSnapshot = wasmExports.PushCopiedSnapshot)(e), _UpdateActiveSnapshotCommandId = Module._UpdateActiveSnapshotCommandId = () => (_UpdateActiveSnapshotCommandId = Module._UpdateActiveSnapshotCommandId = wasmExports.UpdateActiveSnapshotCommandId)(), _CreateQueryDesc = Module._CreateQueryDesc = (e, t, r2, a2, o3, s4, l4, _3) => (_CreateQueryDesc = Module._CreateQueryDesc = wasmExports.CreateQueryDesc)(e, t, r2, a2, o3, s4, l4, _3), _ExecutorStart = Module._ExecutorStart = (e, t) => (_ExecutorStart = Module._ExecutorStart = wasmExports.ExecutorStart)(e, t), _ExecutorFinish = Module._ExecutorFinish = (e) => (_ExecutorFinish = Module._ExecutorFinish = wasmExports.ExecutorFinish)(e), _ExecutorEnd = Module._ExecutorEnd = (e) => (_ExecutorEnd = Module._ExecutorEnd = wasmExports.ExecutorEnd)(e), _FreeQueryDesc = Module._FreeQueryDesc = (e) => (_FreeQueryDesc = Module._FreeQueryDesc = wasmExports.FreeQueryDesc)(e), _pg_server_to_any = Module._pg_server_to_any = (e, t, r2) => (_pg_server_to_any = Module._pg_server_to_any = wasmExports.pg_server_to_any)(e, t, r2), _ExecutorRun = Module._ExecutorRun = (e, t, r2, a2) => (_ExecutorRun = Module._ExecutorRun = wasmExports.ExecutorRun)(e, t, r2, a2), _CreateTableAsRelExists = Module._CreateTableAsRelExists = (e) => (_CreateTableAsRelExists = Module._CreateTableAsRelExists = wasmExports.CreateTableAsRelExists)(e), _DefineRelation = Module._DefineRelation = (e, t, r2, a2, o3, s4) => (_DefineRelation = Module._DefineRelation = wasmExports.DefineRelation)(e, t, r2, a2, o3, s4), _oidin = Module._oidin = (e) => (_oidin = Module._oidin = wasmExports.oidin)(e), _GetCommandTagName = Module._GetCommandTagName = (e) => (_GetCommandTagName = Module._GetCommandTagName = wasmExports.GetCommandTagName)(e), _ExplainBeginOutput = Module._ExplainBeginOutput = (e) => (_ExplainBeginOutput = Module._ExplainBeginOutput = wasmExports.ExplainBeginOutput)(e), _NewExplainState = Module._NewExplainState = () => (_NewExplainState = Module._NewExplainState = wasmExports.NewExplainState)(), _ExplainEndOutput = Module._ExplainEndOutput = (e) => (_ExplainEndOutput = Module._ExplainEndOutput = wasmExports.ExplainEndOutput)(e), _ExplainPrintPlan = Module._ExplainPrintPlan = (e, t) => (_ExplainPrintPlan = Module._ExplainPrintPlan = wasmExports.ExplainPrintPlan)(e, t), _ExplainPrintTriggers = Module._ExplainPrintTriggers = (e, t) => (_ExplainPrintTriggers = Module._ExplainPrintTriggers = wasmExports.ExplainPrintTriggers)(e, t), _ExplainPrintJITSummary = Module._ExplainPrintJITSummary = (e, t) => (_ExplainPrintJITSummary = Module._ExplainPrintJITSummary = wasmExports.ExplainPrintJITSummary)(e, t), _InstrEndLoop = Module._InstrEndLoop = (e) => (_InstrEndLoop = Module._InstrEndLoop = wasmExports.InstrEndLoop)(e), _ExplainPropertyInteger = Module._ExplainPropertyInteger = (e, t, r2, a2) => (_ExplainPropertyInteger = Module._ExplainPropertyInteger = wasmExports.ExplainPropertyInteger)(e, t, r2, a2), _make_orclause = Module._make_orclause = (e) => (_make_orclause = Module._make_orclause = wasmExports.make_orclause)(e), _ExplainQueryText = Module._ExplainQueryText = (e, t) => (_ExplainQueryText = Module._ExplainQueryText = wasmExports.ExplainQueryText)(e, t), _ExplainPropertyText = Module._ExplainPropertyText = (e, t, r2) => (_ExplainPropertyText = Module._ExplainPropertyText = wasmExports.ExplainPropertyText)(e, t, r2), _ExplainQueryParameters = Module._ExplainQueryParameters = (e, t, r2) => (_ExplainQueryParameters = Module._ExplainQueryParameters = wasmExports.ExplainQueryParameters)(e, t, r2), _get_func_namespace = Module._get_func_namespace = (e) => (_get_func_namespace = Module._get_func_namespace = wasmExports.get_func_namespace)(e), _get_rel_type_id = Module._get_rel_type_id = (e) => (_get_rel_type_id = Module._get_rel_type_id = wasmExports.get_rel_type_id)(e), _set_config_option = Module._set_config_option = (e, t, r2, a2, o3, s4, l4, _3) => (_set_config_option = Module._set_config_option = wasmExports.set_config_option)(e, t, r2, a2, o3, s4, l4, _3), _pg_any_to_server = Module._pg_any_to_server = (e, t, r2) => (_pg_any_to_server = Module._pg_any_to_server = wasmExports.pg_any_to_server)(e, t, r2), _DirectFunctionCall4Coll = Module._DirectFunctionCall4Coll = (e, t, r2, a2, o3, s4) => (_DirectFunctionCall4Coll = Module._DirectFunctionCall4Coll = wasmExports.DirectFunctionCall4Coll)(e, t, r2, a2, o3, s4), _list_delete_cell = Module._list_delete_cell = (e, t) => (_list_delete_cell = Module._list_delete_cell = wasmExports.list_delete_cell)(e, t), _GetForeignDataWrapper = Module._GetForeignDataWrapper = (e) => (_GetForeignDataWrapper = Module._GetForeignDataWrapper = wasmExports.GetForeignDataWrapper)(e), _CreateExprContext = Module._CreateExprContext = (e) => (_CreateExprContext = Module._CreateExprContext = wasmExports.CreateExprContext)(e), _EnsurePortalSnapshotExists = Module._EnsurePortalSnapshotExists = () => (_EnsurePortalSnapshotExists = Module._EnsurePortalSnapshotExists = wasmExports.EnsurePortalSnapshotExists)(), _CheckIndexCompatible = Module._CheckIndexCompatible = (e, t, r2, a2) => (_CheckIndexCompatible = Module._CheckIndexCompatible = wasmExports.CheckIndexCompatible)(e, t, r2, a2), _pgstat_count_truncate = Module._pgstat_count_truncate = (e) => (_pgstat_count_truncate = Module._pgstat_count_truncate = wasmExports.pgstat_count_truncate)(e), _SPI_connect = Module._SPI_connect = () => (_SPI_connect = Module._SPI_connect = wasmExports.SPI_connect)(), _SPI_exec = Module._SPI_exec = (e, t) => (_SPI_exec = Module._SPI_exec = wasmExports.SPI_exec)(e, t), _SPI_execute = Module._SPI_execute = (e, t, r2) => (_SPI_execute = Module._SPI_execute = wasmExports.SPI_execute)(e, t, r2), _SPI_getvalue = Module._SPI_getvalue = (e, t, r2) => (_SPI_getvalue = Module._SPI_getvalue = wasmExports.SPI_getvalue)(e, t, r2), _generate_operator_clause = Module._generate_operator_clause = (e, t, r2, a2, o3, s4) => (_generate_operator_clause = Module._generate_operator_clause = wasmExports.generate_operator_clause)(e, t, r2, a2, o3, s4), _SPI_finish = Module._SPI_finish = () => (_SPI_finish = Module._SPI_finish = wasmExports.SPI_finish)(), _CreateTransientRelDestReceiver = Module._CreateTransientRelDestReceiver = (e) => (_CreateTransientRelDestReceiver = Module._CreateTransientRelDestReceiver = wasmExports.CreateTransientRelDestReceiver)(e), _MemoryContextSetIdentifier = Module._MemoryContextSetIdentifier = (e, t) => (_MemoryContextSetIdentifier = Module._MemoryContextSetIdentifier = wasmExports.MemoryContextSetIdentifier)(e, t), _checkExprHasSubLink = Module._checkExprHasSubLink = (e) => (_checkExprHasSubLink = Module._checkExprHasSubLink = wasmExports.checkExprHasSubLink)(e), _SetTuplestoreDestReceiverParams = Module._SetTuplestoreDestReceiverParams = (e, t, r2, a2, o3, s4) => (_SetTuplestoreDestReceiverParams = Module._SetTuplestoreDestReceiverParams = wasmExports.SetTuplestoreDestReceiverParams)(e, t, r2, a2, o3, s4), _tuplestore_rescan = Module._tuplestore_rescan = (e) => (_tuplestore_rescan = Module._tuplestore_rescan = wasmExports.tuplestore_rescan)(e), _MemoryContextDeleteChildren = Module._MemoryContextDeleteChildren = (e) => (_MemoryContextDeleteChildren = Module._MemoryContextDeleteChildren = wasmExports.MemoryContextDeleteChildren)(e), _ReleaseCachedPlan = Module._ReleaseCachedPlan = (e, t) => (_ReleaseCachedPlan = Module._ReleaseCachedPlan = wasmExports.ReleaseCachedPlan)(e, t), _bms_equal = Module._bms_equal = (e, t) => (_bms_equal = Module._bms_equal = wasmExports.bms_equal)(e, t), _nextval = Module._nextval = (e) => (_nextval = Module._nextval = wasmExports.nextval)(e), _textToQualifiedNameList = Module._textToQualifiedNameList = (e) => (_textToQualifiedNameList = Module._textToQualifiedNameList = wasmExports.textToQualifiedNameList)(e), _defGetStreamingMode = Module._defGetStreamingMode = (e) => (_defGetStreamingMode = Module._defGetStreamingMode = wasmExports.defGetStreamingMode)(e), _pg_lsn_in = Module._pg_lsn_in = (e) => (_pg_lsn_in = Module._pg_lsn_in = wasmExports.pg_lsn_in)(e), _tuplestore_gettupleslot = Module._tuplestore_gettupleslot = (e, t, r2, a2) => (_tuplestore_gettupleslot = Module._tuplestore_gettupleslot = wasmExports.tuplestore_gettupleslot)(e, t, r2, a2), _list_delete = Module._list_delete = (e, t) => (_list_delete = Module._list_delete = wasmExports.list_delete)(e, t), _tuplestore_end = Module._tuplestore_end = (e) => (_tuplestore_end = Module._tuplestore_end = wasmExports.tuplestore_end)(e), _quote_literal_cstr = Module._quote_literal_cstr = (e) => (_quote_literal_cstr = Module._quote_literal_cstr = wasmExports.quote_literal_cstr)(e), _contain_mutable_functions = Module._contain_mutable_functions = (e) => (_contain_mutable_functions = Module._contain_mutable_functions = wasmExports.contain_mutable_functions)(e), _ExecuteTruncateGuts = Module._ExecuteTruncateGuts = (e, t, r2, a2, o3, s4) => (_ExecuteTruncateGuts = Module._ExecuteTruncateGuts = wasmExports.ExecuteTruncateGuts)(e, t, r2, a2, o3, s4), _bms_make_singleton = Module._bms_make_singleton = (e) => (_bms_make_singleton = Module._bms_make_singleton = wasmExports.bms_make_singleton)(e), _tuplestore_puttupleslot = Module._tuplestore_puttupleslot = (e, t) => (_tuplestore_puttupleslot = Module._tuplestore_puttupleslot = wasmExports.tuplestore_puttupleslot)(e, t), _tuplestore_begin_heap = Module._tuplestore_begin_heap = (e, t, r2) => (_tuplestore_begin_heap = Module._tuplestore_begin_heap = wasmExports.tuplestore_begin_heap)(e, t, r2), _ExecForceStoreHeapTuple = Module._ExecForceStoreHeapTuple = (e, t, r2) => (_ExecForceStoreHeapTuple = Module._ExecForceStoreHeapTuple = wasmExports.ExecForceStoreHeapTuple)(e, t, r2), _strtod = Module._strtod = (e, t) => (_strtod = Module._strtod = wasmExports.strtod)(e, t), _plain_crypt_verify = Module._plain_crypt_verify = (e, t, r2, a2) => (_plain_crypt_verify = Module._plain_crypt_verify = wasmExports.plain_crypt_verify)(e, t, r2, a2), _ProcessConfigFile = Module._ProcessConfigFile = (e) => (_ProcessConfigFile = Module._ProcessConfigFile = wasmExports.ProcessConfigFile)(e), _ExecReScan = Module._ExecReScan = (e) => (_ExecReScan = Module._ExecReScan = wasmExports.ExecReScan)(e), _ExecAsyncResponse = Module._ExecAsyncResponse = (e) => (_ExecAsyncResponse = Module._ExecAsyncResponse = wasmExports.ExecAsyncResponse)(e), _ExecAsyncRequestDone = Module._ExecAsyncRequestDone = (e, t) => (_ExecAsyncRequestDone = Module._ExecAsyncRequestDone = wasmExports.ExecAsyncRequestDone)(e, t), _ExecAsyncRequestPending = Module._ExecAsyncRequestPending = (e) => (_ExecAsyncRequestPending = Module._ExecAsyncRequestPending = wasmExports.ExecAsyncRequestPending)(e), _ExprEvalPushStep = Module._ExprEvalPushStep = (e, t) => (_ExprEvalPushStep = Module._ExprEvalPushStep = wasmExports.ExprEvalPushStep)(e, t), _ExecInitExprWithParams = Module._ExecInitExprWithParams = (e, t) => (_ExecInitExprWithParams = Module._ExecInitExprWithParams = wasmExports.ExecInitExprWithParams)(e, t), _ExecInitExprList = Module._ExecInitExprList = (e, t) => (_ExecInitExprList = Module._ExecInitExprList = wasmExports.ExecInitExprList)(e, t), _MakeExpandedObjectReadOnlyInternal = Module._MakeExpandedObjectReadOnlyInternal = (e) => (_MakeExpandedObjectReadOnlyInternal = Module._MakeExpandedObjectReadOnlyInternal = wasmExports.MakeExpandedObjectReadOnlyInternal)(e), _tuplesort_puttupleslot = Module._tuplesort_puttupleslot = (e, t) => (_tuplesort_puttupleslot = Module._tuplesort_puttupleslot = wasmExports.tuplesort_puttupleslot)(e, t), _ArrayGetNItems = Module._ArrayGetNItems = (e, t) => (_ArrayGetNItems = Module._ArrayGetNItems = wasmExports.ArrayGetNItems)(e, t), _expanded_record_fetch_tupdesc = Module._expanded_record_fetch_tupdesc = (e) => (_expanded_record_fetch_tupdesc = Module._expanded_record_fetch_tupdesc = wasmExports.expanded_record_fetch_tupdesc)(e), _expanded_record_fetch_field = Module._expanded_record_fetch_field = (e, t, r2) => (_expanded_record_fetch_field = Module._expanded_record_fetch_field = wasmExports.expanded_record_fetch_field)(e, t, r2), _JsonbValueToJsonb = Module._JsonbValueToJsonb = (e) => (_JsonbValueToJsonb = Module._JsonbValueToJsonb = wasmExports.JsonbValueToJsonb)(e), _boolout = Module._boolout = (e) => (_boolout = Module._boolout = wasmExports.boolout)(e), _lookup_rowtype_tupdesc_domain = Module._lookup_rowtype_tupdesc_domain = (e, t, r2) => (_lookup_rowtype_tupdesc_domain = Module._lookup_rowtype_tupdesc_domain = wasmExports.lookup_rowtype_tupdesc_domain)(e, t, r2), _MemoryContextGetParent = Module._MemoryContextGetParent = (e) => (_MemoryContextGetParent = Module._MemoryContextGetParent = wasmExports.MemoryContextGetParent)(e), _DeleteExpandedObject = Module._DeleteExpandedObject = (e) => (_DeleteExpandedObject = Module._DeleteExpandedObject = wasmExports.DeleteExpandedObject)(e), _ExecFindJunkAttributeInTlist = Module._ExecFindJunkAttributeInTlist = (e, t) => (_ExecFindJunkAttributeInTlist = Module._ExecFindJunkAttributeInTlist = wasmExports.ExecFindJunkAttributeInTlist)(e, t), _standard_ExecutorStart = Module._standard_ExecutorStart = (e, t) => (_standard_ExecutorStart = Module._standard_ExecutorStart = wasmExports.standard_ExecutorStart)(e, t), _standard_ExecutorRun = Module._standard_ExecutorRun = (e, t, r2, a2) => (_standard_ExecutorRun = Module._standard_ExecutorRun = wasmExports.standard_ExecutorRun)(e, t, r2, a2), _standard_ExecutorFinish = Module._standard_ExecutorFinish = (e) => (_standard_ExecutorFinish = Module._standard_ExecutorFinish = wasmExports.standard_ExecutorFinish)(e), _standard_ExecutorEnd = Module._standard_ExecutorEnd = (e) => (_standard_ExecutorEnd = Module._standard_ExecutorEnd = wasmExports.standard_ExecutorEnd)(e), _InstrAlloc = Module._InstrAlloc = (e, t, r2) => (_InstrAlloc = Module._InstrAlloc = wasmExports.InstrAlloc)(e, t, r2), _MakeTupleTableSlot = Module._MakeTupleTableSlot = (e, t) => (_MakeTupleTableSlot = Module._MakeTupleTableSlot = wasmExports.MakeTupleTableSlot)(e, t), _get_typlenbyval = Module._get_typlenbyval = (e, t, r2) => (_get_typlenbyval = Module._get_typlenbyval = wasmExports.get_typlenbyval)(e, t, r2), _bms_num_members = Module._bms_num_members = (e) => (_bms_num_members = Module._bms_num_members = wasmExports.bms_num_members)(e), _InputFunctionCall = Module._InputFunctionCall = (e, t, r2, a2) => (_InputFunctionCall = Module._InputFunctionCall = wasmExports.InputFunctionCall)(e, t, r2, a2), _FreeExprContext = Module._FreeExprContext = (e, t) => (_FreeExprContext = Module._FreeExprContext = wasmExports.FreeExprContext)(e, t), _ExecOpenScanRelation = Module._ExecOpenScanRelation = (e, t, r2) => (_ExecOpenScanRelation = Module._ExecOpenScanRelation = wasmExports.ExecOpenScanRelation)(e, t, r2), _bms_intersect = Module._bms_intersect = (e, t) => (_bms_intersect = Module._bms_intersect = wasmExports.bms_intersect)(e, t), _ExecGetReturningSlot = Module._ExecGetReturningSlot = (e, t) => (_ExecGetReturningSlot = Module._ExecGetReturningSlot = wasmExports.ExecGetReturningSlot)(e, t), _ExecGetResultRelCheckAsUser = Module._ExecGetResultRelCheckAsUser = (e, t) => (_ExecGetResultRelCheckAsUser = Module._ExecGetResultRelCheckAsUser = wasmExports.ExecGetResultRelCheckAsUser)(e, t), _get_call_expr_argtype = Module._get_call_expr_argtype = (e, t) => (_get_call_expr_argtype = Module._get_call_expr_argtype = wasmExports.get_call_expr_argtype)(e, t), _tuplestore_clear = Module._tuplestore_clear = (e) => (_tuplestore_clear = Module._tuplestore_clear = wasmExports.tuplestore_clear)(e), _InstrUpdateTupleCount = Module._InstrUpdateTupleCount = (e, t) => (_InstrUpdateTupleCount = Module._InstrUpdateTupleCount = wasmExports.InstrUpdateTupleCount)(e, t), _tuplesort_begin_heap = Module._tuplesort_begin_heap = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_tuplesort_begin_heap = Module._tuplesort_begin_heap = wasmExports.tuplesort_begin_heap)(e, t, r2, a2, o3, s4, l4, _3, n3), _tuplesort_gettupleslot = Module._tuplesort_gettupleslot = (e, t, r2, a2, o3) => (_tuplesort_gettupleslot = Module._tuplesort_gettupleslot = wasmExports.tuplesort_gettupleslot)(e, t, r2, a2, o3), _AddWaitEventToSet = Module._AddWaitEventToSet = (e, t, r2, a2, o3) => (_AddWaitEventToSet = Module._AddWaitEventToSet = wasmExports.AddWaitEventToSet)(e, t, r2, a2, o3), _GetNumRegisteredWaitEvents = Module._GetNumRegisteredWaitEvents = (e) => (_GetNumRegisteredWaitEvents = Module._GetNumRegisteredWaitEvents = wasmExports.GetNumRegisteredWaitEvents)(e), _get_attstatsslot = Module._get_attstatsslot = (e, t, r2, a2, o3) => (_get_attstatsslot = Module._get_attstatsslot = wasmExports.get_attstatsslot)(e, t, r2, a2, o3), _free_attstatsslot = Module._free_attstatsslot = (e) => (_free_attstatsslot = Module._free_attstatsslot = wasmExports.free_attstatsslot)(e), _tuplesort_reset = Module._tuplesort_reset = (e) => (_tuplesort_reset = Module._tuplesort_reset = wasmExports.tuplesort_reset)(e), _pairingheap_first = Module._pairingheap_first = (e) => (_pairingheap_first = Module._pairingheap_first = wasmExports.pairingheap_first)(e), _bms_nonempty_difference = Module._bms_nonempty_difference = (e, t) => (_bms_nonempty_difference = Module._bms_nonempty_difference = wasmExports.bms_nonempty_difference)(e, t), _SPI_connect_ext = Module._SPI_connect_ext = (e) => (_SPI_connect_ext = Module._SPI_connect_ext = wasmExports.SPI_connect_ext)(e), _SPI_commit = Module._SPI_commit = () => (_SPI_commit = Module._SPI_commit = wasmExports.SPI_commit)(), _CopyErrorData = Module._CopyErrorData = () => (_CopyErrorData = Module._CopyErrorData = wasmExports.CopyErrorData)(), _ReThrowError = Module._ReThrowError = (e) => (_ReThrowError = Module._ReThrowError = wasmExports.ReThrowError)(e), _SPI_commit_and_chain = Module._SPI_commit_and_chain = () => (_SPI_commit_and_chain = Module._SPI_commit_and_chain = wasmExports.SPI_commit_and_chain)(), _SPI_rollback = Module._SPI_rollback = () => (_SPI_rollback = Module._SPI_rollback = wasmExports.SPI_rollback)(), _SPI_rollback_and_chain = Module._SPI_rollback_and_chain = () => (_SPI_rollback_and_chain = Module._SPI_rollback_and_chain = wasmExports.SPI_rollback_and_chain)(), _SPI_freetuptable = Module._SPI_freetuptable = (e) => (_SPI_freetuptable = Module._SPI_freetuptable = wasmExports.SPI_freetuptable)(e), _SPI_execute_extended = Module._SPI_execute_extended = (e, t) => (_SPI_execute_extended = Module._SPI_execute_extended = wasmExports.SPI_execute_extended)(e, t), _SPI_execute_plan = Module._SPI_execute_plan = (e, t, r2, a2, o3) => (_SPI_execute_plan = Module._SPI_execute_plan = wasmExports.SPI_execute_plan)(e, t, r2, a2, o3), _SPI_execp = Module._SPI_execp = (e, t, r2, a2) => (_SPI_execp = Module._SPI_execp = wasmExports.SPI_execp)(e, t, r2, a2), _SPI_execute_plan_extended = Module._SPI_execute_plan_extended = (e, t) => (_SPI_execute_plan_extended = Module._SPI_execute_plan_extended = wasmExports.SPI_execute_plan_extended)(e, t), _SPI_execute_plan_with_paramlist = Module._SPI_execute_plan_with_paramlist = (e, t, r2, a2) => (_SPI_execute_plan_with_paramlist = Module._SPI_execute_plan_with_paramlist = wasmExports.SPI_execute_plan_with_paramlist)(e, t, r2, a2), _SPI_prepare = Module._SPI_prepare = (e, t, r2) => (_SPI_prepare = Module._SPI_prepare = wasmExports.SPI_prepare)(e, t, r2), _SPI_prepare_extended = Module._SPI_prepare_extended = (e, t) => (_SPI_prepare_extended = Module._SPI_prepare_extended = wasmExports.SPI_prepare_extended)(e, t), _SPI_keepplan = Module._SPI_keepplan = (e) => (_SPI_keepplan = Module._SPI_keepplan = wasmExports.SPI_keepplan)(e), _SPI_freeplan = Module._SPI_freeplan = (e) => (_SPI_freeplan = Module._SPI_freeplan = wasmExports.SPI_freeplan)(e), _SPI_copytuple = Module._SPI_copytuple = (e) => (_SPI_copytuple = Module._SPI_copytuple = wasmExports.SPI_copytuple)(e), _SPI_returntuple = Module._SPI_returntuple = (e, t) => (_SPI_returntuple = Module._SPI_returntuple = wasmExports.SPI_returntuple)(e, t), _SPI_fnumber = Module._SPI_fnumber = (e, t) => (_SPI_fnumber = Module._SPI_fnumber = wasmExports.SPI_fnumber)(e, t), _SPI_fname = Module._SPI_fname = (e, t) => (_SPI_fname = Module._SPI_fname = wasmExports.SPI_fname)(e, t), _SPI_getbinval = Module._SPI_getbinval = (e, t, r2, a2) => (_SPI_getbinval = Module._SPI_getbinval = wasmExports.SPI_getbinval)(e, t, r2, a2), _SPI_gettype = Module._SPI_gettype = (e, t) => (_SPI_gettype = Module._SPI_gettype = wasmExports.SPI_gettype)(e, t), _SPI_gettypeid = Module._SPI_gettypeid = (e, t) => (_SPI_gettypeid = Module._SPI_gettypeid = wasmExports.SPI_gettypeid)(e, t), _SPI_getrelname = Module._SPI_getrelname = (e) => (_SPI_getrelname = Module._SPI_getrelname = wasmExports.SPI_getrelname)(e), _SPI_palloc = Module._SPI_palloc = (e) => (_SPI_palloc = Module._SPI_palloc = wasmExports.SPI_palloc)(e), _SPI_datumTransfer = Module._SPI_datumTransfer = (e, t, r2) => (_SPI_datumTransfer = Module._SPI_datumTransfer = wasmExports.SPI_datumTransfer)(e, t, r2), _datumTransfer = Module._datumTransfer = (e, t, r2) => (_datumTransfer = Module._datumTransfer = wasmExports.datumTransfer)(e, t, r2), _SPI_cursor_open_with_paramlist = Module._SPI_cursor_open_with_paramlist = (e, t, r2, a2) => (_SPI_cursor_open_with_paramlist = Module._SPI_cursor_open_with_paramlist = wasmExports.SPI_cursor_open_with_paramlist)(e, t, r2, a2), _SPI_cursor_parse_open = Module._SPI_cursor_parse_open = (e, t, r2) => (_SPI_cursor_parse_open = Module._SPI_cursor_parse_open = wasmExports.SPI_cursor_parse_open)(e, t, r2), _SPI_cursor_find = Module._SPI_cursor_find = (e) => (_SPI_cursor_find = Module._SPI_cursor_find = wasmExports.SPI_cursor_find)(e), _SPI_cursor_fetch = Module._SPI_cursor_fetch = (e, t, r2) => (_SPI_cursor_fetch = Module._SPI_cursor_fetch = wasmExports.SPI_cursor_fetch)(e, t, r2), _SPI_scroll_cursor_fetch = Module._SPI_scroll_cursor_fetch = (e, t, r2) => (_SPI_scroll_cursor_fetch = Module._SPI_scroll_cursor_fetch = wasmExports.SPI_scroll_cursor_fetch)(e, t, r2), _SPI_scroll_cursor_move = Module._SPI_scroll_cursor_move = (e, t, r2) => (_SPI_scroll_cursor_move = Module._SPI_scroll_cursor_move = wasmExports.SPI_scroll_cursor_move)(e, t, r2), _SPI_cursor_close = Module._SPI_cursor_close = (e) => (_SPI_cursor_close = Module._SPI_cursor_close = wasmExports.SPI_cursor_close)(e), _SPI_plan_is_valid = Module._SPI_plan_is_valid = (e) => (_SPI_plan_is_valid = Module._SPI_plan_is_valid = wasmExports.SPI_plan_is_valid)(e), _SPI_result_code_string = Module._SPI_result_code_string = (e) => (_SPI_result_code_string = Module._SPI_result_code_string = wasmExports.SPI_result_code_string)(e), _SPI_plan_get_plan_sources = Module._SPI_plan_get_plan_sources = (e) => (_SPI_plan_get_plan_sources = Module._SPI_plan_get_plan_sources = wasmExports.SPI_plan_get_plan_sources)(e), _SPI_plan_get_cached_plan = Module._SPI_plan_get_cached_plan = (e) => (_SPI_plan_get_cached_plan = Module._SPI_plan_get_cached_plan = wasmExports.SPI_plan_get_cached_plan)(e), _SPI_register_relation = Module._SPI_register_relation = (e) => (_SPI_register_relation = Module._SPI_register_relation = wasmExports.SPI_register_relation)(e), _create_queryEnv = Module._create_queryEnv = () => (_create_queryEnv = Module._create_queryEnv = wasmExports.create_queryEnv)(), _register_ENR = Module._register_ENR = (e, t) => (_register_ENR = Module._register_ENR = wasmExports.register_ENR)(e, t), _SPI_register_trigger_data = Module._SPI_register_trigger_data = (e) => (_SPI_register_trigger_data = Module._SPI_register_trigger_data = wasmExports.SPI_register_trigger_data)(e), _tuplestore_tuple_count = Module._tuplestore_tuple_count = (e) => (_tuplestore_tuple_count = Module._tuplestore_tuple_count = wasmExports.tuplestore_tuple_count)(e), _GetUserMapping = Module._GetUserMapping = (e, t) => (_GetUserMapping = Module._GetUserMapping = wasmExports.GetUserMapping)(e, t), _GetForeignTable = Module._GetForeignTable = (e) => (_GetForeignTable = Module._GetForeignTable = wasmExports.GetForeignTable)(e), _GetForeignColumnOptions = Module._GetForeignColumnOptions = (e, t) => (_GetForeignColumnOptions = Module._GetForeignColumnOptions = wasmExports.GetForeignColumnOptions)(e, t), _initClosestMatch = Module._initClosestMatch = (e, t, r2) => (_initClosestMatch = Module._initClosestMatch = wasmExports.initClosestMatch)(e, t, r2), _updateClosestMatch = Module._updateClosestMatch = (e, t) => (_updateClosestMatch = Module._updateClosestMatch = wasmExports.updateClosestMatch)(e, t), _getClosestMatch = Module._getClosestMatch = (e) => (_getClosestMatch = Module._getClosestMatch = wasmExports.getClosestMatch)(e), _GetExistingLocalJoinPath = Module._GetExistingLocalJoinPath = (e) => (_GetExistingLocalJoinPath = Module._GetExistingLocalJoinPath = wasmExports.GetExistingLocalJoinPath)(e), _bloom_create = Module._bloom_create = (e, t, r2) => (_bloom_create = Module._bloom_create = wasmExports.bloom_create)(e, t, r2), _bloom_free = Module._bloom_free = (e) => (_bloom_free = Module._bloom_free = wasmExports.bloom_free)(e), _bloom_add_element = Module._bloom_add_element = (e, t, r2) => (_bloom_add_element = Module._bloom_add_element = wasmExports.bloom_add_element)(e, t, r2), _bloom_lacks_element = Module._bloom_lacks_element = (e, t, r2) => (_bloom_lacks_element = Module._bloom_lacks_element = wasmExports.bloom_lacks_element)(e, t, r2), _bloom_prop_bits_set = Module._bloom_prop_bits_set = (e) => (_bloom_prop_bits_set = Module._bloom_prop_bits_set = wasmExports.bloom_prop_bits_set)(e), _gai_strerror = Module._gai_strerror = (e) => (_gai_strerror = Module._gai_strerror = wasmExports.gai_strerror)(e), _socket = Module._socket = (e, t, r2) => (_socket = Module._socket = wasmExports.socket)(e, t, r2), _connect = Module._connect = (e, t, r2) => (_connect = Module._connect = wasmExports.connect)(e, t, r2), _send = Module._send = (e, t, r2, a2) => (_send = Module._send = wasmExports.send)(e, t, r2, a2), _recv = Module._recv = (e, t, r2, a2) => (_recv = Module._recv = wasmExports.recv)(e, t, r2, a2), _be_lo_unlink = Module._be_lo_unlink = (e) => (_be_lo_unlink = Module._be_lo_unlink = wasmExports.be_lo_unlink)(e), _text_to_cstring_buffer = Module._text_to_cstring_buffer = (e, t, r2) => (_text_to_cstring_buffer = Module._text_to_cstring_buffer = wasmExports.text_to_cstring_buffer)(e, t, r2), _feof = Module._feof = (e) => (_feof = Module._feof = wasmExports.feof)(e), _pg_mb2wchar_with_len = Module._pg_mb2wchar_with_len = (e, t, r2) => (_pg_mb2wchar_with_len = Module._pg_mb2wchar_with_len = wasmExports.pg_mb2wchar_with_len)(e, t, r2), _pg_regcomp = Module._pg_regcomp = (e, t, r2, a2, o3) => (_pg_regcomp = Module._pg_regcomp = wasmExports.pg_regcomp)(e, t, r2, a2, o3), _pg_regerror = Module._pg_regerror = (e, t, r2, a2) => (_pg_regerror = Module._pg_regerror = wasmExports.pg_regerror)(e, t, r2, a2), _strcat = Module._strcat = (e, t) => (_strcat = Module._strcat = wasmExports.strcat)(e, t), _setsockopt = Module._setsockopt = (e, t, r2, a2, o3) => (_setsockopt = Module._setsockopt = wasmExports.setsockopt)(e, t, r2, a2, o3), _pq_sendtext = Module._pq_sendtext = (e, t, r2) => (_pq_sendtext = Module._pq_sendtext = wasmExports.pq_sendtext)(e, t, r2), _pq_sendfloat4 = Module._pq_sendfloat4 = (e, t) => (_pq_sendfloat4 = Module._pq_sendfloat4 = wasmExports.pq_sendfloat4)(e, t), _pq_sendfloat8 = Module._pq_sendfloat8 = (e, t) => (_pq_sendfloat8 = Module._pq_sendfloat8 = wasmExports.pq_sendfloat8)(e, t), _pq_begintypsend = Module._pq_begintypsend = (e) => (_pq_begintypsend = Module._pq_begintypsend = wasmExports.pq_begintypsend)(e), _pq_endtypsend = Module._pq_endtypsend = (e) => (_pq_endtypsend = Module._pq_endtypsend = wasmExports.pq_endtypsend)(e), _pq_getmsgfloat4 = Module._pq_getmsgfloat4 = (e) => (_pq_getmsgfloat4 = Module._pq_getmsgfloat4 = wasmExports.pq_getmsgfloat4)(e), _pq_getmsgfloat8 = Module._pq_getmsgfloat8 = (e) => (_pq_getmsgfloat8 = Module._pq_getmsgfloat8 = wasmExports.pq_getmsgfloat8)(e), _pq_getmsgtext = Module._pq_getmsgtext = (e, t, r2) => (_pq_getmsgtext = Module._pq_getmsgtext = wasmExports.pq_getmsgtext)(e, t, r2), _pg_strtoint32 = Module._pg_strtoint32 = (e) => (_pg_strtoint32 = Module._pg_strtoint32 = wasmExports.pg_strtoint32)(e), _bms_membership = Module._bms_membership = (e) => (_bms_membership = Module._bms_membership = wasmExports.bms_membership)(e), _list_make5_impl = Module._list_make5_impl = (e, t, r2, a2, o3, s4) => (_list_make5_impl = Module._list_make5_impl = wasmExports.list_make5_impl)(e, t, r2, a2, o3, s4), _lappend_xid = Module._lappend_xid = (e, t) => (_lappend_xid = Module._lappend_xid = wasmExports.lappend_xid)(e, t), _list_insert_nth = Module._list_insert_nth = (e, t, r2) => (_list_insert_nth = Module._list_insert_nth = wasmExports.list_insert_nth)(e, t, r2), _list_member_ptr = Module._list_member_ptr = (e, t) => (_list_member_ptr = Module._list_member_ptr = wasmExports.list_member_ptr)(e, t), _list_member_xid = Module._list_member_xid = (e, t) => (_list_member_xid = Module._list_member_xid = wasmExports.list_member_xid)(e, t), _list_append_unique_ptr = Module._list_append_unique_ptr = (e, t) => (_list_append_unique_ptr = Module._list_append_unique_ptr = wasmExports.list_append_unique_ptr)(e, t), _make_opclause = Module._make_opclause = (e, t, r2, a2, o3, s4, l4) => (_make_opclause = Module._make_opclause = wasmExports.make_opclause)(e, t, r2, a2, o3, s4, l4), _exprIsLengthCoercion = Module._exprIsLengthCoercion = (e, t) => (_exprIsLengthCoercion = Module._exprIsLengthCoercion = wasmExports.exprIsLengthCoercion)(e, t), _fix_opfuncids = Module._fix_opfuncids = (e) => (_fix_opfuncids = Module._fix_opfuncids = wasmExports.fix_opfuncids)(e), _CleanQuerytext = Module._CleanQuerytext = (e, t, r2) => (_CleanQuerytext = Module._CleanQuerytext = wasmExports.CleanQuerytext)(e, t, r2), _EnableQueryId = Module._EnableQueryId = () => (_EnableQueryId = Module._EnableQueryId = wasmExports.EnableQueryId)(), _find_base_rel = Module._find_base_rel = (e, t) => (_find_base_rel = Module._find_base_rel = wasmExports.find_base_rel)(e, t), _add_path = Module._add_path = (e, t) => (_add_path = Module._add_path = wasmExports.add_path)(e, t), _pathkeys_contained_in = Module._pathkeys_contained_in = (e, t) => (_pathkeys_contained_in = Module._pathkeys_contained_in = wasmExports.pathkeys_contained_in)(e, t), _create_sort_path = Module._create_sort_path = (e, t, r2, a2, o3) => (_create_sort_path = Module._create_sort_path = wasmExports.create_sort_path)(e, t, r2, a2, o3), _set_baserel_size_estimates = Module._set_baserel_size_estimates = (e, t) => (_set_baserel_size_estimates = Module._set_baserel_size_estimates = wasmExports.set_baserel_size_estimates)(e, t), _clauselist_selectivity = Module._clauselist_selectivity = (e, t, r2, a2, o3) => (_clauselist_selectivity = Module._clauselist_selectivity = wasmExports.clauselist_selectivity)(e, t, r2, a2, o3), _get_tablespace_page_costs = Module._get_tablespace_page_costs = (e, t, r2) => (_get_tablespace_page_costs = Module._get_tablespace_page_costs = wasmExports.get_tablespace_page_costs)(e, t, r2), _cost_qual_eval = Module._cost_qual_eval = (e, t, r2) => (_cost_qual_eval = Module._cost_qual_eval = wasmExports.cost_qual_eval)(e, t, r2), _estimate_num_groups = Module._estimate_num_groups = (e, t, r2, a2, o3) => (_estimate_num_groups = Module._estimate_num_groups = wasmExports.estimate_num_groups)(e, t, r2, a2, o3), _cost_sort = Module._cost_sort = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_cost_sort = Module._cost_sort = wasmExports.cost_sort)(e, t, r2, a2, o3, s4, l4, _3, n3), _get_sortgrouplist_exprs = Module._get_sortgrouplist_exprs = (e, t) => (_get_sortgrouplist_exprs = Module._get_sortgrouplist_exprs = wasmExports.get_sortgrouplist_exprs)(e, t), _make_restrictinfo = Module._make_restrictinfo = (e, t, r2, a2, o3, s4, l4, _3, n3, m4) => (_make_restrictinfo = Module._make_restrictinfo = wasmExports.make_restrictinfo)(e, t, r2, a2, o3, s4, l4, _3, n3, m4), _generate_implied_equalities_for_column = Module._generate_implied_equalities_for_column = (e, t, r2, a2, o3) => (_generate_implied_equalities_for_column = Module._generate_implied_equalities_for_column = wasmExports.generate_implied_equalities_for_column)(e, t, r2, a2, o3), _eclass_useful_for_merging = Module._eclass_useful_for_merging = (e, t, r2) => (_eclass_useful_for_merging = Module._eclass_useful_for_merging = wasmExports.eclass_useful_for_merging)(e, t, r2), _join_clause_is_movable_to = Module._join_clause_is_movable_to = (e, t) => (_join_clause_is_movable_to = Module._join_clause_is_movable_to = wasmExports.join_clause_is_movable_to)(e, t), _get_plan_rowmark = Module._get_plan_rowmark = (e, t) => (_get_plan_rowmark = Module._get_plan_rowmark = wasmExports.get_plan_rowmark)(e, t), _update_mergeclause_eclasses = Module._update_mergeclause_eclasses = (e, t) => (_update_mergeclause_eclasses = Module._update_mergeclause_eclasses = wasmExports.update_mergeclause_eclasses)(e, t), _find_join_rel = Module._find_join_rel = (e, t) => (_find_join_rel = Module._find_join_rel = wasmExports.find_join_rel)(e, t), _make_canonical_pathkey = Module._make_canonical_pathkey = (e, t, r2, a2, o3) => (_make_canonical_pathkey = Module._make_canonical_pathkey = wasmExports.make_canonical_pathkey)(e, t, r2, a2, o3), _get_sortgroupref_clause_noerr = Module._get_sortgroupref_clause_noerr = (e, t) => (_get_sortgroupref_clause_noerr = Module._get_sortgroupref_clause_noerr = wasmExports.get_sortgroupref_clause_noerr)(e, t), _extract_actual_clauses = Module._extract_actual_clauses = (e, t) => (_extract_actual_clauses = Module._extract_actual_clauses = wasmExports.extract_actual_clauses)(e, t), _change_plan_targetlist = Module._change_plan_targetlist = (e, t, r2) => (_change_plan_targetlist = Module._change_plan_targetlist = wasmExports.change_plan_targetlist)(e, t, r2), _make_foreignscan = Module._make_foreignscan = (e, t, r2, a2, o3, s4, l4, _3) => (_make_foreignscan = Module._make_foreignscan = wasmExports.make_foreignscan)(e, t, r2, a2, o3, s4, l4, _3), _tlist_member = Module._tlist_member = (e, t) => (_tlist_member = Module._tlist_member = wasmExports.tlist_member)(e, t), _pull_vars_of_level = Module._pull_vars_of_level = (e, t) => (_pull_vars_of_level = Module._pull_vars_of_level = wasmExports.pull_vars_of_level)(e, t), _IncrementVarSublevelsUp = Module._IncrementVarSublevelsUp = (e, t, r2) => (_IncrementVarSublevelsUp = Module._IncrementVarSublevelsUp = wasmExports.IncrementVarSublevelsUp)(e, t, r2), _standard_planner = Module._standard_planner = (e, t, r2, a2) => (_standard_planner = Module._standard_planner = wasmExports.standard_planner)(e, t, r2, a2), _get_relids_in_jointree = Module._get_relids_in_jointree = (e, t, r2) => (_get_relids_in_jointree = Module._get_relids_in_jointree = wasmExports.get_relids_in_jointree)(e, t, r2), _add_new_columns_to_pathtarget = Module._add_new_columns_to_pathtarget = (e, t) => (_add_new_columns_to_pathtarget = Module._add_new_columns_to_pathtarget = wasmExports.add_new_columns_to_pathtarget)(e, t), _get_agg_clause_costs = Module._get_agg_clause_costs = (e, t, r2) => (_get_agg_clause_costs = Module._get_agg_clause_costs = wasmExports.get_agg_clause_costs)(e, t, r2), _grouping_is_sortable = Module._grouping_is_sortable = (e) => (_grouping_is_sortable = Module._grouping_is_sortable = wasmExports.grouping_is_sortable)(e), _copy_pathtarget = Module._copy_pathtarget = (e) => (_copy_pathtarget = Module._copy_pathtarget = wasmExports.copy_pathtarget)(e), _create_projection_path = Module._create_projection_path = (e, t, r2, a2) => (_create_projection_path = Module._create_projection_path = wasmExports.create_projection_path)(e, t, r2, a2), _GetSysCacheHashValue = Module._GetSysCacheHashValue = (e, t, r2, a2, o3) => (_GetSysCacheHashValue = Module._GetSysCacheHashValue = wasmExports.GetSysCacheHashValue)(e, t, r2, a2, o3), _get_translated_update_targetlist = Module._get_translated_update_targetlist = (e, t, r2, a2) => (_get_translated_update_targetlist = Module._get_translated_update_targetlist = wasmExports.get_translated_update_targetlist)(e, t, r2, a2), _add_row_identity_var = Module._add_row_identity_var = (e, t, r2, a2) => (_add_row_identity_var = Module._add_row_identity_var = wasmExports.add_row_identity_var)(e, t, r2, a2), _get_rel_all_updated_cols = Module._get_rel_all_updated_cols = (e, t) => (_get_rel_all_updated_cols = Module._get_rel_all_updated_cols = wasmExports.get_rel_all_updated_cols)(e, t), _get_baserel_parampathinfo = Module._get_baserel_parampathinfo = (e, t, r2) => (_get_baserel_parampathinfo = Module._get_baserel_parampathinfo = wasmExports.get_baserel_parampathinfo)(e, t, r2), _create_foreignscan_path = Module._create_foreignscan_path = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3) => (_create_foreignscan_path = Module._create_foreignscan_path = wasmExports.create_foreignscan_path)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3), _create_foreign_join_path = Module._create_foreign_join_path = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3) => (_create_foreign_join_path = Module._create_foreign_join_path = wasmExports.create_foreign_join_path)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3), _create_foreign_upper_path = Module._create_foreign_upper_path = (e, t, r2, a2, o3, s4, l4, _3, n3, m4) => (_create_foreign_upper_path = Module._create_foreign_upper_path = wasmExports.create_foreign_upper_path)(e, t, r2, a2, o3, s4, l4, _3, n3, m4), _adjust_limit_rows_costs = Module._adjust_limit_rows_costs = (e, t, r2, a2, o3) => (_adjust_limit_rows_costs = Module._adjust_limit_rows_costs = wasmExports.adjust_limit_rows_costs)(e, t, r2, a2, o3), _add_to_flat_tlist = Module._add_to_flat_tlist = (e, t) => (_add_to_flat_tlist = Module._add_to_flat_tlist = wasmExports.add_to_flat_tlist)(e, t), _get_fn_expr_argtype = Module._get_fn_expr_argtype = (e, t) => (_get_fn_expr_argtype = Module._get_fn_expr_argtype = wasmExports.get_fn_expr_argtype)(e, t), _on_shmem_exit = Module._on_shmem_exit = (e, t) => (_on_shmem_exit = Module._on_shmem_exit = wasmExports.on_shmem_exit)(e, t), _SignalHandlerForConfigReload = Module._SignalHandlerForConfigReload = (e) => (_SignalHandlerForConfigReload = Module._SignalHandlerForConfigReload = wasmExports.SignalHandlerForConfigReload)(e), _SignalHandlerForShutdownRequest = Module._SignalHandlerForShutdownRequest = (e) => (_SignalHandlerForShutdownRequest = Module._SignalHandlerForShutdownRequest = wasmExports.SignalHandlerForShutdownRequest)(e), _procsignal_sigusr1_handler = Module._procsignal_sigusr1_handler = (e) => (_procsignal_sigusr1_handler = Module._procsignal_sigusr1_handler = wasmExports.procsignal_sigusr1_handler)(e), _RegisterBackgroundWorker = Module._RegisterBackgroundWorker = (e) => (_RegisterBackgroundWorker = Module._RegisterBackgroundWorker = wasmExports.RegisterBackgroundWorker)(e), _WaitForBackgroundWorkerStartup = Module._WaitForBackgroundWorkerStartup = (e, t) => (_WaitForBackgroundWorkerStartup = Module._WaitForBackgroundWorkerStartup = wasmExports.WaitForBackgroundWorkerStartup)(e, t), _GetConfigOption = Module._GetConfigOption = (e, t, r2) => (_GetConfigOption = Module._GetConfigOption = wasmExports.GetConfigOption)(e, t, r2), _fputc = Module._fputc = (e, t) => (_fputc = Module._fputc = wasmExports.fputc)(e, t), _toupper = Module._toupper = (e) => (_toupper = Module._toupper = wasmExports.toupper)(e), _pg_reg_getinitialstate = Module._pg_reg_getinitialstate = (e) => (_pg_reg_getinitialstate = Module._pg_reg_getinitialstate = wasmExports.pg_reg_getinitialstate)(e), _pg_reg_getfinalstate = Module._pg_reg_getfinalstate = (e) => (_pg_reg_getfinalstate = Module._pg_reg_getfinalstate = wasmExports.pg_reg_getfinalstate)(e), _pg_reg_getnumoutarcs = Module._pg_reg_getnumoutarcs = (e, t) => (_pg_reg_getnumoutarcs = Module._pg_reg_getnumoutarcs = wasmExports.pg_reg_getnumoutarcs)(e, t), _pg_reg_getoutarcs = Module._pg_reg_getoutarcs = (e, t, r2, a2) => (_pg_reg_getoutarcs = Module._pg_reg_getoutarcs = wasmExports.pg_reg_getoutarcs)(e, t, r2, a2), _pg_reg_getnumcolors = Module._pg_reg_getnumcolors = (e) => (_pg_reg_getnumcolors = Module._pg_reg_getnumcolors = wasmExports.pg_reg_getnumcolors)(e), _pg_reg_colorisbegin = Module._pg_reg_colorisbegin = (e, t) => (_pg_reg_colorisbegin = Module._pg_reg_colorisbegin = wasmExports.pg_reg_colorisbegin)(e, t), _pg_reg_colorisend = Module._pg_reg_colorisend = (e, t) => (_pg_reg_colorisend = Module._pg_reg_colorisend = wasmExports.pg_reg_colorisend)(e, t), _pg_reg_getnumcharacters = Module._pg_reg_getnumcharacters = (e, t) => (_pg_reg_getnumcharacters = Module._pg_reg_getnumcharacters = wasmExports.pg_reg_getnumcharacters)(e, t), _pg_reg_getcharacters = Module._pg_reg_getcharacters = (e, t, r2, a2) => (_pg_reg_getcharacters = Module._pg_reg_getcharacters = wasmExports.pg_reg_getcharacters)(e, t, r2, a2), _OutputPluginPrepareWrite = Module._OutputPluginPrepareWrite = (e, t) => (_OutputPluginPrepareWrite = Module._OutputPluginPrepareWrite = wasmExports.OutputPluginPrepareWrite)(e, t), _OutputPluginWrite = Module._OutputPluginWrite = (e, t) => (_OutputPluginWrite = Module._OutputPluginWrite = wasmExports.OutputPluginWrite)(e, t), _OutputPluginUpdateProgress = Module._OutputPluginUpdateProgress = (e, t) => (_OutputPluginUpdateProgress = Module._OutputPluginUpdateProgress = wasmExports.OutputPluginUpdateProgress)(e, t), _array_contains_nulls = Module._array_contains_nulls = (e) => (_array_contains_nulls = Module._array_contains_nulls = wasmExports.array_contains_nulls)(e), _replorigin_by_oid = Module._replorigin_by_oid = (e, t, r2) => (_replorigin_by_oid = Module._replorigin_by_oid = wasmExports.replorigin_by_oid)(e, t, r2), _logicalrep_write_begin = Module._logicalrep_write_begin = (e, t) => (_logicalrep_write_begin = Module._logicalrep_write_begin = wasmExports.logicalrep_write_begin)(e, t), _logicalrep_write_commit = Module._logicalrep_write_commit = (e, t, r2) => (_logicalrep_write_commit = Module._logicalrep_write_commit = wasmExports.logicalrep_write_commit)(e, t, r2), _logicalrep_write_begin_prepare = Module._logicalrep_write_begin_prepare = (e, t) => (_logicalrep_write_begin_prepare = Module._logicalrep_write_begin_prepare = wasmExports.logicalrep_write_begin_prepare)(e, t), _logicalrep_write_prepare = Module._logicalrep_write_prepare = (e, t, r2) => (_logicalrep_write_prepare = Module._logicalrep_write_prepare = wasmExports.logicalrep_write_prepare)(e, t, r2), _logicalrep_write_commit_prepared = Module._logicalrep_write_commit_prepared = (e, t, r2) => (_logicalrep_write_commit_prepared = Module._logicalrep_write_commit_prepared = wasmExports.logicalrep_write_commit_prepared)(e, t, r2), _logicalrep_write_rollback_prepared = Module._logicalrep_write_rollback_prepared = (e, t, r2, a2) => (_logicalrep_write_rollback_prepared = Module._logicalrep_write_rollback_prepared = wasmExports.logicalrep_write_rollback_prepared)(e, t, r2, a2), _logicalrep_write_stream_prepare = Module._logicalrep_write_stream_prepare = (e, t, r2) => (_logicalrep_write_stream_prepare = Module._logicalrep_write_stream_prepare = wasmExports.logicalrep_write_stream_prepare)(e, t, r2), _logicalrep_write_origin = Module._logicalrep_write_origin = (e, t, r2) => (_logicalrep_write_origin = Module._logicalrep_write_origin = wasmExports.logicalrep_write_origin)(e, t, r2), _logicalrep_write_insert = Module._logicalrep_write_insert = (e, t, r2, a2, o3, s4) => (_logicalrep_write_insert = Module._logicalrep_write_insert = wasmExports.logicalrep_write_insert)(e, t, r2, a2, o3, s4), _logicalrep_write_update = Module._logicalrep_write_update = (e, t, r2, a2, o3, s4, l4) => (_logicalrep_write_update = Module._logicalrep_write_update = wasmExports.logicalrep_write_update)(e, t, r2, a2, o3, s4, l4), _logicalrep_write_delete = Module._logicalrep_write_delete = (e, t, r2, a2, o3, s4) => (_logicalrep_write_delete = Module._logicalrep_write_delete = wasmExports.logicalrep_write_delete)(e, t, r2, a2, o3, s4), _logicalrep_write_truncate = Module._logicalrep_write_truncate = (e, t, r2, a2, o3, s4) => (_logicalrep_write_truncate = Module._logicalrep_write_truncate = wasmExports.logicalrep_write_truncate)(e, t, r2, a2, o3, s4), _logicalrep_write_message = Module._logicalrep_write_message = (e, t, r2, a2, o3, s4, l4) => (_logicalrep_write_message = Module._logicalrep_write_message = wasmExports.logicalrep_write_message)(e, t, r2, a2, o3, s4, l4), _logicalrep_write_rel = Module._logicalrep_write_rel = (e, t, r2, a2) => (_logicalrep_write_rel = Module._logicalrep_write_rel = wasmExports.logicalrep_write_rel)(e, t, r2, a2), _logicalrep_write_typ = Module._logicalrep_write_typ = (e, t, r2) => (_logicalrep_write_typ = Module._logicalrep_write_typ = wasmExports.logicalrep_write_typ)(e, t, r2), _logicalrep_write_stream_start = Module._logicalrep_write_stream_start = (e, t, r2) => (_logicalrep_write_stream_start = Module._logicalrep_write_stream_start = wasmExports.logicalrep_write_stream_start)(e, t, r2), _logicalrep_write_stream_stop = Module._logicalrep_write_stream_stop = (e) => (_logicalrep_write_stream_stop = Module._logicalrep_write_stream_stop = wasmExports.logicalrep_write_stream_stop)(e), _logicalrep_write_stream_commit = Module._logicalrep_write_stream_commit = (e, t, r2) => (_logicalrep_write_stream_commit = Module._logicalrep_write_stream_commit = wasmExports.logicalrep_write_stream_commit)(e, t, r2), _logicalrep_write_stream_abort = Module._logicalrep_write_stream_abort = (e, t, r2, a2, o3, s4) => (_logicalrep_write_stream_abort = Module._logicalrep_write_stream_abort = wasmExports.logicalrep_write_stream_abort)(e, t, r2, a2, o3, s4), _CacheRegisterRelcacheCallback = Module._CacheRegisterRelcacheCallback = (e, t) => (_CacheRegisterRelcacheCallback = Module._CacheRegisterRelcacheCallback = wasmExports.CacheRegisterRelcacheCallback)(e, t), _hash_seq_term = Module._hash_seq_term = (e) => (_hash_seq_term = Module._hash_seq_term = wasmExports.hash_seq_term)(e), _FreeErrorData = Module._FreeErrorData = (e) => (_FreeErrorData = Module._FreeErrorData = wasmExports.FreeErrorData)(e), _RelidByRelfilenumber = Module._RelidByRelfilenumber = (e, t) => (_RelidByRelfilenumber = Module._RelidByRelfilenumber = wasmExports.RelidByRelfilenumber)(e, t), _WaitLatchOrSocket = Module._WaitLatchOrSocket = (e, t, r2, a2, o3) => (_WaitLatchOrSocket = Module._WaitLatchOrSocket = wasmExports.WaitLatchOrSocket)(e, t, r2, a2, o3), _ProcessWalRcvInterrupts = Module._ProcessWalRcvInterrupts = () => (_ProcessWalRcvInterrupts = Module._ProcessWalRcvInterrupts = wasmExports.ProcessWalRcvInterrupts)(), _get_row_security_policies = Module._get_row_security_policies = (e, t, r2, a2, o3, s4, l4) => (_get_row_security_policies = Module._get_row_security_policies = wasmExports.get_row_security_policies)(e, t, r2, a2, o3, s4, l4), _hash_estimate_size = Module._hash_estimate_size = (e, t) => (_hash_estimate_size = Module._hash_estimate_size = wasmExports.hash_estimate_size)(e, t), _ShmemInitHash = Module._ShmemInitHash = (e, t, r2, a2, o3) => (_ShmemInitHash = Module._ShmemInitHash = wasmExports.ShmemInitHash)(e, t, r2, a2, o3), _LockBufHdr = Module._LockBufHdr = (e) => (_LockBufHdr = Module._LockBufHdr = wasmExports.LockBufHdr)(e), _EvictUnpinnedBuffer = Module._EvictUnpinnedBuffer = (e) => (_EvictUnpinnedBuffer = Module._EvictUnpinnedBuffer = wasmExports.EvictUnpinnedBuffer)(e), _have_free_buffer = Module._have_free_buffer = () => (_have_free_buffer = Module._have_free_buffer = wasmExports.have_free_buffer)(), _copy_file = Module._copy_file = (e, t) => (_copy_file = Module._copy_file = wasmExports.copy_file)(e, t), _AcquireExternalFD = Module._AcquireExternalFD = () => (_AcquireExternalFD = Module._AcquireExternalFD = wasmExports.AcquireExternalFD)(), _GetNamedDSMSegment = Module._GetNamedDSMSegment = (e, t, r2, a2) => (_GetNamedDSMSegment = Module._GetNamedDSMSegment = wasmExports.GetNamedDSMSegment)(e, t, r2, a2), _RequestAddinShmemSpace = Module._RequestAddinShmemSpace = (e) => (_RequestAddinShmemSpace = Module._RequestAddinShmemSpace = wasmExports.RequestAddinShmemSpace)(e), _poll = Module._poll = (e, t, r2) => (_poll = Module._poll = wasmExports.poll)(e, t, r2), _GetRunningTransactionData = Module._GetRunningTransactionData = () => (_GetRunningTransactionData = Module._GetRunningTransactionData = wasmExports.GetRunningTransactionData)(), _BackendXidGetPid = Module._BackendXidGetPid = (e) => (_BackendXidGetPid = Module._BackendXidGetPid = wasmExports.BackendXidGetPid)(e), _LWLockRegisterTranche = Module._LWLockRegisterTranche = (e, t) => (_LWLockRegisterTranche = Module._LWLockRegisterTranche = wasmExports.LWLockRegisterTranche)(e, t), _GetNamedLWLockTranche = Module._GetNamedLWLockTranche = (e) => (_GetNamedLWLockTranche = Module._GetNamedLWLockTranche = wasmExports.GetNamedLWLockTranche)(e), _LWLockNewTrancheId = Module._LWLockNewTrancheId = () => (_LWLockNewTrancheId = Module._LWLockNewTrancheId = wasmExports.LWLockNewTrancheId)(), _RequestNamedLWLockTranche = Module._RequestNamedLWLockTranche = (e, t) => (_RequestNamedLWLockTranche = Module._RequestNamedLWLockTranche = wasmExports.RequestNamedLWLockTranche)(e, t), _standard_ProcessUtility = Module._standard_ProcessUtility = (e, t, r2, a2, o3, s4, l4, _3) => (_standard_ProcessUtility = Module._standard_ProcessUtility = wasmExports.standard_ProcessUtility)(e, t, r2, a2, o3, s4, l4, _3), _lookup_ts_dictionary_cache = Module._lookup_ts_dictionary_cache = (e) => (_lookup_ts_dictionary_cache = Module._lookup_ts_dictionary_cache = wasmExports.lookup_ts_dictionary_cache)(e), _get_tsearch_config_filename = Module._get_tsearch_config_filename = (e, t) => (_get_tsearch_config_filename = Module._get_tsearch_config_filename = wasmExports.get_tsearch_config_filename)(e, t), _lowerstr = Module._lowerstr = (e) => (_lowerstr = Module._lowerstr = wasmExports.lowerstr)(e), _readstoplist = Module._readstoplist = (e, t, r2) => (_readstoplist = Module._readstoplist = wasmExports.readstoplist)(e, t, r2), _lowerstr_with_len = Module._lowerstr_with_len = (e, t) => (_lowerstr_with_len = Module._lowerstr_with_len = wasmExports.lowerstr_with_len)(e, t), _searchstoplist = Module._searchstoplist = (e, t) => (_searchstoplist = Module._searchstoplist = wasmExports.searchstoplist)(e, t), _tsearch_readline_begin = Module._tsearch_readline_begin = (e, t) => (_tsearch_readline_begin = Module._tsearch_readline_begin = wasmExports.tsearch_readline_begin)(e, t), _tsearch_readline = Module._tsearch_readline = (e) => (_tsearch_readline = Module._tsearch_readline = wasmExports.tsearch_readline)(e), _t_isspace = Module._t_isspace = (e) => (_t_isspace = Module._t_isspace = wasmExports.t_isspace)(e), _tsearch_readline_end = Module._tsearch_readline_end = (e) => (_tsearch_readline_end = Module._tsearch_readline_end = wasmExports.tsearch_readline_end)(e), _stringToQualifiedNameList = Module._stringToQualifiedNameList = (e, t) => (_stringToQualifiedNameList = Module._stringToQualifiedNameList = wasmExports.stringToQualifiedNameList)(e, t), _t_isdigit = Module._t_isdigit = (e) => (_t_isdigit = Module._t_isdigit = wasmExports.t_isdigit)(e), _t_isalnum = Module._t_isalnum = (e) => (_t_isalnum = Module._t_isalnum = wasmExports.t_isalnum)(e), _get_restriction_variable = Module._get_restriction_variable = (e, t, r2, a2, o3, s4) => (_get_restriction_variable = Module._get_restriction_variable = wasmExports.get_restriction_variable)(e, t, r2, a2, o3, s4), _MemoryContextAllocHuge = Module._MemoryContextAllocHuge = (e, t) => (_MemoryContextAllocHuge = Module._MemoryContextAllocHuge = wasmExports.MemoryContextAllocHuge)(e, t), _WaitEventExtensionNew = Module._WaitEventExtensionNew = (e) => (_WaitEventExtensionNew = Module._WaitEventExtensionNew = wasmExports.WaitEventExtensionNew)(e), _expand_array = Module._expand_array = (e, t, r2) => (_expand_array = Module._expand_array = wasmExports.expand_array)(e, t, r2), _arraycontsel = Module._arraycontsel = (e) => (_arraycontsel = Module._arraycontsel = wasmExports.arraycontsel)(e), _arraycontjoinsel = Module._arraycontjoinsel = (e) => (_arraycontjoinsel = Module._arraycontjoinsel = wasmExports.arraycontjoinsel)(e), _initArrayResult = Module._initArrayResult = (e, t, r2) => (_initArrayResult = Module._initArrayResult = wasmExports.initArrayResult)(e, t, r2), _array_create_iterator = Module._array_create_iterator = (e, t, r2) => (_array_create_iterator = Module._array_create_iterator = wasmExports.array_create_iterator)(e, t, r2), _array_iterate = Module._array_iterate = (e, t, r2) => (_array_iterate = Module._array_iterate = wasmExports.array_iterate)(e, t, r2), _ArrayGetIntegerTypmods = Module._ArrayGetIntegerTypmods = (e, t) => (_ArrayGetIntegerTypmods = Module._ArrayGetIntegerTypmods = wasmExports.ArrayGetIntegerTypmods)(e, t), _boolin = Module._boolin = (e) => (_boolin = Module._boolin = wasmExports.boolin)(e), _cash_cmp = Module._cash_cmp = (e) => (_cash_cmp = Module._cash_cmp = wasmExports.cash_cmp)(e), _int64_to_numeric = Module._int64_to_numeric = (e) => (_int64_to_numeric = Module._int64_to_numeric = wasmExports.int64_to_numeric)(e), _numeric_div = Module._numeric_div = (e) => (_numeric_div = Module._numeric_div = wasmExports.numeric_div)(e), _date_eq = Module._date_eq = (e) => (_date_eq = Module._date_eq = wasmExports.date_eq)(e), _date_lt = Module._date_lt = (e) => (_date_lt = Module._date_lt = wasmExports.date_lt)(e), _date_le = Module._date_le = (e) => (_date_le = Module._date_le = wasmExports.date_le)(e), _date_gt = Module._date_gt = (e) => (_date_gt = Module._date_gt = wasmExports.date_gt)(e), _date_ge = Module._date_ge = (e) => (_date_ge = Module._date_ge = wasmExports.date_ge)(e), _date_cmp = Module._date_cmp = (e) => (_date_cmp = Module._date_cmp = wasmExports.date_cmp)(e), _date_mi = Module._date_mi = (e) => (_date_mi = Module._date_mi = wasmExports.date_mi)(e), _time_eq = Module._time_eq = (e) => (_time_eq = Module._time_eq = wasmExports.time_eq)(e), _time_lt = Module._time_lt = (e) => (_time_lt = Module._time_lt = wasmExports.time_lt)(e), _time_le = Module._time_le = (e) => (_time_le = Module._time_le = wasmExports.time_le)(e), _time_gt = Module._time_gt = (e) => (_time_gt = Module._time_gt = wasmExports.time_gt)(e), _time_ge = Module._time_ge = (e) => (_time_ge = Module._time_ge = wasmExports.time_ge)(e), _time_cmp = Module._time_cmp = (e) => (_time_cmp = Module._time_cmp = wasmExports.time_cmp)(e), _time_mi_time = Module._time_mi_time = (e) => (_time_mi_time = Module._time_mi_time = wasmExports.time_mi_time)(e), _timetz_cmp = Module._timetz_cmp = (e) => (_timetz_cmp = Module._timetz_cmp = wasmExports.timetz_cmp)(e), _TransferExpandedObject = Module._TransferExpandedObject = (e, t) => (_TransferExpandedObject = Module._TransferExpandedObject = wasmExports.TransferExpandedObject)(e, t), _numeric_lt = Module._numeric_lt = (e) => (_numeric_lt = Module._numeric_lt = wasmExports.numeric_lt)(e), _numeric_ge = Module._numeric_ge = (e) => (_numeric_ge = Module._numeric_ge = wasmExports.numeric_ge)(e), _err_generic_string = Module._err_generic_string = (e, t) => (_err_generic_string = Module._err_generic_string = wasmExports.err_generic_string)(e, t), _domain_check = Module._domain_check = (e, t, r2, a2, o3) => (_domain_check = Module._domain_check = wasmExports.domain_check)(e, t, r2, a2, o3), _enum_lt = Module._enum_lt = (e) => (_enum_lt = Module._enum_lt = wasmExports.enum_lt)(e), _enum_le = Module._enum_le = (e) => (_enum_le = Module._enum_le = wasmExports.enum_le)(e), _enum_ge = Module._enum_ge = (e) => (_enum_ge = Module._enum_ge = wasmExports.enum_ge)(e), _enum_gt = Module._enum_gt = (e) => (_enum_gt = Module._enum_gt = wasmExports.enum_gt)(e), _enum_cmp = Module._enum_cmp = (e) => (_enum_cmp = Module._enum_cmp = wasmExports.enum_cmp)(e), _make_expanded_record_from_typeid = Module._make_expanded_record_from_typeid = (e, t, r2) => (_make_expanded_record_from_typeid = Module._make_expanded_record_from_typeid = wasmExports.make_expanded_record_from_typeid)(e, t, r2), _MemoryContextRegisterResetCallback = Module._MemoryContextRegisterResetCallback = (e, t) => (_MemoryContextRegisterResetCallback = Module._MemoryContextRegisterResetCallback = wasmExports.MemoryContextRegisterResetCallback)(e, t), _make_expanded_record_from_tupdesc = Module._make_expanded_record_from_tupdesc = (e, t) => (_make_expanded_record_from_tupdesc = Module._make_expanded_record_from_tupdesc = wasmExports.make_expanded_record_from_tupdesc)(e, t), _make_expanded_record_from_exprecord = Module._make_expanded_record_from_exprecord = (e, t) => (_make_expanded_record_from_exprecord = Module._make_expanded_record_from_exprecord = wasmExports.make_expanded_record_from_exprecord)(e, t), _expanded_record_set_tuple = Module._expanded_record_set_tuple = (e, t, r2, a2) => (_expanded_record_set_tuple = Module._expanded_record_set_tuple = wasmExports.expanded_record_set_tuple)(e, t, r2, a2), _expanded_record_get_tuple = Module._expanded_record_get_tuple = (e) => (_expanded_record_get_tuple = Module._expanded_record_get_tuple = wasmExports.expanded_record_get_tuple)(e), _deconstruct_expanded_record = Module._deconstruct_expanded_record = (e) => (_deconstruct_expanded_record = Module._deconstruct_expanded_record = wasmExports.deconstruct_expanded_record)(e), _expanded_record_lookup_field = Module._expanded_record_lookup_field = (e, t, r2) => (_expanded_record_lookup_field = Module._expanded_record_lookup_field = wasmExports.expanded_record_lookup_field)(e, t, r2), _expanded_record_set_field_internal = Module._expanded_record_set_field_internal = (e, t, r2, a2, o3, s4) => (_expanded_record_set_field_internal = Module._expanded_record_set_field_internal = wasmExports.expanded_record_set_field_internal)(e, t, r2, a2, o3, s4), _expanded_record_set_fields = Module._expanded_record_set_fields = (e, t, r2, a2) => (_expanded_record_set_fields = Module._expanded_record_set_fields = wasmExports.expanded_record_set_fields)(e, t, r2, a2), _float4in_internal = Module._float4in_internal = (e, t, r2, a2, o3) => (_float4in_internal = Module._float4in_internal = wasmExports.float4in_internal)(e, t, r2, a2, o3), _strtof = Module._strtof = (e, t) => (_strtof = Module._strtof = wasmExports.strtof)(e, t), _float8in_internal = Module._float8in_internal = (e, t, r2, a2, o3) => (_float8in_internal = Module._float8in_internal = wasmExports.float8in_internal)(e, t, r2, a2, o3), _float8out_internal = Module._float8out_internal = (e) => (_float8out_internal = Module._float8out_internal = wasmExports.float8out_internal)(e), _btfloat4cmp = Module._btfloat4cmp = (e) => (_btfloat4cmp = Module._btfloat4cmp = wasmExports.btfloat4cmp)(e), _btfloat8cmp = Module._btfloat8cmp = (e) => (_btfloat8cmp = Module._btfloat8cmp = wasmExports.btfloat8cmp)(e), _log10 = Module._log10 = (e) => (_log10 = Module._log10 = wasmExports.log10)(e), _acos = Module._acos = (e) => (_acos = Module._acos = wasmExports.acos)(e), _asin = Module._asin = (e) => (_asin = Module._asin = wasmExports.asin)(e), _cos = Module._cos = (e) => (_cos = Module._cos = wasmExports.cos)(e), _fmod = Module._fmod = (e, t) => (_fmod = Module._fmod = wasmExports.fmod)(e, t), _str_tolower = Module._str_tolower = (e, t, r2) => (_str_tolower = Module._str_tolower = wasmExports.str_tolower)(e, t, r2), _pushJsonbValue = Module._pushJsonbValue = (e, t, r2) => (_pushJsonbValue = Module._pushJsonbValue = wasmExports.pushJsonbValue)(e, t, r2), _numeric_float4 = Module._numeric_float4 = (e) => (_numeric_float4 = Module._numeric_float4 = wasmExports.numeric_float4)(e), _numeric_cmp = Module._numeric_cmp = (e) => (_numeric_cmp = Module._numeric_cmp = wasmExports.numeric_cmp)(e), _numeric_eq = Module._numeric_eq = (e) => (_numeric_eq = Module._numeric_eq = wasmExports.numeric_eq)(e), _numeric_is_nan = Module._numeric_is_nan = (e) => (_numeric_is_nan = Module._numeric_is_nan = wasmExports.numeric_is_nan)(e), _timestamp_cmp = Module._timestamp_cmp = (e) => (_timestamp_cmp = Module._timestamp_cmp = wasmExports.timestamp_cmp)(e), _macaddr_cmp = Module._macaddr_cmp = (e) => (_macaddr_cmp = Module._macaddr_cmp = wasmExports.macaddr_cmp)(e), _macaddr_lt = Module._macaddr_lt = (e) => (_macaddr_lt = Module._macaddr_lt = wasmExports.macaddr_lt)(e), _macaddr_le = Module._macaddr_le = (e) => (_macaddr_le = Module._macaddr_le = wasmExports.macaddr_le)(e), _macaddr_eq = Module._macaddr_eq = (e) => (_macaddr_eq = Module._macaddr_eq = wasmExports.macaddr_eq)(e), _macaddr_ge = Module._macaddr_ge = (e) => (_macaddr_ge = Module._macaddr_ge = wasmExports.macaddr_ge)(e), _macaddr_gt = Module._macaddr_gt = (e) => (_macaddr_gt = Module._macaddr_gt = wasmExports.macaddr_gt)(e), _macaddr8_cmp = Module._macaddr8_cmp = (e) => (_macaddr8_cmp = Module._macaddr8_cmp = wasmExports.macaddr8_cmp)(e), _macaddr8_lt = Module._macaddr8_lt = (e) => (_macaddr8_lt = Module._macaddr8_lt = wasmExports.macaddr8_lt)(e), _macaddr8_le = Module._macaddr8_le = (e) => (_macaddr8_le = Module._macaddr8_le = wasmExports.macaddr8_le)(e), _macaddr8_eq = Module._macaddr8_eq = (e) => (_macaddr8_eq = Module._macaddr8_eq = wasmExports.macaddr8_eq)(e), _macaddr8_ge = Module._macaddr8_ge = (e) => (_macaddr8_ge = Module._macaddr8_ge = wasmExports.macaddr8_ge)(e), _macaddr8_gt = Module._macaddr8_gt = (e) => (_macaddr8_gt = Module._macaddr8_gt = wasmExports.macaddr8_gt)(e), _current_query = Module._current_query = (e) => (_current_query = Module._current_query = wasmExports.current_query)(e), _unpack_sql_state = Module._unpack_sql_state = (e) => (_unpack_sql_state = Module._unpack_sql_state = wasmExports.unpack_sql_state)(e), _get_fn_expr_rettype = Module._get_fn_expr_rettype = (e) => (_get_fn_expr_rettype = Module._get_fn_expr_rettype = wasmExports.get_fn_expr_rettype)(e), _btnamecmp = Module._btnamecmp = (e) => (_btnamecmp = Module._btnamecmp = wasmExports.btnamecmp)(e), _inet_in = Module._inet_in = (e) => (_inet_in = Module._inet_in = wasmExports.inet_in)(e), _network_cmp = Module._network_cmp = (e) => (_network_cmp = Module._network_cmp = wasmExports.network_cmp)(e), _convert_network_to_scalar = Module._convert_network_to_scalar = (e, t, r2) => (_convert_network_to_scalar = Module._convert_network_to_scalar = wasmExports.convert_network_to_scalar)(e, t, r2), _numeric_gt = Module._numeric_gt = (e) => (_numeric_gt = Module._numeric_gt = wasmExports.numeric_gt)(e), _numeric_le = Module._numeric_le = (e) => (_numeric_le = Module._numeric_le = wasmExports.numeric_le)(e), _numeric_float8_no_overflow = Module._numeric_float8_no_overflow = (e) => (_numeric_float8_no_overflow = Module._numeric_float8_no_overflow = wasmExports.numeric_float8_no_overflow)(e), _oidout = Module._oidout = (e) => (_oidout = Module._oidout = wasmExports.oidout)(e), _interval_mi = Module._interval_mi = (e) => (_interval_mi = Module._interval_mi = wasmExports.interval_mi)(e), _localtime = Module._localtime = (e) => (_localtime = Module._localtime = wasmExports.localtime)(e), _quote_ident = Module._quote_ident = (e) => (_quote_ident = Module._quote_ident = wasmExports.quote_ident)(e), _pg_wchar2mb_with_len = Module._pg_wchar2mb_with_len = (e, t, r2) => (_pg_wchar2mb_with_len = Module._pg_wchar2mb_with_len = wasmExports.pg_wchar2mb_with_len)(e, t, r2), _pg_get_indexdef_columns_extended = Module._pg_get_indexdef_columns_extended = (e, t) => (_pg_get_indexdef_columns_extended = Module._pg_get_indexdef_columns_extended = wasmExports.pg_get_indexdef_columns_extended)(e, t), _pg_get_querydef = Module._pg_get_querydef = (e, t) => (_pg_get_querydef = Module._pg_get_querydef = wasmExports.pg_get_querydef)(e, t), _strcspn = Module._strcspn = (e, t) => (_strcspn = Module._strcspn = wasmExports.strcspn)(e, t), _generic_restriction_selectivity = Module._generic_restriction_selectivity = (e, t, r2, a2, o3, s4) => (_generic_restriction_selectivity = Module._generic_restriction_selectivity = wasmExports.generic_restriction_selectivity)(e, t, r2, a2, o3, s4), _genericcostestimate = Module._genericcostestimate = (e, t, r2, a2) => (_genericcostestimate = Module._genericcostestimate = wasmExports.genericcostestimate)(e, t, r2, a2), _tidin = Module._tidin = (e) => (_tidin = Module._tidin = wasmExports.tidin)(e), _tidout = Module._tidout = (e) => (_tidout = Module._tidout = wasmExports.tidout)(e), _timestamp_in = Module._timestamp_in = (e) => (_timestamp_in = Module._timestamp_in = wasmExports.timestamp_in)(e), _timestamp_eq = Module._timestamp_eq = (e) => (_timestamp_eq = Module._timestamp_eq = wasmExports.timestamp_eq)(e), _timestamp_lt = Module._timestamp_lt = (e) => (_timestamp_lt = Module._timestamp_lt = wasmExports.timestamp_lt)(e), _timestamp_gt = Module._timestamp_gt = (e) => (_timestamp_gt = Module._timestamp_gt = wasmExports.timestamp_gt)(e), _timestamp_le = Module._timestamp_le = (e) => (_timestamp_le = Module._timestamp_le = wasmExports.timestamp_le)(e), _timestamp_ge = Module._timestamp_ge = (e) => (_timestamp_ge = Module._timestamp_ge = wasmExports.timestamp_ge)(e), _interval_eq = Module._interval_eq = (e) => (_interval_eq = Module._interval_eq = wasmExports.interval_eq)(e), _interval_lt = Module._interval_lt = (e) => (_interval_lt = Module._interval_lt = wasmExports.interval_lt)(e), _interval_gt = Module._interval_gt = (e) => (_interval_gt = Module._interval_gt = wasmExports.interval_gt)(e), _interval_le = Module._interval_le = (e) => (_interval_le = Module._interval_le = wasmExports.interval_le)(e), _interval_ge = Module._interval_ge = (e) => (_interval_ge = Module._interval_ge = wasmExports.interval_ge)(e), _interval_cmp = Module._interval_cmp = (e) => (_interval_cmp = Module._interval_cmp = wasmExports.interval_cmp)(e), _timestamp_mi = Module._timestamp_mi = (e) => (_timestamp_mi = Module._timestamp_mi = wasmExports.timestamp_mi)(e), _interval_um = Module._interval_um = (e) => (_interval_um = Module._interval_um = wasmExports.interval_um)(e), _has_fn_opclass_options = Module._has_fn_opclass_options = (e) => (_has_fn_opclass_options = Module._has_fn_opclass_options = wasmExports.has_fn_opclass_options)(e), _uuid_in = Module._uuid_in = (e) => (_uuid_in = Module._uuid_in = wasmExports.uuid_in)(e), _uuid_out = Module._uuid_out = (e) => (_uuid_out = Module._uuid_out = wasmExports.uuid_out)(e), _uuid_cmp = Module._uuid_cmp = (e) => (_uuid_cmp = Module._uuid_cmp = wasmExports.uuid_cmp)(e), _gen_random_uuid = Module._gen_random_uuid = (e) => (_gen_random_uuid = Module._gen_random_uuid = wasmExports.gen_random_uuid)(e), _varbit_in = Module._varbit_in = (e) => (_varbit_in = Module._varbit_in = wasmExports.varbit_in)(e), _biteq = Module._biteq = (e) => (_biteq = Module._biteq = wasmExports.biteq)(e), _bitlt = Module._bitlt = (e) => (_bitlt = Module._bitlt = wasmExports.bitlt)(e), _bitle = Module._bitle = (e) => (_bitle = Module._bitle = wasmExports.bitle)(e), _bitgt = Module._bitgt = (e) => (_bitgt = Module._bitgt = wasmExports.bitgt)(e), _bitge = Module._bitge = (e) => (_bitge = Module._bitge = wasmExports.bitge)(e), _bitcmp = Module._bitcmp = (e) => (_bitcmp = Module._bitcmp = wasmExports.bitcmp)(e), _bpchareq = Module._bpchareq = (e) => (_bpchareq = Module._bpchareq = wasmExports.bpchareq)(e), _bpcharlt = Module._bpcharlt = (e) => (_bpcharlt = Module._bpcharlt = wasmExports.bpcharlt)(e), _bpcharle = Module._bpcharle = (e) => (_bpcharle = Module._bpcharle = wasmExports.bpcharle)(e), _bpchargt = Module._bpchargt = (e) => (_bpchargt = Module._bpchargt = wasmExports.bpchargt)(e), _bpcharge = Module._bpcharge = (e) => (_bpcharge = Module._bpcharge = wasmExports.bpcharge)(e), _bpcharcmp = Module._bpcharcmp = (e) => (_bpcharcmp = Module._bpcharcmp = wasmExports.bpcharcmp)(e), _texteq = Module._texteq = (e) => (_texteq = Module._texteq = wasmExports.texteq)(e), _text_lt = Module._text_lt = (e) => (_text_lt = Module._text_lt = wasmExports.text_lt)(e), _text_le = Module._text_le = (e) => (_text_le = Module._text_le = wasmExports.text_le)(e), _text_gt = Module._text_gt = (e) => (_text_gt = Module._text_gt = wasmExports.text_gt)(e), _text_ge = Module._text_ge = (e) => (_text_ge = Module._text_ge = wasmExports.text_ge)(e), _bttextcmp = Module._bttextcmp = (e) => (_bttextcmp = Module._bttextcmp = wasmExports.bttextcmp)(e), _byteaeq = Module._byteaeq = (e) => (_byteaeq = Module._byteaeq = wasmExports.byteaeq)(e), _bytealt = Module._bytealt = (e) => (_bytealt = Module._bytealt = wasmExports.bytealt)(e), _byteale = Module._byteale = (e) => (_byteale = Module._byteale = wasmExports.byteale)(e), _byteagt = Module._byteagt = (e) => (_byteagt = Module._byteagt = wasmExports.byteagt)(e), _byteage = Module._byteage = (e) => (_byteage = Module._byteage = wasmExports.byteage)(e), _byteacmp = Module._byteacmp = (e) => (_byteacmp = Module._byteacmp = wasmExports.byteacmp)(e), _to_hex32 = Module._to_hex32 = (e) => (_to_hex32 = Module._to_hex32 = wasmExports.to_hex32)(e), _varstr_levenshtein = Module._varstr_levenshtein = (e, t, r2, a2, o3, s4, l4, _3) => (_varstr_levenshtein = Module._varstr_levenshtein = wasmExports.varstr_levenshtein)(e, t, r2, a2, o3, s4, l4, _3), _pg_xml_init = Module._pg_xml_init = (e) => (_pg_xml_init = Module._pg_xml_init = wasmExports.pg_xml_init)(e), _xmlInitParser = Module._xmlInitParser = () => (_xmlInitParser = Module._xmlInitParser = wasmExports.xmlInitParser)(), _xml_ereport = Module._xml_ereport = (e, t, r2, a2) => (_xml_ereport = Module._xml_ereport = wasmExports.xml_ereport)(e, t, r2, a2), _pg_xml_done = Module._pg_xml_done = (e, t) => (_pg_xml_done = Module._pg_xml_done = wasmExports.pg_xml_done)(e, t), _xmlXPathNewContext = Module._xmlXPathNewContext = (e) => (_xmlXPathNewContext = Module._xmlXPathNewContext = wasmExports.xmlXPathNewContext)(e), _xmlXPathFreeContext = Module._xmlXPathFreeContext = (e) => (_xmlXPathFreeContext = Module._xmlXPathFreeContext = wasmExports.xmlXPathFreeContext)(e), _xmlFreeDoc = Module._xmlFreeDoc = (e) => (_xmlFreeDoc = Module._xmlFreeDoc = wasmExports.xmlFreeDoc)(e), _xmlXPathCtxtCompile = Module._xmlXPathCtxtCompile = (e, t) => (_xmlXPathCtxtCompile = Module._xmlXPathCtxtCompile = wasmExports.xmlXPathCtxtCompile)(e, t), _xmlXPathCompiledEval = Module._xmlXPathCompiledEval = (e, t) => (_xmlXPathCompiledEval = Module._xmlXPathCompiledEval = wasmExports.xmlXPathCompiledEval)(e, t), _xmlXPathFreeCompExpr = Module._xmlXPathFreeCompExpr = (e) => (_xmlXPathFreeCompExpr = Module._xmlXPathFreeCompExpr = wasmExports.xmlXPathFreeCompExpr)(e), _pg_do_encoding_conversion = Module._pg_do_encoding_conversion = (e, t, r2, a2) => (_pg_do_encoding_conversion = Module._pg_do_encoding_conversion = wasmExports.pg_do_encoding_conversion)(e, t, r2, a2), _xmlStrdup = Module._xmlStrdup = (e) => (_xmlStrdup = Module._xmlStrdup = wasmExports.xmlStrdup)(e), _xmlXPathCastNodeToString = Module._xmlXPathCastNodeToString = (e) => (_xmlXPathCastNodeToString = Module._xmlXPathCastNodeToString = wasmExports.xmlXPathCastNodeToString)(e), _get_typsubscript = Module._get_typsubscript = (e, t) => (_get_typsubscript = Module._get_typsubscript = wasmExports.get_typsubscript)(e, t), _CachedPlanAllowsSimpleValidityCheck = Module._CachedPlanAllowsSimpleValidityCheck = (e, t, r2) => (_CachedPlanAllowsSimpleValidityCheck = Module._CachedPlanAllowsSimpleValidityCheck = wasmExports.CachedPlanAllowsSimpleValidityCheck)(e, t, r2), _CachedPlanIsSimplyValid = Module._CachedPlanIsSimplyValid = (e, t, r2) => (_CachedPlanIsSimplyValid = Module._CachedPlanIsSimplyValid = wasmExports.CachedPlanIsSimplyValid)(e, t, r2), _GetCachedExpression = Module._GetCachedExpression = (e) => (_GetCachedExpression = Module._GetCachedExpression = wasmExports.GetCachedExpression)(e), _FreeCachedExpression = Module._FreeCachedExpression = (e) => (_FreeCachedExpression = Module._FreeCachedExpression = wasmExports.FreeCachedExpression)(e), _ReleaseAllPlanCacheRefsInOwner = Module._ReleaseAllPlanCacheRefsInOwner = (e) => (_ReleaseAllPlanCacheRefsInOwner = Module._ReleaseAllPlanCacheRefsInOwner = wasmExports.ReleaseAllPlanCacheRefsInOwner)(e), _in_error_recursion_trouble = Module._in_error_recursion_trouble = () => (_in_error_recursion_trouble = Module._in_error_recursion_trouble = wasmExports.in_error_recursion_trouble)(), _GetErrorContextStack = Module._GetErrorContextStack = () => (_GetErrorContextStack = Module._GetErrorContextStack = wasmExports.GetErrorContextStack)(), _dlsym = Module._dlsym = (e, t) => (_dlsym = Module._dlsym = wasmExports.dlsym)(e, t), _dlopen = Module._dlopen = (e, t) => (_dlopen = Module._dlopen = wasmExports.dlopen)(e, t), _dlerror = Module._dlerror = () => (_dlerror = Module._dlerror = wasmExports.dlerror)(), _dlclose = Module._dlclose = (e) => (_dlclose = Module._dlclose = wasmExports.dlclose)(e), _find_rendezvous_variable = Module._find_rendezvous_variable = (e) => (_find_rendezvous_variable = Module._find_rendezvous_variable = wasmExports.find_rendezvous_variable)(e), _CallerFInfoFunctionCall2 = Module._CallerFInfoFunctionCall2 = (e, t, r2, a2, o3) => (_CallerFInfoFunctionCall2 = Module._CallerFInfoFunctionCall2 = wasmExports.CallerFInfoFunctionCall2)(e, t, r2, a2, o3), _FunctionCall0Coll = Module._FunctionCall0Coll = (e, t) => (_FunctionCall0Coll = Module._FunctionCall0Coll = wasmExports.FunctionCall0Coll)(e, t), _resolve_polymorphic_argtypes = Module._resolve_polymorphic_argtypes = (e, t, r2, a2) => (_resolve_polymorphic_argtypes = Module._resolve_polymorphic_argtypes = wasmExports.resolve_polymorphic_argtypes)(e, t, r2, a2), _memcpy = Module._memcpy = (e, t, r2) => (_memcpy = Module._memcpy = wasmExports.memcpy)(e, t, r2), _pg_bindtextdomain = Module._pg_bindtextdomain = (e) => (_pg_bindtextdomain = Module._pg_bindtextdomain = wasmExports.pg_bindtextdomain)(e), _local2local = Module._local2local = (e, t, r2, a2, o3, s4, l4) => (_local2local = Module._local2local = wasmExports.local2local)(e, t, r2, a2, o3, s4, l4), _report_untranslatable_char = Module._report_untranslatable_char = (e, t, r2, a2) => (_report_untranslatable_char = Module._report_untranslatable_char = wasmExports.report_untranslatable_char)(e, t, r2, a2), _latin2mic = Module._latin2mic = (e, t, r2, a2, o3, s4) => (_latin2mic = Module._latin2mic = wasmExports.latin2mic)(e, t, r2, a2, o3, s4), _mic2latin = Module._mic2latin = (e, t, r2, a2, o3, s4) => (_mic2latin = Module._mic2latin = wasmExports.mic2latin)(e, t, r2, a2, o3, s4), _latin2mic_with_table = Module._latin2mic_with_table = (e, t, r2, a2, o3, s4, l4) => (_latin2mic_with_table = Module._latin2mic_with_table = wasmExports.latin2mic_with_table)(e, t, r2, a2, o3, s4, l4), _mic2latin_with_table = Module._mic2latin_with_table = (e, t, r2, a2, o3, s4, l4) => (_mic2latin_with_table = Module._mic2latin_with_table = wasmExports.mic2latin_with_table)(e, t, r2, a2, o3, s4, l4), _UtfToLocal = Module._UtfToLocal = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_UtfToLocal = Module._UtfToLocal = wasmExports.UtfToLocal)(e, t, r2, a2, o3, s4, l4, _3, n3), _LocalToUtf = Module._LocalToUtf = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_LocalToUtf = Module._LocalToUtf = wasmExports.LocalToUtf)(e, t, r2, a2, o3, s4, l4, _3, n3), _check_encoding_conversion_args = Module._check_encoding_conversion_args = (e, t, r2, a2, o3) => (_check_encoding_conversion_args = Module._check_encoding_conversion_args = wasmExports.check_encoding_conversion_args)(e, t, r2, a2, o3), _DefineCustomBoolVariable = Module._DefineCustomBoolVariable = (e, t, r2, a2, o3, s4, l4, _3, n3, m4) => (_DefineCustomBoolVariable = Module._DefineCustomBoolVariable = wasmExports.DefineCustomBoolVariable)(e, t, r2, a2, o3, s4, l4, _3, n3, m4), _DefineCustomIntVariable = Module._DefineCustomIntVariable = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3) => (_DefineCustomIntVariable = Module._DefineCustomIntVariable = wasmExports.DefineCustomIntVariable)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3), _DefineCustomRealVariable = Module._DefineCustomRealVariable = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3) => (_DefineCustomRealVariable = Module._DefineCustomRealVariable = wasmExports.DefineCustomRealVariable)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3), _DefineCustomStringVariable = Module._DefineCustomStringVariable = (e, t, r2, a2, o3, s4, l4, _3, n3, m4) => (_DefineCustomStringVariable = Module._DefineCustomStringVariable = wasmExports.DefineCustomStringVariable)(e, t, r2, a2, o3, s4, l4, _3, n3, m4), _DefineCustomEnumVariable = Module._DefineCustomEnumVariable = (e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3) => (_DefineCustomEnumVariable = Module._DefineCustomEnumVariable = wasmExports.DefineCustomEnumVariable)(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3), _MarkGUCPrefixReserved = Module._MarkGUCPrefixReserved = (e) => (_MarkGUCPrefixReserved = Module._MarkGUCPrefixReserved = wasmExports.MarkGUCPrefixReserved)(e), _sampler_random_init_state = Module._sampler_random_init_state = (e, t) => (_sampler_random_init_state = Module._sampler_random_init_state = wasmExports.sampler_random_init_state)(e, t), _pchomp = Module._pchomp = (e) => (_pchomp = Module._pchomp = wasmExports.pchomp)(e), _PinPortal = Module._PinPortal = (e) => (_PinPortal = Module._PinPortal = wasmExports.PinPortal)(e), _UnpinPortal = Module._UnpinPortal = (e) => (_UnpinPortal = Module._UnpinPortal = wasmExports.UnpinPortal)(e), _isolat1ToUTF8 = Module._isolat1ToUTF8 = (e, t, r2, a2) => (_isolat1ToUTF8 = Module._isolat1ToUTF8 = wasmExports.isolat1ToUTF8)(e, t, r2, a2), _UTF8Toisolat1 = Module._UTF8Toisolat1 = (e, t, r2, a2) => (_UTF8Toisolat1 = Module._UTF8Toisolat1 = wasmExports.UTF8Toisolat1)(e, t, r2, a2), _vfprintf = Module._vfprintf = (e, t, r2) => (_vfprintf = Module._vfprintf = wasmExports.vfprintf)(e, t, r2), _vsnprintf = Module._vsnprintf = (e, t, r2, a2) => (_vsnprintf = Module._vsnprintf = wasmExports.vsnprintf)(e, t, r2, a2), _xmlParserValidityWarning = Module._xmlParserValidityWarning = (e, t, r2) => (_xmlParserValidityWarning = Module._xmlParserValidityWarning = wasmExports.xmlParserValidityWarning)(e, t, r2), _xmlParserValidityError = Module._xmlParserValidityError = (e, t, r2) => (_xmlParserValidityError = Module._xmlParserValidityError = wasmExports.xmlParserValidityError)(e, t, r2), _xmlParserError = Module._xmlParserError = (e, t, r2) => (_xmlParserError = Module._xmlParserError = wasmExports.xmlParserError)(e, t, r2), _xmlParserWarning = Module._xmlParserWarning = (e, t, r2) => (_xmlParserWarning = Module._xmlParserWarning = wasmExports.xmlParserWarning)(e, t, r2), _fprintf = Module._fprintf = (e, t, r2) => (_fprintf = Module._fprintf = wasmExports.fprintf)(e, t, r2), ___xmlParserInputBufferCreateFilename = Module.___xmlParserInputBufferCreateFilename = (e, t) => (___xmlParserInputBufferCreateFilename = Module.___xmlParserInputBufferCreateFilename = wasmExports.__xmlParserInputBufferCreateFilename)(e, t), ___xmlOutputBufferCreateFilename = Module.___xmlOutputBufferCreateFilename = (e, t, r2) => (___xmlOutputBufferCreateFilename = Module.___xmlOutputBufferCreateFilename = wasmExports.__xmlOutputBufferCreateFilename)(e, t, r2), _xmlSAX2InternalSubset = Module._xmlSAX2InternalSubset = (e, t, r2, a2) => (_xmlSAX2InternalSubset = Module._xmlSAX2InternalSubset = wasmExports.xmlSAX2InternalSubset)(e, t, r2, a2), _xmlSAX2IsStandalone = Module._xmlSAX2IsStandalone = (e) => (_xmlSAX2IsStandalone = Module._xmlSAX2IsStandalone = wasmExports.xmlSAX2IsStandalone)(e), _xmlSAX2HasInternalSubset = Module._xmlSAX2HasInternalSubset = (e) => (_xmlSAX2HasInternalSubset = Module._xmlSAX2HasInternalSubset = wasmExports.xmlSAX2HasInternalSubset)(e), _xmlSAX2HasExternalSubset = Module._xmlSAX2HasExternalSubset = (e) => (_xmlSAX2HasExternalSubset = Module._xmlSAX2HasExternalSubset = wasmExports.xmlSAX2HasExternalSubset)(e), _xmlSAX2ResolveEntity = Module._xmlSAX2ResolveEntity = (e, t, r2) => (_xmlSAX2ResolveEntity = Module._xmlSAX2ResolveEntity = wasmExports.xmlSAX2ResolveEntity)(e, t, r2), _xmlSAX2GetEntity = Module._xmlSAX2GetEntity = (e, t) => (_xmlSAX2GetEntity = Module._xmlSAX2GetEntity = wasmExports.xmlSAX2GetEntity)(e, t), _xmlSAX2EntityDecl = Module._xmlSAX2EntityDecl = (e, t, r2, a2, o3, s4) => (_xmlSAX2EntityDecl = Module._xmlSAX2EntityDecl = wasmExports.xmlSAX2EntityDecl)(e, t, r2, a2, o3, s4), _xmlSAX2NotationDecl = Module._xmlSAX2NotationDecl = (e, t, r2, a2) => (_xmlSAX2NotationDecl = Module._xmlSAX2NotationDecl = wasmExports.xmlSAX2NotationDecl)(e, t, r2, a2), _xmlSAX2AttributeDecl = Module._xmlSAX2AttributeDecl = (e, t, r2, a2, o3, s4, l4) => (_xmlSAX2AttributeDecl = Module._xmlSAX2AttributeDecl = wasmExports.xmlSAX2AttributeDecl)(e, t, r2, a2, o3, s4, l4), _xmlSAX2ElementDecl = Module._xmlSAX2ElementDecl = (e, t, r2, a2) => (_xmlSAX2ElementDecl = Module._xmlSAX2ElementDecl = wasmExports.xmlSAX2ElementDecl)(e, t, r2, a2), _xmlSAX2UnparsedEntityDecl = Module._xmlSAX2UnparsedEntityDecl = (e, t, r2, a2, o3) => (_xmlSAX2UnparsedEntityDecl = Module._xmlSAX2UnparsedEntityDecl = wasmExports.xmlSAX2UnparsedEntityDecl)(e, t, r2, a2, o3), _xmlSAX2SetDocumentLocator = Module._xmlSAX2SetDocumentLocator = (e, t) => (_xmlSAX2SetDocumentLocator = Module._xmlSAX2SetDocumentLocator = wasmExports.xmlSAX2SetDocumentLocator)(e, t), _xmlSAX2StartDocument = Module._xmlSAX2StartDocument = (e) => (_xmlSAX2StartDocument = Module._xmlSAX2StartDocument = wasmExports.xmlSAX2StartDocument)(e), _xmlSAX2EndDocument = Module._xmlSAX2EndDocument = (e) => (_xmlSAX2EndDocument = Module._xmlSAX2EndDocument = wasmExports.xmlSAX2EndDocument)(e), _xmlSAX2StartElement = Module._xmlSAX2StartElement = (e, t, r2) => (_xmlSAX2StartElement = Module._xmlSAX2StartElement = wasmExports.xmlSAX2StartElement)(e, t, r2), _xmlSAX2EndElement = Module._xmlSAX2EndElement = (e, t) => (_xmlSAX2EndElement = Module._xmlSAX2EndElement = wasmExports.xmlSAX2EndElement)(e, t), _xmlSAX2Reference = Module._xmlSAX2Reference = (e, t) => (_xmlSAX2Reference = Module._xmlSAX2Reference = wasmExports.xmlSAX2Reference)(e, t), _xmlSAX2Characters = Module._xmlSAX2Characters = (e, t, r2) => (_xmlSAX2Characters = Module._xmlSAX2Characters = wasmExports.xmlSAX2Characters)(e, t, r2), _xmlSAX2ProcessingInstruction = Module._xmlSAX2ProcessingInstruction = (e, t, r2) => (_xmlSAX2ProcessingInstruction = Module._xmlSAX2ProcessingInstruction = wasmExports.xmlSAX2ProcessingInstruction)(e, t, r2), _xmlSAX2Comment = Module._xmlSAX2Comment = (e, t) => (_xmlSAX2Comment = Module._xmlSAX2Comment = wasmExports.xmlSAX2Comment)(e, t), _xmlSAX2GetParameterEntity = Module._xmlSAX2GetParameterEntity = (e, t) => (_xmlSAX2GetParameterEntity = Module._xmlSAX2GetParameterEntity = wasmExports.xmlSAX2GetParameterEntity)(e, t), _xmlSAX2CDataBlock = Module._xmlSAX2CDataBlock = (e, t, r2) => (_xmlSAX2CDataBlock = Module._xmlSAX2CDataBlock = wasmExports.xmlSAX2CDataBlock)(e, t, r2), _xmlSAX2ExternalSubset = Module._xmlSAX2ExternalSubset = (e, t, r2, a2) => (_xmlSAX2ExternalSubset = Module._xmlSAX2ExternalSubset = wasmExports.xmlSAX2ExternalSubset)(e, t, r2, a2), _xmlSAX2GetPublicId = Module._xmlSAX2GetPublicId = (e) => (_xmlSAX2GetPublicId = Module._xmlSAX2GetPublicId = wasmExports.xmlSAX2GetPublicId)(e), _xmlSAX2GetSystemId = Module._xmlSAX2GetSystemId = (e) => (_xmlSAX2GetSystemId = Module._xmlSAX2GetSystemId = wasmExports.xmlSAX2GetSystemId)(e), _xmlSAX2GetLineNumber = Module._xmlSAX2GetLineNumber = (e) => (_xmlSAX2GetLineNumber = Module._xmlSAX2GetLineNumber = wasmExports.xmlSAX2GetLineNumber)(e), _xmlSAX2GetColumnNumber = Module._xmlSAX2GetColumnNumber = (e) => (_xmlSAX2GetColumnNumber = Module._xmlSAX2GetColumnNumber = wasmExports.xmlSAX2GetColumnNumber)(e), _xmlSAX2IgnorableWhitespace = Module._xmlSAX2IgnorableWhitespace = (e, t, r2) => (_xmlSAX2IgnorableWhitespace = Module._xmlSAX2IgnorableWhitespace = wasmExports.xmlSAX2IgnorableWhitespace)(e, t, r2), _xmlHashDefaultDeallocator = Module._xmlHashDefaultDeallocator = (e, t) => (_xmlHashDefaultDeallocator = Module._xmlHashDefaultDeallocator = wasmExports.xmlHashDefaultDeallocator)(e, t), _iconv_open = Module._iconv_open = (e, t) => (_iconv_open = Module._iconv_open = wasmExports.iconv_open)(e, t), _iconv_close = Module._iconv_close = (e) => (_iconv_close = Module._iconv_close = wasmExports.iconv_close)(e), _iconv = Module._iconv = (e, t, r2, a2, o3) => (_iconv = Module._iconv = wasmExports.iconv)(e, t, r2, a2, o3), _UTF8ToHtml = Module._UTF8ToHtml = (e, t, r2, a2) => (_UTF8ToHtml = Module._UTF8ToHtml = wasmExports.UTF8ToHtml)(e, t, r2, a2), _xmlReadMemory = Module._xmlReadMemory = (e, t, r2, a2, o3) => (_xmlReadMemory = Module._xmlReadMemory = wasmExports.xmlReadMemory)(e, t, r2, a2, o3), _xmlSAX2StartElementNs = Module._xmlSAX2StartElementNs = (e, t, r2, a2, o3, s4, l4, _3, n3) => (_xmlSAX2StartElementNs = Module._xmlSAX2StartElementNs = wasmExports.xmlSAX2StartElementNs)(e, t, r2, a2, o3, s4, l4, _3, n3), _xmlSAX2EndElementNs = Module._xmlSAX2EndElementNs = (e, t, r2, a2) => (_xmlSAX2EndElementNs = Module._xmlSAX2EndElementNs = wasmExports.xmlSAX2EndElementNs)(e, t, r2, a2), ___cxa_atexit = Module.___cxa_atexit = (e, t, r2) => (___cxa_atexit = Module.___cxa_atexit = wasmExports.__cxa_atexit)(e, t, r2), _xmlDocGetRootElement = Module._xmlDocGetRootElement = (e) => (_xmlDocGetRootElement = Module._xmlDocGetRootElement = wasmExports.xmlDocGetRootElement)(e), _xmlFileMatch = Module._xmlFileMatch = (e) => (_xmlFileMatch = Module._xmlFileMatch = wasmExports.xmlFileMatch)(e), _xmlFileOpen = Module._xmlFileOpen = (e) => (_xmlFileOpen = Module._xmlFileOpen = wasmExports.xmlFileOpen)(e), _xmlFileRead = Module._xmlFileRead = (e, t, r2) => (_xmlFileRead = Module._xmlFileRead = wasmExports.xmlFileRead)(e, t, r2), _xmlFileClose = Module._xmlFileClose = (e) => (_xmlFileClose = Module._xmlFileClose = wasmExports.xmlFileClose)(e), _gzread = Module._gzread = (e, t, r2) => (_gzread = Module._gzread = wasmExports.gzread)(e, t, r2), _gzclose = Module._gzclose = (e) => (_gzclose = Module._gzclose = wasmExports.gzclose)(e), _gzdirect = Module._gzdirect = (e) => (_gzdirect = Module._gzdirect = wasmExports.gzdirect)(e), _gzdopen = Module._gzdopen = (e, t) => (_gzdopen = Module._gzdopen = wasmExports.gzdopen)(e, t), _gzopen = Module._gzopen = (e, t) => (_gzopen = Module._gzopen = wasmExports.gzopen)(e, t), _gzwrite = Module._gzwrite = (e, t, r2) => (_gzwrite = Module._gzwrite = wasmExports.gzwrite)(e, t, r2), _xmlUCSIsCatNd = Module._xmlUCSIsCatNd = (e) => (_xmlUCSIsCatNd = Module._xmlUCSIsCatNd = wasmExports.xmlUCSIsCatNd)(e), _xmlUCSIsCatP = Module._xmlUCSIsCatP = (e) => (_xmlUCSIsCatP = Module._xmlUCSIsCatP = wasmExports.xmlUCSIsCatP)(e), _xmlUCSIsCatZ = Module._xmlUCSIsCatZ = (e) => (_xmlUCSIsCatZ = Module._xmlUCSIsCatZ = wasmExports.xmlUCSIsCatZ)(e), _xmlUCSIsCatC = Module._xmlUCSIsCatC = (e) => (_xmlUCSIsCatC = Module._xmlUCSIsCatC = wasmExports.xmlUCSIsCatC)(e), _xmlUCSIsCatL = Module._xmlUCSIsCatL = (e) => (_xmlUCSIsCatL = Module._xmlUCSIsCatL = wasmExports.xmlUCSIsCatL)(e), _xmlUCSIsCatLu = Module._xmlUCSIsCatLu = (e) => (_xmlUCSIsCatLu = Module._xmlUCSIsCatLu = wasmExports.xmlUCSIsCatLu)(e), _xmlUCSIsCatLl = Module._xmlUCSIsCatLl = (e) => (_xmlUCSIsCatLl = Module._xmlUCSIsCatLl = wasmExports.xmlUCSIsCatLl)(e), _xmlUCSIsCatLt = Module._xmlUCSIsCatLt = (e) => (_xmlUCSIsCatLt = Module._xmlUCSIsCatLt = wasmExports.xmlUCSIsCatLt)(e), _xmlUCSIsCatLm = Module._xmlUCSIsCatLm = (e) => (_xmlUCSIsCatLm = Module._xmlUCSIsCatLm = wasmExports.xmlUCSIsCatLm)(e), _xmlUCSIsCatLo = Module._xmlUCSIsCatLo = (e) => (_xmlUCSIsCatLo = Module._xmlUCSIsCatLo = wasmExports.xmlUCSIsCatLo)(e), _xmlUCSIsCatM = Module._xmlUCSIsCatM = (e) => (_xmlUCSIsCatM = Module._xmlUCSIsCatM = wasmExports.xmlUCSIsCatM)(e), _xmlUCSIsCatMn = Module._xmlUCSIsCatMn = (e) => (_xmlUCSIsCatMn = Module._xmlUCSIsCatMn = wasmExports.xmlUCSIsCatMn)(e), _xmlUCSIsCatMc = Module._xmlUCSIsCatMc = (e) => (_xmlUCSIsCatMc = Module._xmlUCSIsCatMc = wasmExports.xmlUCSIsCatMc)(e), _xmlUCSIsCatMe = Module._xmlUCSIsCatMe = (e) => (_xmlUCSIsCatMe = Module._xmlUCSIsCatMe = wasmExports.xmlUCSIsCatMe)(e), _xmlUCSIsCatN = Module._xmlUCSIsCatN = (e) => (_xmlUCSIsCatN = Module._xmlUCSIsCatN = wasmExports.xmlUCSIsCatN)(e), _xmlUCSIsCatNl = Module._xmlUCSIsCatNl = (e) => (_xmlUCSIsCatNl = Module._xmlUCSIsCatNl = wasmExports.xmlUCSIsCatNl)(e), _xmlUCSIsCatNo = Module._xmlUCSIsCatNo = (e) => (_xmlUCSIsCatNo = Module._xmlUCSIsCatNo = wasmExports.xmlUCSIsCatNo)(e), _xmlUCSIsCatPc = Module._xmlUCSIsCatPc = (e) => (_xmlUCSIsCatPc = Module._xmlUCSIsCatPc = wasmExports.xmlUCSIsCatPc)(e), _xmlUCSIsCatPd = Module._xmlUCSIsCatPd = (e) => (_xmlUCSIsCatPd = Module._xmlUCSIsCatPd = wasmExports.xmlUCSIsCatPd)(e), _xmlUCSIsCatPs = Module._xmlUCSIsCatPs = (e) => (_xmlUCSIsCatPs = Module._xmlUCSIsCatPs = wasmExports.xmlUCSIsCatPs)(e), _xmlUCSIsCatPe = Module._xmlUCSIsCatPe = (e) => (_xmlUCSIsCatPe = Module._xmlUCSIsCatPe = wasmExports.xmlUCSIsCatPe)(e), _xmlUCSIsCatPi = Module._xmlUCSIsCatPi = (e) => (_xmlUCSIsCatPi = Module._xmlUCSIsCatPi = wasmExports.xmlUCSIsCatPi)(e), _xmlUCSIsCatPf = Module._xmlUCSIsCatPf = (e) => (_xmlUCSIsCatPf = Module._xmlUCSIsCatPf = wasmExports.xmlUCSIsCatPf)(e), _xmlUCSIsCatPo = Module._xmlUCSIsCatPo = (e) => (_xmlUCSIsCatPo = Module._xmlUCSIsCatPo = wasmExports.xmlUCSIsCatPo)(e), _xmlUCSIsCatZs = Module._xmlUCSIsCatZs = (e) => (_xmlUCSIsCatZs = Module._xmlUCSIsCatZs = wasmExports.xmlUCSIsCatZs)(e), _xmlUCSIsCatZl = Module._xmlUCSIsCatZl = (e) => (_xmlUCSIsCatZl = Module._xmlUCSIsCatZl = wasmExports.xmlUCSIsCatZl)(e), _xmlUCSIsCatZp = Module._xmlUCSIsCatZp = (e) => (_xmlUCSIsCatZp = Module._xmlUCSIsCatZp = wasmExports.xmlUCSIsCatZp)(e), _xmlUCSIsCatS = Module._xmlUCSIsCatS = (e) => (_xmlUCSIsCatS = Module._xmlUCSIsCatS = wasmExports.xmlUCSIsCatS)(e), _xmlUCSIsCatSm = Module._xmlUCSIsCatSm = (e) => (_xmlUCSIsCatSm = Module._xmlUCSIsCatSm = wasmExports.xmlUCSIsCatSm)(e), _xmlUCSIsCatSc = Module._xmlUCSIsCatSc = (e) => (_xmlUCSIsCatSc = Module._xmlUCSIsCatSc = wasmExports.xmlUCSIsCatSc)(e), _xmlUCSIsCatSk = Module._xmlUCSIsCatSk = (e) => (_xmlUCSIsCatSk = Module._xmlUCSIsCatSk = wasmExports.xmlUCSIsCatSk)(e), _xmlUCSIsCatSo = Module._xmlUCSIsCatSo = (e) => (_xmlUCSIsCatSo = Module._xmlUCSIsCatSo = wasmExports.xmlUCSIsCatSo)(e), _xmlUCSIsCatCc = Module._xmlUCSIsCatCc = (e) => (_xmlUCSIsCatCc = Module._xmlUCSIsCatCc = wasmExports.xmlUCSIsCatCc)(e), _xmlUCSIsCatCf = Module._xmlUCSIsCatCf = (e) => (_xmlUCSIsCatCf = Module._xmlUCSIsCatCf = wasmExports.xmlUCSIsCatCf)(e), _xmlUCSIsCatCo = Module._xmlUCSIsCatCo = (e) => (_xmlUCSIsCatCo = Module._xmlUCSIsCatCo = wasmExports.xmlUCSIsCatCo)(e), _xmlUCSIsAegeanNumbers = Module._xmlUCSIsAegeanNumbers = (e) => (_xmlUCSIsAegeanNumbers = Module._xmlUCSIsAegeanNumbers = wasmExports.xmlUCSIsAegeanNumbers)(e), _xmlUCSIsAlphabeticPresentationForms = Module._xmlUCSIsAlphabeticPresentationForms = (e) => (_xmlUCSIsAlphabeticPresentationForms = Module._xmlUCSIsAlphabeticPresentationForms = wasmExports.xmlUCSIsAlphabeticPresentationForms)(e), _xmlUCSIsArabic = Module._xmlUCSIsArabic = (e) => (_xmlUCSIsArabic = Module._xmlUCSIsArabic = wasmExports.xmlUCSIsArabic)(e), _xmlUCSIsArabicPresentationFormsA = Module._xmlUCSIsArabicPresentationFormsA = (e) => (_xmlUCSIsArabicPresentationFormsA = Module._xmlUCSIsArabicPresentationFormsA = wasmExports.xmlUCSIsArabicPresentationFormsA)(e), _xmlUCSIsArabicPresentationFormsB = Module._xmlUCSIsArabicPresentationFormsB = (e) => (_xmlUCSIsArabicPresentationFormsB = Module._xmlUCSIsArabicPresentationFormsB = wasmExports.xmlUCSIsArabicPresentationFormsB)(e), _xmlUCSIsArmenian = Module._xmlUCSIsArmenian = (e) => (_xmlUCSIsArmenian = Module._xmlUCSIsArmenian = wasmExports.xmlUCSIsArmenian)(e), _xmlUCSIsArrows = Module._xmlUCSIsArrows = (e) => (_xmlUCSIsArrows = Module._xmlUCSIsArrows = wasmExports.xmlUCSIsArrows)(e), _xmlUCSIsBasicLatin = Module._xmlUCSIsBasicLatin = (e) => (_xmlUCSIsBasicLatin = Module._xmlUCSIsBasicLatin = wasmExports.xmlUCSIsBasicLatin)(e), _xmlUCSIsBengali = Module._xmlUCSIsBengali = (e) => (_xmlUCSIsBengali = Module._xmlUCSIsBengali = wasmExports.xmlUCSIsBengali)(e), _xmlUCSIsBlockElements = Module._xmlUCSIsBlockElements = (e) => (_xmlUCSIsBlockElements = Module._xmlUCSIsBlockElements = wasmExports.xmlUCSIsBlockElements)(e), _xmlUCSIsBopomofo = Module._xmlUCSIsBopomofo = (e) => (_xmlUCSIsBopomofo = Module._xmlUCSIsBopomofo = wasmExports.xmlUCSIsBopomofo)(e), _xmlUCSIsBopomofoExtended = Module._xmlUCSIsBopomofoExtended = (e) => (_xmlUCSIsBopomofoExtended = Module._xmlUCSIsBopomofoExtended = wasmExports.xmlUCSIsBopomofoExtended)(e), _xmlUCSIsBoxDrawing = Module._xmlUCSIsBoxDrawing = (e) => (_xmlUCSIsBoxDrawing = Module._xmlUCSIsBoxDrawing = wasmExports.xmlUCSIsBoxDrawing)(e), _xmlUCSIsBraillePatterns = Module._xmlUCSIsBraillePatterns = (e) => (_xmlUCSIsBraillePatterns = Module._xmlUCSIsBraillePatterns = wasmExports.xmlUCSIsBraillePatterns)(e), _xmlUCSIsBuhid = Module._xmlUCSIsBuhid = (e) => (_xmlUCSIsBuhid = Module._xmlUCSIsBuhid = wasmExports.xmlUCSIsBuhid)(e), _xmlUCSIsByzantineMusicalSymbols = Module._xmlUCSIsByzantineMusicalSymbols = (e) => (_xmlUCSIsByzantineMusicalSymbols = Module._xmlUCSIsByzantineMusicalSymbols = wasmExports.xmlUCSIsByzantineMusicalSymbols)(e), _xmlUCSIsCJKCompatibility = Module._xmlUCSIsCJKCompatibility = (e) => (_xmlUCSIsCJKCompatibility = Module._xmlUCSIsCJKCompatibility = wasmExports.xmlUCSIsCJKCompatibility)(e), _xmlUCSIsCJKCompatibilityForms = Module._xmlUCSIsCJKCompatibilityForms = (e) => (_xmlUCSIsCJKCompatibilityForms = Module._xmlUCSIsCJKCompatibilityForms = wasmExports.xmlUCSIsCJKCompatibilityForms)(e), _xmlUCSIsCJKCompatibilityIdeographs = Module._xmlUCSIsCJKCompatibilityIdeographs = (e) => (_xmlUCSIsCJKCompatibilityIdeographs = Module._xmlUCSIsCJKCompatibilityIdeographs = wasmExports.xmlUCSIsCJKCompatibilityIdeographs)(e), _xmlUCSIsCJKCompatibilityIdeographsSupplement = Module._xmlUCSIsCJKCompatibilityIdeographsSupplement = (e) => (_xmlUCSIsCJKCompatibilityIdeographsSupplement = Module._xmlUCSIsCJKCompatibilityIdeographsSupplement = wasmExports.xmlUCSIsCJKCompatibilityIdeographsSupplement)(e), _xmlUCSIsCJKRadicalsSupplement = Module._xmlUCSIsCJKRadicalsSupplement = (e) => (_xmlUCSIsCJKRadicalsSupplement = Module._xmlUCSIsCJKRadicalsSupplement = wasmExports.xmlUCSIsCJKRadicalsSupplement)(e), _xmlUCSIsCJKSymbolsandPunctuation = Module._xmlUCSIsCJKSymbolsandPunctuation = (e) => (_xmlUCSIsCJKSymbolsandPunctuation = Module._xmlUCSIsCJKSymbolsandPunctuation = wasmExports.xmlUCSIsCJKSymbolsandPunctuation)(e), _xmlUCSIsCJKUnifiedIdeographs = Module._xmlUCSIsCJKUnifiedIdeographs = (e) => (_xmlUCSIsCJKUnifiedIdeographs = Module._xmlUCSIsCJKUnifiedIdeographs = wasmExports.xmlUCSIsCJKUnifiedIdeographs)(e), _xmlUCSIsCJKUnifiedIdeographsExtensionA = Module._xmlUCSIsCJKUnifiedIdeographsExtensionA = (e) => (_xmlUCSIsCJKUnifiedIdeographsExtensionA = Module._xmlUCSIsCJKUnifiedIdeographsExtensionA = wasmExports.xmlUCSIsCJKUnifiedIdeographsExtensionA)(e), _xmlUCSIsCJKUnifiedIdeographsExtensionB = Module._xmlUCSIsCJKUnifiedIdeographsExtensionB = (e) => (_xmlUCSIsCJKUnifiedIdeographsExtensionB = Module._xmlUCSIsCJKUnifiedIdeographsExtensionB = wasmExports.xmlUCSIsCJKUnifiedIdeographsExtensionB)(e), _xmlUCSIsCherokee = Module._xmlUCSIsCherokee = (e) => (_xmlUCSIsCherokee = Module._xmlUCSIsCherokee = wasmExports.xmlUCSIsCherokee)(e), _xmlUCSIsCombiningDiacriticalMarks = Module._xmlUCSIsCombiningDiacriticalMarks = (e) => (_xmlUCSIsCombiningDiacriticalMarks = Module._xmlUCSIsCombiningDiacriticalMarks = wasmExports.xmlUCSIsCombiningDiacriticalMarks)(e), _xmlUCSIsCombiningDiacriticalMarksforSymbols = Module._xmlUCSIsCombiningDiacriticalMarksforSymbols = (e) => (_xmlUCSIsCombiningDiacriticalMarksforSymbols = Module._xmlUCSIsCombiningDiacriticalMarksforSymbols = wasmExports.xmlUCSIsCombiningDiacriticalMarksforSymbols)(e), _xmlUCSIsCombiningHalfMarks = Module._xmlUCSIsCombiningHalfMarks = (e) => (_xmlUCSIsCombiningHalfMarks = Module._xmlUCSIsCombiningHalfMarks = wasmExports.xmlUCSIsCombiningHalfMarks)(e), _xmlUCSIsCombiningMarksforSymbols = Module._xmlUCSIsCombiningMarksforSymbols = (e) => (_xmlUCSIsCombiningMarksforSymbols = Module._xmlUCSIsCombiningMarksforSymbols = wasmExports.xmlUCSIsCombiningMarksforSymbols)(e), _xmlUCSIsControlPictures = Module._xmlUCSIsControlPictures = (e) => (_xmlUCSIsControlPictures = Module._xmlUCSIsControlPictures = wasmExports.xmlUCSIsControlPictures)(e), _xmlUCSIsCurrencySymbols = Module._xmlUCSIsCurrencySymbols = (e) => (_xmlUCSIsCurrencySymbols = Module._xmlUCSIsCurrencySymbols = wasmExports.xmlUCSIsCurrencySymbols)(e), _xmlUCSIsCypriotSyllabary = Module._xmlUCSIsCypriotSyllabary = (e) => (_xmlUCSIsCypriotSyllabary = Module._xmlUCSIsCypriotSyllabary = wasmExports.xmlUCSIsCypriotSyllabary)(e), _xmlUCSIsCyrillic = Module._xmlUCSIsCyrillic = (e) => (_xmlUCSIsCyrillic = Module._xmlUCSIsCyrillic = wasmExports.xmlUCSIsCyrillic)(e), _xmlUCSIsCyrillicSupplement = Module._xmlUCSIsCyrillicSupplement = (e) => (_xmlUCSIsCyrillicSupplement = Module._xmlUCSIsCyrillicSupplement = wasmExports.xmlUCSIsCyrillicSupplement)(e), _xmlUCSIsDeseret = Module._xmlUCSIsDeseret = (e) => (_xmlUCSIsDeseret = Module._xmlUCSIsDeseret = wasmExports.xmlUCSIsDeseret)(e), _xmlUCSIsDevanagari = Module._xmlUCSIsDevanagari = (e) => (_xmlUCSIsDevanagari = Module._xmlUCSIsDevanagari = wasmExports.xmlUCSIsDevanagari)(e), _xmlUCSIsDingbats = Module._xmlUCSIsDingbats = (e) => (_xmlUCSIsDingbats = Module._xmlUCSIsDingbats = wasmExports.xmlUCSIsDingbats)(e), _xmlUCSIsEnclosedAlphanumerics = Module._xmlUCSIsEnclosedAlphanumerics = (e) => (_xmlUCSIsEnclosedAlphanumerics = Module._xmlUCSIsEnclosedAlphanumerics = wasmExports.xmlUCSIsEnclosedAlphanumerics)(e), _xmlUCSIsEnclosedCJKLettersandMonths = Module._xmlUCSIsEnclosedCJKLettersandMonths = (e) => (_xmlUCSIsEnclosedCJKLettersandMonths = Module._xmlUCSIsEnclosedCJKLettersandMonths = wasmExports.xmlUCSIsEnclosedCJKLettersandMonths)(e), _xmlUCSIsEthiopic = Module._xmlUCSIsEthiopic = (e) => (_xmlUCSIsEthiopic = Module._xmlUCSIsEthiopic = wasmExports.xmlUCSIsEthiopic)(e), _xmlUCSIsGeneralPunctuation = Module._xmlUCSIsGeneralPunctuation = (e) => (_xmlUCSIsGeneralPunctuation = Module._xmlUCSIsGeneralPunctuation = wasmExports.xmlUCSIsGeneralPunctuation)(e), _xmlUCSIsGeometricShapes = Module._xmlUCSIsGeometricShapes = (e) => (_xmlUCSIsGeometricShapes = Module._xmlUCSIsGeometricShapes = wasmExports.xmlUCSIsGeometricShapes)(e), _xmlUCSIsGeorgian = Module._xmlUCSIsGeorgian = (e) => (_xmlUCSIsGeorgian = Module._xmlUCSIsGeorgian = wasmExports.xmlUCSIsGeorgian)(e), _xmlUCSIsGothic = Module._xmlUCSIsGothic = (e) => (_xmlUCSIsGothic = Module._xmlUCSIsGothic = wasmExports.xmlUCSIsGothic)(e), _xmlUCSIsGreek = Module._xmlUCSIsGreek = (e) => (_xmlUCSIsGreek = Module._xmlUCSIsGreek = wasmExports.xmlUCSIsGreek)(e), _xmlUCSIsGreekExtended = Module._xmlUCSIsGreekExtended = (e) => (_xmlUCSIsGreekExtended = Module._xmlUCSIsGreekExtended = wasmExports.xmlUCSIsGreekExtended)(e), _xmlUCSIsGreekandCoptic = Module._xmlUCSIsGreekandCoptic = (e) => (_xmlUCSIsGreekandCoptic = Module._xmlUCSIsGreekandCoptic = wasmExports.xmlUCSIsGreekandCoptic)(e), _xmlUCSIsGujarati = Module._xmlUCSIsGujarati = (e) => (_xmlUCSIsGujarati = Module._xmlUCSIsGujarati = wasmExports.xmlUCSIsGujarati)(e), _xmlUCSIsGurmukhi = Module._xmlUCSIsGurmukhi = (e) => (_xmlUCSIsGurmukhi = Module._xmlUCSIsGurmukhi = wasmExports.xmlUCSIsGurmukhi)(e), _xmlUCSIsHalfwidthandFullwidthForms = Module._xmlUCSIsHalfwidthandFullwidthForms = (e) => (_xmlUCSIsHalfwidthandFullwidthForms = Module._xmlUCSIsHalfwidthandFullwidthForms = wasmExports.xmlUCSIsHalfwidthandFullwidthForms)(e), _xmlUCSIsHangulCompatibilityJamo = Module._xmlUCSIsHangulCompatibilityJamo = (e) => (_xmlUCSIsHangulCompatibilityJamo = Module._xmlUCSIsHangulCompatibilityJamo = wasmExports.xmlUCSIsHangulCompatibilityJamo)(e), _xmlUCSIsHangulJamo = Module._xmlUCSIsHangulJamo = (e) => (_xmlUCSIsHangulJamo = Module._xmlUCSIsHangulJamo = wasmExports.xmlUCSIsHangulJamo)(e), _xmlUCSIsHangulSyllables = Module._xmlUCSIsHangulSyllables = (e) => (_xmlUCSIsHangulSyllables = Module._xmlUCSIsHangulSyllables = wasmExports.xmlUCSIsHangulSyllables)(e), _xmlUCSIsHanunoo = Module._xmlUCSIsHanunoo = (e) => (_xmlUCSIsHanunoo = Module._xmlUCSIsHanunoo = wasmExports.xmlUCSIsHanunoo)(e), _xmlUCSIsHebrew = Module._xmlUCSIsHebrew = (e) => (_xmlUCSIsHebrew = Module._xmlUCSIsHebrew = wasmExports.xmlUCSIsHebrew)(e), _xmlUCSIsHighPrivateUseSurrogates = Module._xmlUCSIsHighPrivateUseSurrogates = (e) => (_xmlUCSIsHighPrivateUseSurrogates = Module._xmlUCSIsHighPrivateUseSurrogates = wasmExports.xmlUCSIsHighPrivateUseSurrogates)(e), _xmlUCSIsHighSurrogates = Module._xmlUCSIsHighSurrogates = (e) => (_xmlUCSIsHighSurrogates = Module._xmlUCSIsHighSurrogates = wasmExports.xmlUCSIsHighSurrogates)(e), _xmlUCSIsHiragana = Module._xmlUCSIsHiragana = (e) => (_xmlUCSIsHiragana = Module._xmlUCSIsHiragana = wasmExports.xmlUCSIsHiragana)(e), _xmlUCSIsIPAExtensions = Module._xmlUCSIsIPAExtensions = (e) => (_xmlUCSIsIPAExtensions = Module._xmlUCSIsIPAExtensions = wasmExports.xmlUCSIsIPAExtensions)(e), _xmlUCSIsIdeographicDescriptionCharacters = Module._xmlUCSIsIdeographicDescriptionCharacters = (e) => (_xmlUCSIsIdeographicDescriptionCharacters = Module._xmlUCSIsIdeographicDescriptionCharacters = wasmExports.xmlUCSIsIdeographicDescriptionCharacters)(e), _xmlUCSIsKanbun = Module._xmlUCSIsKanbun = (e) => (_xmlUCSIsKanbun = Module._xmlUCSIsKanbun = wasmExports.xmlUCSIsKanbun)(e), _xmlUCSIsKangxiRadicals = Module._xmlUCSIsKangxiRadicals = (e) => (_xmlUCSIsKangxiRadicals = Module._xmlUCSIsKangxiRadicals = wasmExports.xmlUCSIsKangxiRadicals)(e), _xmlUCSIsKannada = Module._xmlUCSIsKannada = (e) => (_xmlUCSIsKannada = Module._xmlUCSIsKannada = wasmExports.xmlUCSIsKannada)(e), _xmlUCSIsKatakana = Module._xmlUCSIsKatakana = (e) => (_xmlUCSIsKatakana = Module._xmlUCSIsKatakana = wasmExports.xmlUCSIsKatakana)(e), _xmlUCSIsKatakanaPhoneticExtensions = Module._xmlUCSIsKatakanaPhoneticExtensions = (e) => (_xmlUCSIsKatakanaPhoneticExtensions = Module._xmlUCSIsKatakanaPhoneticExtensions = wasmExports.xmlUCSIsKatakanaPhoneticExtensions)(e), _xmlUCSIsKhmer = Module._xmlUCSIsKhmer = (e) => (_xmlUCSIsKhmer = Module._xmlUCSIsKhmer = wasmExports.xmlUCSIsKhmer)(e), _xmlUCSIsKhmerSymbols = Module._xmlUCSIsKhmerSymbols = (e) => (_xmlUCSIsKhmerSymbols = Module._xmlUCSIsKhmerSymbols = wasmExports.xmlUCSIsKhmerSymbols)(e), _xmlUCSIsLao = Module._xmlUCSIsLao = (e) => (_xmlUCSIsLao = Module._xmlUCSIsLao = wasmExports.xmlUCSIsLao)(e), _xmlUCSIsLatin1Supplement = Module._xmlUCSIsLatin1Supplement = (e) => (_xmlUCSIsLatin1Supplement = Module._xmlUCSIsLatin1Supplement = wasmExports.xmlUCSIsLatin1Supplement)(e), _xmlUCSIsLatinExtendedA = Module._xmlUCSIsLatinExtendedA = (e) => (_xmlUCSIsLatinExtendedA = Module._xmlUCSIsLatinExtendedA = wasmExports.xmlUCSIsLatinExtendedA)(e), _xmlUCSIsLatinExtendedB = Module._xmlUCSIsLatinExtendedB = (e) => (_xmlUCSIsLatinExtendedB = Module._xmlUCSIsLatinExtendedB = wasmExports.xmlUCSIsLatinExtendedB)(e), _xmlUCSIsLatinExtendedAdditional = Module._xmlUCSIsLatinExtendedAdditional = (e) => (_xmlUCSIsLatinExtendedAdditional = Module._xmlUCSIsLatinExtendedAdditional = wasmExports.xmlUCSIsLatinExtendedAdditional)(e), _xmlUCSIsLetterlikeSymbols = Module._xmlUCSIsLetterlikeSymbols = (e) => (_xmlUCSIsLetterlikeSymbols = Module._xmlUCSIsLetterlikeSymbols = wasmExports.xmlUCSIsLetterlikeSymbols)(e), _xmlUCSIsLimbu = Module._xmlUCSIsLimbu = (e) => (_xmlUCSIsLimbu = Module._xmlUCSIsLimbu = wasmExports.xmlUCSIsLimbu)(e), _xmlUCSIsLinearBIdeograms = Module._xmlUCSIsLinearBIdeograms = (e) => (_xmlUCSIsLinearBIdeograms = Module._xmlUCSIsLinearBIdeograms = wasmExports.xmlUCSIsLinearBIdeograms)(e), _xmlUCSIsLinearBSyllabary = Module._xmlUCSIsLinearBSyllabary = (e) => (_xmlUCSIsLinearBSyllabary = Module._xmlUCSIsLinearBSyllabary = wasmExports.xmlUCSIsLinearBSyllabary)(e), _xmlUCSIsLowSurrogates = Module._xmlUCSIsLowSurrogates = (e) => (_xmlUCSIsLowSurrogates = Module._xmlUCSIsLowSurrogates = wasmExports.xmlUCSIsLowSurrogates)(e), _xmlUCSIsMalayalam = Module._xmlUCSIsMalayalam = (e) => (_xmlUCSIsMalayalam = Module._xmlUCSIsMalayalam = wasmExports.xmlUCSIsMalayalam)(e), _xmlUCSIsMathematicalAlphanumericSymbols = Module._xmlUCSIsMathematicalAlphanumericSymbols = (e) => (_xmlUCSIsMathematicalAlphanumericSymbols = Module._xmlUCSIsMathematicalAlphanumericSymbols = wasmExports.xmlUCSIsMathematicalAlphanumericSymbols)(e), _xmlUCSIsMathematicalOperators = Module._xmlUCSIsMathematicalOperators = (e) => (_xmlUCSIsMathematicalOperators = Module._xmlUCSIsMathematicalOperators = wasmExports.xmlUCSIsMathematicalOperators)(e), _xmlUCSIsMiscellaneousMathematicalSymbolsA = Module._xmlUCSIsMiscellaneousMathematicalSymbolsA = (e) => (_xmlUCSIsMiscellaneousMathematicalSymbolsA = Module._xmlUCSIsMiscellaneousMathematicalSymbolsA = wasmExports.xmlUCSIsMiscellaneousMathematicalSymbolsA)(e), _xmlUCSIsMiscellaneousMathematicalSymbolsB = Module._xmlUCSIsMiscellaneousMathematicalSymbolsB = (e) => (_xmlUCSIsMiscellaneousMathematicalSymbolsB = Module._xmlUCSIsMiscellaneousMathematicalSymbolsB = wasmExports.xmlUCSIsMiscellaneousMathematicalSymbolsB)(e), _xmlUCSIsMiscellaneousSymbols = Module._xmlUCSIsMiscellaneousSymbols = (e) => (_xmlUCSIsMiscellaneousSymbols = Module._xmlUCSIsMiscellaneousSymbols = wasmExports.xmlUCSIsMiscellaneousSymbols)(e), _xmlUCSIsMiscellaneousSymbolsandArrows = Module._xmlUCSIsMiscellaneousSymbolsandArrows = (e) => (_xmlUCSIsMiscellaneousSymbolsandArrows = Module._xmlUCSIsMiscellaneousSymbolsandArrows = wasmExports.xmlUCSIsMiscellaneousSymbolsandArrows)(e), _xmlUCSIsMiscellaneousTechnical = Module._xmlUCSIsMiscellaneousTechnical = (e) => (_xmlUCSIsMiscellaneousTechnical = Module._xmlUCSIsMiscellaneousTechnical = wasmExports.xmlUCSIsMiscellaneousTechnical)(e), _xmlUCSIsMongolian = Module._xmlUCSIsMongolian = (e) => (_xmlUCSIsMongolian = Module._xmlUCSIsMongolian = wasmExports.xmlUCSIsMongolian)(e), _xmlUCSIsMusicalSymbols = Module._xmlUCSIsMusicalSymbols = (e) => (_xmlUCSIsMusicalSymbols = Module._xmlUCSIsMusicalSymbols = wasmExports.xmlUCSIsMusicalSymbols)(e), _xmlUCSIsMyanmar = Module._xmlUCSIsMyanmar = (e) => (_xmlUCSIsMyanmar = Module._xmlUCSIsMyanmar = wasmExports.xmlUCSIsMyanmar)(e), _xmlUCSIsNumberForms = Module._xmlUCSIsNumberForms = (e) => (_xmlUCSIsNumberForms = Module._xmlUCSIsNumberForms = wasmExports.xmlUCSIsNumberForms)(e), _xmlUCSIsOgham = Module._xmlUCSIsOgham = (e) => (_xmlUCSIsOgham = Module._xmlUCSIsOgham = wasmExports.xmlUCSIsOgham)(e), _xmlUCSIsOldItalic = Module._xmlUCSIsOldItalic = (e) => (_xmlUCSIsOldItalic = Module._xmlUCSIsOldItalic = wasmExports.xmlUCSIsOldItalic)(e), _xmlUCSIsOpticalCharacterRecognition = Module._xmlUCSIsOpticalCharacterRecognition = (e) => (_xmlUCSIsOpticalCharacterRecognition = Module._xmlUCSIsOpticalCharacterRecognition = wasmExports.xmlUCSIsOpticalCharacterRecognition)(e), _xmlUCSIsOriya = Module._xmlUCSIsOriya = (e) => (_xmlUCSIsOriya = Module._xmlUCSIsOriya = wasmExports.xmlUCSIsOriya)(e), _xmlUCSIsOsmanya = Module._xmlUCSIsOsmanya = (e) => (_xmlUCSIsOsmanya = Module._xmlUCSIsOsmanya = wasmExports.xmlUCSIsOsmanya)(e), _xmlUCSIsPhoneticExtensions = Module._xmlUCSIsPhoneticExtensions = (e) => (_xmlUCSIsPhoneticExtensions = Module._xmlUCSIsPhoneticExtensions = wasmExports.xmlUCSIsPhoneticExtensions)(e), _xmlUCSIsPrivateUse = Module._xmlUCSIsPrivateUse = (e) => (_xmlUCSIsPrivateUse = Module._xmlUCSIsPrivateUse = wasmExports.xmlUCSIsPrivateUse)(e), _xmlUCSIsPrivateUseArea = Module._xmlUCSIsPrivateUseArea = (e) => (_xmlUCSIsPrivateUseArea = Module._xmlUCSIsPrivateUseArea = wasmExports.xmlUCSIsPrivateUseArea)(e), _xmlUCSIsRunic = Module._xmlUCSIsRunic = (e) => (_xmlUCSIsRunic = Module._xmlUCSIsRunic = wasmExports.xmlUCSIsRunic)(e), _xmlUCSIsShavian = Module._xmlUCSIsShavian = (e) => (_xmlUCSIsShavian = Module._xmlUCSIsShavian = wasmExports.xmlUCSIsShavian)(e), _xmlUCSIsSinhala = Module._xmlUCSIsSinhala = (e) => (_xmlUCSIsSinhala = Module._xmlUCSIsSinhala = wasmExports.xmlUCSIsSinhala)(e), _xmlUCSIsSmallFormVariants = Module._xmlUCSIsSmallFormVariants = (e) => (_xmlUCSIsSmallFormVariants = Module._xmlUCSIsSmallFormVariants = wasmExports.xmlUCSIsSmallFormVariants)(e), _xmlUCSIsSpacingModifierLetters = Module._xmlUCSIsSpacingModifierLetters = (e) => (_xmlUCSIsSpacingModifierLetters = Module._xmlUCSIsSpacingModifierLetters = wasmExports.xmlUCSIsSpacingModifierLetters)(e), _xmlUCSIsSpecials = Module._xmlUCSIsSpecials = (e) => (_xmlUCSIsSpecials = Module._xmlUCSIsSpecials = wasmExports.xmlUCSIsSpecials)(e), _xmlUCSIsSuperscriptsandSubscripts = Module._xmlUCSIsSuperscriptsandSubscripts = (e) => (_xmlUCSIsSuperscriptsandSubscripts = Module._xmlUCSIsSuperscriptsandSubscripts = wasmExports.xmlUCSIsSuperscriptsandSubscripts)(e), _xmlUCSIsSupplementalArrowsA = Module._xmlUCSIsSupplementalArrowsA = (e) => (_xmlUCSIsSupplementalArrowsA = Module._xmlUCSIsSupplementalArrowsA = wasmExports.xmlUCSIsSupplementalArrowsA)(e), _xmlUCSIsSupplementalArrowsB = Module._xmlUCSIsSupplementalArrowsB = (e) => (_xmlUCSIsSupplementalArrowsB = Module._xmlUCSIsSupplementalArrowsB = wasmExports.xmlUCSIsSupplementalArrowsB)(e), _xmlUCSIsSupplementalMathematicalOperators = Module._xmlUCSIsSupplementalMathematicalOperators = (e) => (_xmlUCSIsSupplementalMathematicalOperators = Module._xmlUCSIsSupplementalMathematicalOperators = wasmExports.xmlUCSIsSupplementalMathematicalOperators)(e), _xmlUCSIsSupplementaryPrivateUseAreaA = Module._xmlUCSIsSupplementaryPrivateUseAreaA = (e) => (_xmlUCSIsSupplementaryPrivateUseAreaA = Module._xmlUCSIsSupplementaryPrivateUseAreaA = wasmExports.xmlUCSIsSupplementaryPrivateUseAreaA)(e), _xmlUCSIsSupplementaryPrivateUseAreaB = Module._xmlUCSIsSupplementaryPrivateUseAreaB = (e) => (_xmlUCSIsSupplementaryPrivateUseAreaB = Module._xmlUCSIsSupplementaryPrivateUseAreaB = wasmExports.xmlUCSIsSupplementaryPrivateUseAreaB)(e), _xmlUCSIsSyriac = Module._xmlUCSIsSyriac = (e) => (_xmlUCSIsSyriac = Module._xmlUCSIsSyriac = wasmExports.xmlUCSIsSyriac)(e), _xmlUCSIsTagalog = Module._xmlUCSIsTagalog = (e) => (_xmlUCSIsTagalog = Module._xmlUCSIsTagalog = wasmExports.xmlUCSIsTagalog)(e), _xmlUCSIsTagbanwa = Module._xmlUCSIsTagbanwa = (e) => (_xmlUCSIsTagbanwa = Module._xmlUCSIsTagbanwa = wasmExports.xmlUCSIsTagbanwa)(e), _xmlUCSIsTags = Module._xmlUCSIsTags = (e) => (_xmlUCSIsTags = Module._xmlUCSIsTags = wasmExports.xmlUCSIsTags)(e), _xmlUCSIsTaiLe = Module._xmlUCSIsTaiLe = (e) => (_xmlUCSIsTaiLe = Module._xmlUCSIsTaiLe = wasmExports.xmlUCSIsTaiLe)(e), _xmlUCSIsTaiXuanJingSymbols = Module._xmlUCSIsTaiXuanJingSymbols = (e) => (_xmlUCSIsTaiXuanJingSymbols = Module._xmlUCSIsTaiXuanJingSymbols = wasmExports.xmlUCSIsTaiXuanJingSymbols)(e), _xmlUCSIsTamil = Module._xmlUCSIsTamil = (e) => (_xmlUCSIsTamil = Module._xmlUCSIsTamil = wasmExports.xmlUCSIsTamil)(e), _xmlUCSIsTelugu = Module._xmlUCSIsTelugu = (e) => (_xmlUCSIsTelugu = Module._xmlUCSIsTelugu = wasmExports.xmlUCSIsTelugu)(e), _xmlUCSIsThaana = Module._xmlUCSIsThaana = (e) => (_xmlUCSIsThaana = Module._xmlUCSIsThaana = wasmExports.xmlUCSIsThaana)(e), _xmlUCSIsThai = Module._xmlUCSIsThai = (e) => (_xmlUCSIsThai = Module._xmlUCSIsThai = wasmExports.xmlUCSIsThai)(e), _xmlUCSIsTibetan = Module._xmlUCSIsTibetan = (e) => (_xmlUCSIsTibetan = Module._xmlUCSIsTibetan = wasmExports.xmlUCSIsTibetan)(e), _xmlUCSIsUgaritic = Module._xmlUCSIsUgaritic = (e) => (_xmlUCSIsUgaritic = Module._xmlUCSIsUgaritic = wasmExports.xmlUCSIsUgaritic)(e), _xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module._xmlUCSIsUnifiedCanadianAboriginalSyllabics = (e) => (_xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module._xmlUCSIsUnifiedCanadianAboriginalSyllabics = wasmExports.xmlUCSIsUnifiedCanadianAboriginalSyllabics)(e), _xmlUCSIsVariationSelectors = Module._xmlUCSIsVariationSelectors = (e) => (_xmlUCSIsVariationSelectors = Module._xmlUCSIsVariationSelectors = wasmExports.xmlUCSIsVariationSelectors)(e), _xmlUCSIsVariationSelectorsSupplement = Module._xmlUCSIsVariationSelectorsSupplement = (e) => (_xmlUCSIsVariationSelectorsSupplement = Module._xmlUCSIsVariationSelectorsSupplement = wasmExports.xmlUCSIsVariationSelectorsSupplement)(e), _xmlUCSIsYiRadicals = Module._xmlUCSIsYiRadicals = (e) => (_xmlUCSIsYiRadicals = Module._xmlUCSIsYiRadicals = wasmExports.xmlUCSIsYiRadicals)(e), _xmlUCSIsYiSyllables = Module._xmlUCSIsYiSyllables = (e) => (_xmlUCSIsYiSyllables = Module._xmlUCSIsYiSyllables = wasmExports.xmlUCSIsYiSyllables)(e), _xmlUCSIsYijingHexagramSymbols = Module._xmlUCSIsYijingHexagramSymbols = (e) => (_xmlUCSIsYijingHexagramSymbols = Module._xmlUCSIsYijingHexagramSymbols = wasmExports.xmlUCSIsYijingHexagramSymbols)(e), _xmlUCSIsCatCs = Module._xmlUCSIsCatCs = (e) => (_xmlUCSIsCatCs = Module._xmlUCSIsCatCs = wasmExports.xmlUCSIsCatCs)(e), ___small_fprintf = Module.___small_fprintf = (e, t, r2) => (___small_fprintf = Module.___small_fprintf = wasmExports.__small_fprintf)(e, t, r2), _xmlXPathBooleanFunction = Module._xmlXPathBooleanFunction = (e, t) => (_xmlXPathBooleanFunction = Module._xmlXPathBooleanFunction = wasmExports.xmlXPathBooleanFunction)(e, t), _xmlXPathCeilingFunction = Module._xmlXPathCeilingFunction = (e, t) => (_xmlXPathCeilingFunction = Module._xmlXPathCeilingFunction = wasmExports.xmlXPathCeilingFunction)(e, t), _xmlXPathCountFunction = Module._xmlXPathCountFunction = (e, t) => (_xmlXPathCountFunction = Module._xmlXPathCountFunction = wasmExports.xmlXPathCountFunction)(e, t), _xmlXPathConcatFunction = Module._xmlXPathConcatFunction = (e, t) => (_xmlXPathConcatFunction = Module._xmlXPathConcatFunction = wasmExports.xmlXPathConcatFunction)(e, t), _xmlXPathContainsFunction = Module._xmlXPathContainsFunction = (e, t) => (_xmlXPathContainsFunction = Module._xmlXPathContainsFunction = wasmExports.xmlXPathContainsFunction)(e, t), _xmlXPathIdFunction = Module._xmlXPathIdFunction = (e, t) => (_xmlXPathIdFunction = Module._xmlXPathIdFunction = wasmExports.xmlXPathIdFunction)(e, t), _xmlXPathFalseFunction = Module._xmlXPathFalseFunction = (e, t) => (_xmlXPathFalseFunction = Module._xmlXPathFalseFunction = wasmExports.xmlXPathFalseFunction)(e, t), _xmlXPathFloorFunction = Module._xmlXPathFloorFunction = (e, t) => (_xmlXPathFloorFunction = Module._xmlXPathFloorFunction = wasmExports.xmlXPathFloorFunction)(e, t), _xmlXPathLastFunction = Module._xmlXPathLastFunction = (e, t) => (_xmlXPathLastFunction = Module._xmlXPathLastFunction = wasmExports.xmlXPathLastFunction)(e, t), _xmlXPathLangFunction = Module._xmlXPathLangFunction = (e, t) => (_xmlXPathLangFunction = Module._xmlXPathLangFunction = wasmExports.xmlXPathLangFunction)(e, t), _xmlXPathLocalNameFunction = Module._xmlXPathLocalNameFunction = (e, t) => (_xmlXPathLocalNameFunction = Module._xmlXPathLocalNameFunction = wasmExports.xmlXPathLocalNameFunction)(e, t), _xmlXPathNotFunction = Module._xmlXPathNotFunction = (e, t) => (_xmlXPathNotFunction = Module._xmlXPathNotFunction = wasmExports.xmlXPathNotFunction)(e, t), _xmlXPathNamespaceURIFunction = Module._xmlXPathNamespaceURIFunction = (e, t) => (_xmlXPathNamespaceURIFunction = Module._xmlXPathNamespaceURIFunction = wasmExports.xmlXPathNamespaceURIFunction)(e, t), _xmlXPathNormalizeFunction = Module._xmlXPathNormalizeFunction = (e, t) => (_xmlXPathNormalizeFunction = Module._xmlXPathNormalizeFunction = wasmExports.xmlXPathNormalizeFunction)(e, t), _xmlXPathNumberFunction = Module._xmlXPathNumberFunction = (e, t) => (_xmlXPathNumberFunction = Module._xmlXPathNumberFunction = wasmExports.xmlXPathNumberFunction)(e, t), _xmlXPathPositionFunction = Module._xmlXPathPositionFunction = (e, t) => (_xmlXPathPositionFunction = Module._xmlXPathPositionFunction = wasmExports.xmlXPathPositionFunction)(e, t), _xmlXPathRoundFunction = Module._xmlXPathRoundFunction = (e, t) => (_xmlXPathRoundFunction = Module._xmlXPathRoundFunction = wasmExports.xmlXPathRoundFunction)(e, t), _xmlXPathStringFunction = Module._xmlXPathStringFunction = (e, t) => (_xmlXPathStringFunction = Module._xmlXPathStringFunction = wasmExports.xmlXPathStringFunction)(e, t), _xmlXPathStringLengthFunction = Module._xmlXPathStringLengthFunction = (e, t) => (_xmlXPathStringLengthFunction = Module._xmlXPathStringLengthFunction = wasmExports.xmlXPathStringLengthFunction)(e, t), _xmlXPathStartsWithFunction = Module._xmlXPathStartsWithFunction = (e, t) => (_xmlXPathStartsWithFunction = Module._xmlXPathStartsWithFunction = wasmExports.xmlXPathStartsWithFunction)(e, t), _xmlXPathSubstringFunction = Module._xmlXPathSubstringFunction = (e, t) => (_xmlXPathSubstringFunction = Module._xmlXPathSubstringFunction = wasmExports.xmlXPathSubstringFunction)(e, t), _xmlXPathSubstringBeforeFunction = Module._xmlXPathSubstringBeforeFunction = (e, t) => (_xmlXPathSubstringBeforeFunction = Module._xmlXPathSubstringBeforeFunction = wasmExports.xmlXPathSubstringBeforeFunction)(e, t), _xmlXPathSubstringAfterFunction = Module._xmlXPathSubstringAfterFunction = (e, t) => (_xmlXPathSubstringAfterFunction = Module._xmlXPathSubstringAfterFunction = wasmExports.xmlXPathSubstringAfterFunction)(e, t), _xmlXPathSumFunction = Module._xmlXPathSumFunction = (e, t) => (_xmlXPathSumFunction = Module._xmlXPathSumFunction = wasmExports.xmlXPathSumFunction)(e, t), _xmlXPathTrueFunction = Module._xmlXPathTrueFunction = (e, t) => (_xmlXPathTrueFunction = Module._xmlXPathTrueFunction = wasmExports.xmlXPathTrueFunction)(e, t), _xmlXPathTranslateFunction = Module._xmlXPathTranslateFunction = (e, t) => (_xmlXPathTranslateFunction = Module._xmlXPathTranslateFunction = wasmExports.xmlXPathTranslateFunction)(e, t), _xmlXPathNextSelf = Module._xmlXPathNextSelf = (e, t) => (_xmlXPathNextSelf = Module._xmlXPathNextSelf = wasmExports.xmlXPathNextSelf)(e, t), _xmlXPathNextChild = Module._xmlXPathNextChild = (e, t) => (_xmlXPathNextChild = Module._xmlXPathNextChild = wasmExports.xmlXPathNextChild)(e, t), _xmlXPathNextDescendant = Module._xmlXPathNextDescendant = (e, t) => (_xmlXPathNextDescendant = Module._xmlXPathNextDescendant = wasmExports.xmlXPathNextDescendant)(e, t), _xmlXPathNextDescendantOrSelf = Module._xmlXPathNextDescendantOrSelf = (e, t) => (_xmlXPathNextDescendantOrSelf = Module._xmlXPathNextDescendantOrSelf = wasmExports.xmlXPathNextDescendantOrSelf)(e, t), _xmlXPathNextParent = Module._xmlXPathNextParent = (e, t) => (_xmlXPathNextParent = Module._xmlXPathNextParent = wasmExports.xmlXPathNextParent)(e, t), _xmlXPathNextAncestor = Module._xmlXPathNextAncestor = (e, t) => (_xmlXPathNextAncestor = Module._xmlXPathNextAncestor = wasmExports.xmlXPathNextAncestor)(e, t), _xmlXPathNextAncestorOrSelf = Module._xmlXPathNextAncestorOrSelf = (e, t) => (_xmlXPathNextAncestorOrSelf = Module._xmlXPathNextAncestorOrSelf = wasmExports.xmlXPathNextAncestorOrSelf)(e, t), _xmlXPathNextFollowingSibling = Module._xmlXPathNextFollowingSibling = (e, t) => (_xmlXPathNextFollowingSibling = Module._xmlXPathNextFollowingSibling = wasmExports.xmlXPathNextFollowingSibling)(e, t), _xmlXPathNextPrecedingSibling = Module._xmlXPathNextPrecedingSibling = (e, t) => (_xmlXPathNextPrecedingSibling = Module._xmlXPathNextPrecedingSibling = wasmExports.xmlXPathNextPrecedingSibling)(e, t), _xmlXPathNextFollowing = Module._xmlXPathNextFollowing = (e, t) => (_xmlXPathNextFollowing = Module._xmlXPathNextFollowing = wasmExports.xmlXPathNextFollowing)(e, t), _xmlXPathNextNamespace = Module._xmlXPathNextNamespace = (e, t) => (_xmlXPathNextNamespace = Module._xmlXPathNextNamespace = wasmExports.xmlXPathNextNamespace)(e, t), _xmlXPathNextAttribute = Module._xmlXPathNextAttribute = (e, t) => (_xmlXPathNextAttribute = Module._xmlXPathNextAttribute = wasmExports.xmlXPathNextAttribute)(e, t), _zcalloc = Module._zcalloc = (e, t, r2) => (_zcalloc = Module._zcalloc = wasmExports.zcalloc)(e, t, r2), _zcfree = Module._zcfree = (e, t) => (_zcfree = Module._zcfree = wasmExports.zcfree)(e, t), _memset = Module._memset = (e, t, r2) => (_memset = Module._memset = wasmExports.memset)(e, t, r2), _strerror = Module._strerror = (e) => (_strerror = Module._strerror = wasmExports.strerror)(e), _memmove = Module._memmove = (e, t, r2) => (_memmove = Module._memmove = wasmExports.memmove)(e, t, r2), ___multf3 = Module.___multf3 = (e, t, r2, a2, o3) => (___multf3 = Module.___multf3 = wasmExports.__multf3)(e, t, r2, a2, o3), ___subtf3 = Module.___subtf3 = (e, t, r2, a2, o3) => (___subtf3 = Module.___subtf3 = wasmExports.__subtf3)(e, t, r2, a2, o3), ___lttf2 = Module.___lttf2 = (e, t, r2, a2) => (___lttf2 = Module.___lttf2 = wasmExports.__lttf2)(e, t, r2, a2), ___fixtfsi = Module.___fixtfsi = (e, t) => (___fixtfsi = Module.___fixtfsi = wasmExports.__fixtfsi)(e, t), ___floatsitf = Module.___floatsitf = (e, t) => (___floatsitf = Module.___floatsitf = wasmExports.__floatsitf)(e, t), ___extenddftf2 = Module.___extenddftf2 = (e, t) => (___extenddftf2 = Module.___extenddftf2 = wasmExports.__extenddftf2)(e, t), ___getf2 = Module.___getf2 = (e, t, r2, a2) => (___getf2 = Module.___getf2 = wasmExports.__getf2)(e, t, r2, a2), _pthread_mutex_lock = Module._pthread_mutex_lock = (e) => (_pthread_mutex_lock = Module._pthread_mutex_lock = wasmExports.pthread_mutex_lock)(e), _pthread_mutex_unlock = Module._pthread_mutex_unlock = (e) => (_pthread_mutex_unlock = Module._pthread_mutex_unlock = wasmExports.pthread_mutex_unlock)(e), ___dl_seterr = (e, t) => (___dl_seterr = wasmExports.__dl_seterr)(e, t), _emscripten_builtin_memalign = (e, t) => (_emscripten_builtin_memalign = wasmExports.emscripten_builtin_memalign)(e, t), _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports.emscripten_stack_get_current)(), _putc = Module._putc = (e, t) => (_putc = Module._putc = wasmExports.putc)(e, t), ___letf2 = Module.___letf2 = (e, t, r2, a2) => (___letf2 = Module.___letf2 = wasmExports.__letf2)(e, t, r2, a2), _pthread_sigmask = Module._pthread_sigmask = (e, t, r2) => (_pthread_sigmask = Module._pthread_sigmask = wasmExports.pthread_sigmask)(e, t, r2), _htons = (e) => (_htons = wasmExports.htons)(e), _ntohs = (e) => (_ntohs = wasmExports.ntohs)(e), _gmtime = Module._gmtime = (e) => (_gmtime = Module._gmtime = wasmExports.gmtime)(e), _htonl = (e) => (_htonl = wasmExports.htonl)(e), _ioctl = Module._ioctl = (e, t, r2) => (_ioctl = Module._ioctl = wasmExports.ioctl)(e, t, r2), _sigismember = Module._sigismember = (e, t) => (_sigismember = Module._sigismember = wasmExports.sigismember)(e, t), _sigpending = Module._sigpending = (e) => (_sigpending = Module._sigpending = wasmExports.sigpending)(e), _srand = Module._srand = (e) => (_srand = Module._srand = wasmExports.srand)(e), _rand = Module._rand = () => (_rand = Module._rand = wasmExports.rand)(), __emscripten_timeout = (e, t) => (__emscripten_timeout = wasmExports._emscripten_timeout)(e, t), _sigwait = Module._sigwait = (e, t) => (_sigwait = Module._sigwait = wasmExports.sigwait)(e, t), _strncat = Module._strncat = (e, t, r2) => (_strncat = Module._strncat = wasmExports.strncat)(e, t, r2), _setThrew = (e, t) => (_setThrew = wasmExports.setThrew)(e, t), __emscripten_tempret_set = (e) => (__emscripten_tempret_set = wasmExports._emscripten_tempret_set)(e), __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports._emscripten_tempret_get)(), __emscripten_stack_restore = (e) => (__emscripten_stack_restore = wasmExports._emscripten_stack_restore)(e), __emscripten_stack_alloc = (e) => (__emscripten_stack_alloc = wasmExports._emscripten_stack_alloc)(e), _getsockname = Module._getsockname = (e, t, r2) => (_getsockname = Module._getsockname = wasmExports.getsockname)(e, t, r2), ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports.__wasm_apply_data_relocs)(), _stderr = Module._stderr = 15157024, _InterruptPending = Module._InterruptPending = 15301456, _MyLatch = Module._MyLatch = 15301644, _CritSectionCount = Module._CritSectionCount = 15301508, _MyProc = Module._MyProc = 15271260, _pg_global_prng_state = Module._pg_global_prng_state = 15247840, _error_context_stack = Module._error_context_stack = 15299752, _GUC_check_errdetail_string = Module._GUC_check_errdetail_string = 15305404, _IsUnderPostmaster = Module._IsUnderPostmaster = 15301537, _CurrentMemoryContext = Module._CurrentMemoryContext = 15306832, _stdout = Module._stdout = 15157328, _debug_query_string = Module._debug_query_string = 15162268, _MyProcPort = Module._MyProcPort = 15301632, ___THREW__ = Module.___THREW__ = 15325956, ___threwValue = Module.___threwValue = 15325960, _MyDatabaseId = Module._MyDatabaseId = 15301516, _TopMemoryContext = Module._TopMemoryContext = 15306836, _PG_exception_stack = Module._PG_exception_stack = 15299756, _MyProcPid = Module._MyProcPid = 15301608, _stdin = Module._stdin = 15157176, _ScanKeywords = Module._ScanKeywords = 14989880, _pg_number_of_ones = Module._pg_number_of_ones = 13556160, _LocalBufferBlockPointers = Module._LocalBufferBlockPointers = 15267836, _BufferBlocks = Module._BufferBlocks = 15262572, _wal_level = Module._wal_level = 15003760, _SnapshotAnyData = Module._SnapshotAnyData = 15089936, _maintenance_work_mem = Module._maintenance_work_mem = 15037416, _ParallelWorkerNumber = Module._ParallelWorkerNumber = 14995320, _MainLWLockArray = Module._MainLWLockArray = 15269444, _CurrentResourceOwner = Module._CurrentResourceOwner = 15306880, _work_mem = Module._work_mem = 15037400, _NBuffers = Module._NBuffers = 15037424, _bsysscan = Module._bsysscan = 15249076, _CheckXidAlive = Module._CheckXidAlive = 15249072, _RecentXmin = Module._RecentXmin = 15090028, _TTSOpsHeapTuple = Module._TTSOpsHeapTuple = 15007500, _XactIsoLevel = Module._XactIsoLevel = 15003624, _pgWalUsage = Module._pgWalUsage = 15252544, _pgBufferUsage = Module._pgBufferUsage = 15252416, _TTSOpsVirtual = Module._TTSOpsVirtual = 15007448, _TransamVariables = Module._TransamVariables = 15249064, _TopTransactionContext = Module._TopTransactionContext = 15306856, _RmgrTable = Module._RmgrTable = 14995344, _process_shared_preload_libraries_in_progress = Module._process_shared_preload_libraries_in_progress = 15304800, _wal_segment_size = Module._wal_segment_size = 15003780, _TopTransactionResourceOwner = Module._TopTransactionResourceOwner = 15306888, _arch_module_check_errdetail_string = Module._arch_module_check_errdetail_string = 15261956, _object_access_hook = Module._object_access_hook = 15251184, _InvalidObjectAddress = Module._InvalidObjectAddress = 14151628, _check_function_bodies = Module._check_function_bodies = 15037590, _post_parse_analyze_hook = Module._post_parse_analyze_hook = 15251224, _ScanKeywordTokens = Module._ScanKeywordTokens = 14182928, _SPI_processed = Module._SPI_processed = 15252568, _SPI_tuptable = Module._SPI_tuptable = 15252576, _CacheMemoryContext = Module._CacheMemoryContext = 15306848, _WalReceiverFunctions = Module._WalReceiverFunctions = 15262348, _TTSOpsMinimalTuple = Module._TTSOpsMinimalTuple = 15007552, _check_password_hook = Module._check_password_hook = 15251492, _ConfigReloadPending = Module._ConfigReloadPending = 15261944, _max_parallel_maintenance_workers = Module._max_parallel_maintenance_workers = 15037420, _DateStyle = Module._DateStyle = 15037388, _ExecutorStart_hook = Module._ExecutorStart_hook = 15252392, _ExecutorRun_hook = Module._ExecutorRun_hook = 15252396, _ExecutorFinish_hook = Module._ExecutorFinish_hook = 15252400, _ExecutorEnd_hook = Module._ExecutorEnd_hook = 15252404, _SPI_result = Module._SPI_result = 15252580, _ClientAuthentication_hook = Module._ClientAuthentication_hook = 15252752, _cpu_tuple_cost = Module._cpu_tuple_cost = 15008008, _cpu_operator_cost = Module._cpu_operator_cost = 15008024, _seq_page_cost = Module._seq_page_cost = 15007992, _planner_hook = Module._planner_hook = 15261640, _ShutdownRequestPending = Module._ShutdownRequestPending = 15261948, _MyStartTime = Module._MyStartTime = 15301616, _cluster_name = Module._cluster_name = 15037640, _application_name = Module._application_name = 15305628, _BufferDescriptors = Module._BufferDescriptors = 15262568, _shmem_startup_hook = Module._shmem_startup_hook = 15268516, _ProcessUtility_hook = Module._ProcessUtility_hook = 15271348, _IntervalStyle = Module._IntervalStyle = 15301540, _extra_float_digits = Module._extra_float_digits = 15027816, _pg_crc32_table = Module._pg_crc32_table = 14743360, _xmlFree = Module._xmlFree = 15139240, _xmlStructuredError = Module._xmlStructuredError = 15308404, _xmlStructuredErrorContext = Module._xmlStructuredErrorContext = 15308412, _xmlGenericErrorContext = Module._xmlGenericErrorContext = 15308408, _xmlGenericError = Module._xmlGenericError = 15139276, _xmlIsBaseCharGroup = Module._xmlIsBaseCharGroup = 15138640, _xmlIsDigitGroup = Module._xmlIsDigitGroup = 15138672, _xmlIsCombiningGroup = Module._xmlIsCombiningGroup = 15138656, _xmlIsExtenderGroup = Module._xmlIsExtenderGroup = 15138688, _ErrorContext = Module._ErrorContext = 15306840, _shmem_request_hook = Module._shmem_request_hook = 15304804, _xmlIsPubidChar_tab = Module._xmlIsPubidChar_tab = 14784656, _xmlMalloc = Module._xmlMalloc = 15139244, _xmlRealloc = Module._xmlRealloc = 15139252, _xmlGetWarningsDefaultValue = Module._xmlGetWarningsDefaultValue = 15139268, _xmlLastError = Module._xmlLastError = 15308424, _xmlMallocAtomic = Module._xmlMallocAtomic = 15139248, _xmlMemStrdup = Module._xmlMemStrdup = 15139256, _xmlBufferAllocScheme = Module._xmlBufferAllocScheme = 15139260, _xmlDefaultBufferSize = Module._xmlDefaultBufferSize = 15139264, _xmlParserDebugEntities = Module._xmlParserDebugEntities = 15308364, _xmlDoValidityCheckingDefaultValue = Module._xmlDoValidityCheckingDefaultValue = 15308368, _xmlLoadExtDtdDefaultValue = Module._xmlLoadExtDtdDefaultValue = 15308372, _xmlPedanticParserDefaultValue = Module._xmlPedanticParserDefaultValue = 15308376, _xmlLineNumbersDefaultValue = Module._xmlLineNumbersDefaultValue = 15308380, _xmlKeepBlanksDefaultValue = Module._xmlKeepBlanksDefaultValue = 15139272, _xmlSubstituteEntitiesDefaultValue = Module._xmlSubstituteEntitiesDefaultValue = 15308384, _xmlRegisterNodeDefaultValue = Module._xmlRegisterNodeDefaultValue = 15308388, _xmlDeregisterNodeDefaultValue = Module._xmlDeregisterNodeDefaultValue = 15308392, _xmlParserInputBufferCreateFilenameValue = Module._xmlParserInputBufferCreateFilenameValue = 15308396, _xmlOutputBufferCreateFilenameValue = Module._xmlOutputBufferCreateFilenameValue = 15308400, _xmlIndentTreeOutput = Module._xmlIndentTreeOutput = 15139280, _xmlTreeIndentString = Module._xmlTreeIndentString = 15139284, _xmlSaveNoEmptyTags = Module._xmlSaveNoEmptyTags = 15308416, _xmlDefaultSAXHandler = Module._xmlDefaultSAXHandler = 15139288, _xmlDefaultSAXLocator = Module._xmlDefaultSAXLocator = 15139400, _xmlParserMaxDepth = Module._xmlParserMaxDepth = 15139668, _xmlStringText = Module._xmlStringText = 14786464, _xmlStringComment = Module._xmlStringComment = 14786479, _xmlStringTextNoenc = Module._xmlStringTextNoenc = 14786469, _xmlXPathNAN = Module._xmlXPathNAN = 15309080, _xmlXPathNINF = Module._xmlXPathNINF = 15309096, _xmlXPathPINF = Module._xmlXPathPINF = 15309088, _z_errmsg = Module._z_errmsg = 15156224, __length_code = Module.__length_code = 14806128, __dist_code = Module.__dist_code = 14805616;
    function invoke_iii(e, t, r2) {
      var a2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_viiii(e, t, r2, a2, o3) {
      var s4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3);
      } catch (l4) {
        if (stackRestore(s4), l4 !== l4 + 0)
          throw l4;
        _setThrew(1, 0);
      }
    }
    function invoke_vi(e, t) {
      var r2 = stackSave();
      try {
        getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_v(e) {
      var t = stackSave();
      try {
        getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        _setThrew(1, 0);
      }
    }
    function invoke_j(e) {
      var t = stackSave();
      try {
        return getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_viiiiii(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        _setThrew(1, 0);
      }
    }
    function invoke_vii(e, t, r2) {
      var a2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiii(e, t, r2, a2, o3, s4) {
      var l4 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4);
      } catch (_3) {
        if (stackRestore(l4), _3 !== _3 + 0)
          throw _3;
        _setThrew(1, 0);
      }
    }
    function invoke_i(e) {
      var t = stackSave();
      try {
        return getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        _setThrew(1, 0);
      }
    }
    function invoke_ii(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_viii(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_iiii(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_vji(e, t, r2) {
      var a2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiii(e, t, r2, a2, o3) {
      var s4 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3);
      } catch (l4) {
        if (stackRestore(s4), l4 !== l4 + 0)
          throw l4;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiii(e, t, r2, a2, o3, s4, l4, _3) {
      var n3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3);
      } catch (m4) {
        if (stackRestore(n3), m4 !== m4 + 0)
          throw m4;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4) {
      var p3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4);
      } catch (d3) {
        if (stackRestore(p3), d3 !== d3 + 0)
          throw d3;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiii(e, t, r2, a2, o3, s4) {
      var l4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4);
      } catch (_3) {
        if (stackRestore(l4), _3 !== _3 + 0)
          throw _3;
        _setThrew(1, 0);
      }
    }
    function invoke_jii(e, t, r2) {
      var a2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_ji(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_jiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4) {
      var p3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4);
      } catch (d3) {
        if (stackRestore(p3), d3 !== d3 + 0)
          throw d3;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_jiiiiii(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_iiiiiiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5, u3) {
      var f3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5, u3);
      } catch (c2) {
        if (stackRestore(f3), c2 !== c2 + 0)
          throw c2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiijii(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        _setThrew(1, 0);
      }
    }
    function invoke_vijiji(e, t, r2, a2, o3, s4) {
      var l4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4);
      } catch (_3) {
        if (stackRestore(l4), _3 !== _3 + 0)
          throw _3;
        _setThrew(1, 0);
      }
    }
    function invoke_viji(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_iiji(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3) {
      var m4 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3);
      } catch (p3) {
        if (stackRestore(m4), p3 !== p3 + 0)
          throw p3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiiiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5, u3, f3, c2, w4, h3) {
      var v3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5, u3, f3, c2, w4, h3);
      } catch (x5) {
        if (stackRestore(v3), x5 !== x5 + 0)
          throw x5;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiij(e, t, r2, a2, o3) {
      var s4 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3);
      } catch (l4) {
        if (stackRestore(s4), l4 !== l4 + 0)
          throw l4;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiii(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        _setThrew(1, 0);
      }
    }
    function invoke_vj(e, t) {
      var r2 = stackSave();
      try {
        getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4) {
      var p3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4);
      } catch (d3) {
        if (stackRestore(p3), d3 !== d3 + 0)
          throw d3;
        _setThrew(1, 0);
      }
    }
    function invoke_viiji(e, t, r2, a2, o3) {
      var s4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3);
      } catch (l4) {
        if (stackRestore(s4), l4 !== l4 + 0)
          throw l4;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3) {
      var m4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3);
      } catch (p3) {
        if (stackRestore(m4), p3 !== p3 + 0)
          throw p3;
        _setThrew(1, 0);
      }
    }
    function invoke_vij(e, t, r2) {
      var a2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_ij(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiii(e, t, r2, a2, o3, s4, l4, _3) {
      var n3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3);
      } catch (m4) {
        if (stackRestore(n3), m4 !== m4 + 0)
          throw m4;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiji(e, t, r2, a2, o3, s4) {
      var l4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4);
      } catch (_3) {
        if (stackRestore(l4), _3 !== _3 + 0)
          throw _3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiij(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_vid(e, t, r2) {
      var a2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a2), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiiii(e, t, r2, a2, o3, s4, l4, _3) {
      var n3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3);
      } catch (m4) {
        if (stackRestore(n3), m4 !== m4 + 0)
          throw m4;
        _setThrew(1, 0);
      }
    }
    function invoke_viijii(e, t, r2, a2, o3, s4) {
      var l4 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4);
      } catch (_3) {
        if (stackRestore(l4), _3 !== _3 + 0)
          throw _3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiji(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        _setThrew(1, 0);
      }
    }
    function invoke_viijiiii(e, t, r2, a2, o3, s4, l4, _3) {
      var n3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3);
      } catch (m4) {
        if (stackRestore(n3), m4 !== m4 + 0)
          throw m4;
        _setThrew(1, 0);
      }
    }
    function invoke_viij(e, t, r2, a2) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2);
      } catch (s4) {
        if (stackRestore(o3), s4 !== s4 + 0)
          throw s4;
        _setThrew(1, 0);
      }
    }
    function invoke_jiiii(e, t, r2, a2, o3) {
      var s4 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3);
      } catch (l4) {
        if (stackRestore(s4), l4 !== l4 + 0)
          throw l4;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_viiiiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5) {
      var u3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4, p3, d3, g5);
      } catch (f3) {
        if (stackRestore(u3), f3 !== f3 + 0)
          throw f3;
        _setThrew(1, 0);
      }
    }
    function invoke_di(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_id(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a2) {
        if (stackRestore(r2), a2 !== a2 + 0)
          throw a2;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiii(e, t, r2, a2, o3, s4, l4) {
      var _3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4);
      } catch (n3) {
        if (stackRestore(_3), n3 !== n3 + 0)
          throw n3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiiii(e, t, r2, a2, o3, s4, l4, _3, n3, m4, p3) {
      var d3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a2, o3, s4, l4, _3, n3, m4, p3);
      } catch (g5) {
        if (stackRestore(d3), g5 !== g5 + 0)
          throw g5;
        _setThrew(1, 0);
      }
    }
    Module.addRunDependency = addRunDependency, Module.removeRunDependency = removeRunDependency, Module.setValue = setValue, Module.getValue = getValue, Module.UTF8ToString = UTF8ToString, Module.stringToNewUTF8 = stringToNewUTF8, Module.stringToUTF8OnStack = stringToUTF8OnStack, Module.FS_createPreloadedFile = FS_createPreloadedFile, Module.FS_unlink = FS_unlink, Module.FS_createPath = FS_createPath, Module.FS_createDevice = FS_createDevice, Module.FS = FS, Module.FS_createDataFile = FS_createDataFile, Module.FS_createLazyFile = FS_createLazyFile, Module.MEMFS = MEMFS, Module.IDBFS = IDBFS;
    var calledRun;
    dependenciesFulfilled = function e() {
      calledRun || run(), calledRun || (dependenciesFulfilled = e);
    };
    function callMain(e = []) {
      var t = resolveGlobalSymbol("main").sym;
      if (t) {
        e.unshift(thisProgram);
        var r2 = e.length, a2 = stackAlloc((r2 + 1) * 4), o3 = a2;
        e.forEach((l4) => {
          HEAPU32[o3 >> 2] = stringToUTF8OnStack(l4), o3 += 4;
        }), HEAPU32[o3 >> 2] = 0;
        try {
          var s4 = t(r2, a2);
          return exitJS(s4, true), s4;
        } catch (l4) {
          return handleException(l4);
        }
      }
    }
    function run(e = arguments_) {
      if (runDependencies > 0 || (preRun(), runDependencies > 0))
        return;
      function t() {
        calledRun || (calledRun = true, Module.calledRun = true, !ABORT && (initRuntime(), preMain(), readyPromiseResolve(Module), Module.onRuntimeInitialized?.(), shouldRunNow && callMain(e), postRun()));
      }
      Module.setStatus ? (Module.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => Module.setStatus(""), 1), t();
      }, 1)) : t();
    }
    if (Module.preInit)
      for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]);Module.preInit.length > 0; )
        Module.preInit.pop()();
    var shouldRunNow = true;
    return Module.noInitialRun && (shouldRunNow = false), run(), moduleRtn = readyPromise, moduleRtn;
  };
})();
var Ue2 = Ze2;
var Re2 = Ue2;
var J2;
var j3;
var V;
var Q2;
var $3;
var ie;
var me2;
var pe2;
var de2;
var Z2;
var ae;
var oe;
var se2;
var le2;
var K2;
var H4;
var A2;
var Y2;
var T3;
var De2;
var re2;
var ze2;
var Ne2;
var ue2 = class ue3 extends z2 {
  constructor(r2 = {}, a2 = {}) {
    super();
    R(this, T3);
    R(this, J2, false);
    R(this, j3, false);
    R(this, V, false);
    R(this, Q2, false);
    R(this, $3, false);
    R(this, ie, new X2);
    R(this, me2, new X2);
    R(this, pe2, new X2);
    R(this, de2, new X2);
    R(this, Z2, false);
    R(this, ae, "cma");
    this.debug = 0;
    R(this, oe);
    R(this, se2, []);
    R(this, le2, new ye);
    R(this, K2);
    R(this, H4);
    R(this, A2, new Map);
    R(this, Y2, new Set);
    typeof r2 == "string" ? a2 = { dataDir: r2, ...a2 } : a2 = r2, this.dataDir = a2.dataDir, a2.parsers !== undefined && (this.parsers = { ...this.parsers, ...a2.parsers }), a2.serializers !== undefined && (this.serializers = { ...this.serializers, ...a2.serializers }), a2?.debug !== undefined && (this.debug = a2.debug), a2?.relaxedDurability !== undefined && x(this, $3, a2.relaxedDurability), a2?.defaultDataTransferContainer !== undefined && x(this, ae, a2.defaultDataTransferContainer), x(this, oe, a2.extensions ?? {}), this.waitReady = T(this, T3, De2).call(this, a2 ?? {});
  }
  static async create(r2, a2) {
    let o3 = typeof r2 == "string" ? { dataDir: r2, ...a2 ?? {} } : r2 ?? {}, s4 = new ue3(o3);
    return await s4.waitReady, s4;
  }
  get Module() {
    return this.mod;
  }
  get ready() {
    return h(this, J2) && !h(this, j3) && !h(this, V);
  }
  get closed() {
    return h(this, V);
  }
  async close() {
    await this._checkReady(), x(this, j3, true);
    for (let r2 of h(this, se2))
      await r2();
    try {
      await this.execProtocol(O.end()), this.mod._pgl_shutdown();
    } catch (r2) {
      let a2 = r2;
      if (!(a2.name === "ExitStatus" && a2.status === 0))
        throw r2;
    }
    await this.fs.closeFs(), x(this, V, true), x(this, j3, false);
  }
  async[Symbol.asyncDispose]() {
    await this.close();
  }
  async _handleBlob(r2) {
    x(this, K2, r2 ? await r2.arrayBuffer() : undefined);
  }
  async _cleanupBlob() {
    x(this, K2, undefined);
  }
  async _getWrittenBlob() {
    if (!h(this, H4))
      return;
    let r2 = new Blob(h(this, H4));
    return x(this, H4, undefined), r2;
  }
  async _checkReady() {
    if (h(this, j3))
      throw new Error("PGlite is closing");
    if (h(this, V))
      throw new Error("PGlite is closed");
    h(this, J2) || await this.waitReady;
  }
  execProtocolRawSync(r2, a2 = {}) {
    let o3, s4 = this.mod;
    s4._use_wire(1);
    let l4 = r2.length, _3 = a2.dataTransferContainer ?? h(this, ae);
    switch (r2.length >= s4.FD_BUFFER_MAX && (_3 = "file"), _3) {
      case "cma": {
        s4._interactive_write(r2.length), s4.HEAPU8.set(r2, 1);
        break;
      }
      case "file": {
        let m4 = "/tmp/pglite/base/.s.PGSQL.5432.lck.in", p3 = "/tmp/pglite/base/.s.PGSQL.5432.in";
        s4._interactive_write(0), s4.FS.writeFile(m4, r2), s4.FS.rename(m4, p3);
        break;
      }
      default:
        throw new Error(`Unknown data transfer container: ${_3}`);
    }
    s4._interactive_one();
    let n3 = s4._get_channel();
    switch (n3 < 0 && (_3 = "file"), n3 > 0 && (_3 = "cma"), _3) {
      case "cma": {
        let m4 = l4 + 2, p3 = m4 + s4._interactive_read();
        o3 = s4.HEAPU8.subarray(m4, p3);
        break;
      }
      case "file": {
        let m4 = "/tmp/pglite/base/.s.PGSQL.5432.out";
        try {
          let p3 = s4.FS.stat(m4), d3 = s4.FS.open(m4, "r");
          o3 = new Uint8Array(p3.size), s4.FS.read(d3, o3, 0, p3.size, 0), s4.FS.unlink(m4);
        } catch {
          o3 = new Uint8Array(0);
        }
        break;
      }
      default:
        throw new Error(`Unknown data transfer container: ${_3}`);
    }
    return o3;
  }
  async execProtocolRaw(r2, { syncToFs: a2 = true, dataTransferContainer: o3 } = {}) {
    let s4 = this.execProtocolRawSync(r2, { dataTransferContainer: o3 });
    return a2 && await this.syncToFs(), s4;
  }
  async execProtocol(r2, { syncToFs: a2 = true, throwOnError: o3 = true, onNotice: s4 } = {}) {
    let l4 = await this.execProtocolRaw(r2, { syncToFs: a2 }), _3 = [];
    return h(this, le2).parse(l4, (n3) => {
      if (n3 instanceof E) {
        if (x(this, le2, new ye), o3)
          throw n3;
      } else if (n3 instanceof ne)
        this.debug > 0 && console.warn(n3), s4 && s4(n3);
      else if (n3 instanceof ee)
        switch (n3.text) {
          case "BEGIN":
            x(this, Q2, true);
            break;
          case "COMMIT":
          case "ROLLBACK":
            x(this, Q2, false);
            break;
        }
      else if (n3 instanceof X) {
        let m4 = h(this, A2).get(n3.channel);
        m4 && m4.forEach((p3) => {
          queueMicrotask(() => p3(n3.payload));
        }), h(this, Y2).forEach((p3) => {
          queueMicrotask(() => p3(n3.channel, n3.payload));
        });
      }
      _3.push(n3);
    }), { messages: _3, data: l4 };
  }
  isInTransaction() {
    return h(this, Q2);
  }
  async syncToFs() {
    if (h(this, Z2))
      return;
    x(this, Z2, true);
    let r2 = async () => {
      await h(this, de2).runExclusive(async () => {
        x(this, Z2, false), await this.fs.syncToFs(h(this, $3));
      });
    };
    h(this, $3) ? r2() : await r2();
  }
  async listen(r2, a2) {
    return this._runExclusiveListen(() => T(this, T3, ze2).call(this, r2, a2));
  }
  async unlisten(r2, a2) {
    return this._runExclusiveListen(() => T(this, T3, Ne2).call(this, r2, a2));
  }
  onNotification(r2) {
    return h(this, Y2).add(r2), () => {
      h(this, Y2).delete(r2);
    };
  }
  offNotification(r2) {
    h(this, Y2).delete(r2);
  }
  async dumpDataDir(r2) {
    await this._checkReady();
    let a2 = this.dataDir?.split("/").pop() ?? "pgdata";
    return this.fs.dumpTar(a2, r2);
  }
  _runExclusiveQuery(r2) {
    return h(this, ie).runExclusive(r2);
  }
  _runExclusiveTransaction(r2) {
    return h(this, me2).runExclusive(r2);
  }
  async clone() {
    let r2 = await this.dumpDataDir("none");
    return ue3.create({ loadDataDir: r2 });
  }
  _runExclusiveListen(r2) {
    return h(this, pe2).runExclusive(r2);
  }
};
J2 = new WeakMap, j3 = new WeakMap, V = new WeakMap, Q2 = new WeakMap, $3 = new WeakMap, ie = new WeakMap, me2 = new WeakMap, pe2 = new WeakMap, de2 = new WeakMap, Z2 = new WeakMap, ae = new WeakMap, oe = new WeakMap, se2 = new WeakMap, le2 = new WeakMap, K2 = new WeakMap, H4 = new WeakMap, A2 = new WeakMap, Y2 = new WeakMap, T3 = new WeakSet, De2 = async function(r2) {
  if (r2.fs)
    this.fs = r2.fs;
  else {
    let { dataDir: d3, fsType: g5 } = Ae2(r2.dataDir);
    this.fs = await Te2(d3, g5);
  }
  let a2 = {}, o3 = [], s4 = [`PGDATA=${C2}`, `PREFIX=${Vr}`, `PGUSER=${r2.username ?? "postgres"}`, `PGDATABASE=${r2.database ?? "template1"}`, "MODE=REACT", "REPL=N", ...this.debug ? ["-d", this.debug.toString()] : []];
  r2.wasmModule || Rr();
  let l4 = r2.fsBundle ? r2.fsBundle.arrayBuffer() : Er(), _3;
  l4.then((d3) => {
    _3 = d3;
  });
  let n3 = { WASM_PREFIX: Vr, arguments: s4, INITIAL_MEMORY: r2.initialMemory, noExitRuntime: true, ...this.debug > 0 ? { print: console.info, printErr: console.error } : { print: () => {}, printErr: () => {} }, instantiateWasm: (d3, g5) => (Tr(d3, r2.wasmModule).then(({ instance: u3, module: f3 }) => {
    g5(u3, f3);
  }), {}), getPreloadedPackage: (d3, g5) => {
    if (d3 === "pglite.data") {
      if (_3.byteLength !== g5)
        throw new Error(`Invalid FS bundle size: ${_3.byteLength} !== ${g5}`);
      return _3;
    }
    throw new Error(`Unknown package: ${d3}`);
  }, preRun: [(d3) => {
    let g5 = d3.FS.makedev(64, 0), u3 = { open: (f3) => {}, close: (f3) => {}, read: (f3, c2, w4, h3, v3) => {
      let x5 = h(this, K2);
      if (!x5)
        throw new Error("No /dev/blob File or Blob provided to read from");
      let y3 = new Uint8Array(x5);
      if (v3 >= y3.length)
        return 0;
      let M3 = Math.min(y3.length - v3, h3);
      for (let E3 = 0;E3 < M3; E3++)
        c2[w4 + E3] = y3[v3 + E3];
      return M3;
    }, write: (f3, c2, w4, h3, v3) => (h(this, H4) ?? x(this, H4, []), h(this, H4).push(c2.slice(w4, w4 + h3)), h3), llseek: (f3, c2, w4) => {
      let h3 = h(this, K2);
      if (!h3)
        throw new Error("No /dev/blob File or Blob provided to llseek");
      let v3 = c2;
      if (w4 === 1 ? v3 += f3.position : w4 === 2 && (v3 = new Uint8Array(h3).length), v3 < 0)
        throw new d3.FS.ErrnoError(28);
      return v3;
    } };
    d3.FS.registerDevice(g5, u3), d3.FS.mkdev("/dev/blob", g5);
  }] }, { emscriptenOpts: m4 } = await this.fs.init(this, n3);
  n3 = m4;
  for (let [d3, g5] of Object.entries(h(this, oe)))
    if (g5 instanceof URL)
      a2[d3] = xe2(g5);
    else {
      let u3 = await g5.setup(this, n3);
      if (u3.emscriptenOpts && (n3 = u3.emscriptenOpts), u3.namespaceObj) {
        let f3 = this;
        f3[d3] = u3.namespaceObj;
      }
      u3.bundlePath && (a2[d3] = xe2(u3.bundlePath)), u3.init && o3.push(u3.init), u3.close && h(this, se2).push(u3.close);
    }
  if (n3.pg_extensions = a2, await l4, this.mod = await Re2(n3), await this.fs.initialSyncFs(), r2.loadDataDir) {
    if (this.mod.FS.analyzePath(C2 + "/PG_VERSION").exists)
      throw new Error("Database already exists, cannot load from tarball");
    T(this, T3, re2).call(this, "pglite: loading data from tarball"), await ce2(this.mod.FS, r2.loadDataDir, C2);
  }
  this.mod.FS.analyzePath(C2 + "/PG_VERSION").exists ? T(this, T3, re2).call(this, "pglite: found DB, resuming") : T(this, T3, re2).call(this, "pglite: no db"), await ke2(this.mod, (...d3) => T(this, T3, re2).call(this, ...d3));
  let p3 = this.mod._pgl_initdb();
  if (!p3)
    throw new Error("INITDB failed to return value");
  if (p3 & 1)
    throw new Error("INITDB: failed to execute");
  if (p3 & 2) {
    let d3 = r2.username ?? "postgres", g5 = r2.database ?? "template1";
    if (p3 & 4) {
      if (!(p3 & 12))
        throw new Error(`INITDB: Invalid db ${g5}/user ${d3} combination`);
    } else if (g5 !== "template1" && d3 !== "postgres")
      throw new Error(`INITDB: created a new datadir ${C2}, but an alternative db ${g5}/user ${d3} was requested`);
  }
  this.mod._pgl_backend(), await this.syncToFs(), x(this, J2, true), await this.exec("SET search_path TO public;"), await this._initArrayTypes();
  for (let d3 of o3)
    await d3();
}, re2 = function(...r2) {
  this.debug > 0 && console.log(...r2);
}, ze2 = async function(r2, a2) {
  let o3 = Nr(r2);
  h(this, A2).has(o3) || h(this, A2).set(o3, new Set), h(this, A2).get(o3).add(a2);
  try {
    await this.exec(`LISTEN ${r2}`);
  } catch (s4) {
    throw h(this, A2).get(o3).delete(a2), h(this, A2).get(o3)?.size === 0 && h(this, A2).delete(o3), s4;
  }
  return async () => {
    await this.unlisten(o3, a2);
  };
}, Ne2 = async function(r2, a2) {
  let o3 = Nr(r2), s4 = async () => {
    await this.exec(`UNLISTEN ${r2}`), h(this, A2).get(o3)?.size === 0 && h(this, A2).delete(o3);
  };
  a2 ? (h(this, A2).get(o3)?.delete(a2), h(this, A2).get(o3)?.size === 0 && await s4()) : await s4();
};
var qe2 = ue2;
u();

// node_modules/@electric-sql/pglite/dist/worker/index.js
init_chunk_BTBUZ646();
u();
var W3;
var C4;
var T4;
var M3;
var _3;
var m4;
var L5;
var x5;
var k3;
var B;
var A3;
var O3;
var E3;
var v3;
var G3;
var P4;
var b4;
var I2;
var $4;
var c2;
var K3;
var D4;
var w4;
var J3;
W3 = new WeakMap, C4 = new WeakMap, T4 = new WeakMap, M3 = new WeakMap, _3 = new WeakMap, m4 = new WeakMap, L5 = new WeakMap, x5 = new WeakMap, k3 = new WeakMap, B = new WeakMap, A3 = new WeakMap, O3 = new WeakMap, E3 = new WeakMap, v3 = new WeakMap, G3 = new WeakMap, P4 = new WeakMap, b4 = new WeakMap, I2 = new WeakMap, $4 = new WeakMap, c2 = new WeakSet, K3 = async function(e = {}) {
  for (let [o3, h3] of Object.entries(h(this, I2))) {
    if (h3 instanceof URL)
      throw new Error("URL extensions are not supported on the client side of a worker");
    {
      let l4 = await h3.setup(this, {}, true);
      if (l4.emscriptenOpts && console.warn(`PGlite extension ${o3} returned emscriptenOpts, these are not supported on the client side of a worker`), l4.namespaceObj) {
        let R4 = this;
        R4[o3] = l4.namespaceObj;
      }
      l4.bundlePath && console.warn(`PGlite extension ${o3} returned bundlePath, this is not supported on the client side of a worker`), l4.init && await l4.init(), l4.close && h(this, $4).push(l4.close);
    }
  }
  await h(this, A3);
  let { extensions: r2, ...n3 } = e;
  h(this, k3).postMessage({ type: "init", options: n3 }), await h(this, O3);
  let s4 = `pglite-tab-close:${h(this, L5)}`;
  x(this, G3, await q2(s4));
  let p3 = `pglite-broadcast:${h(this, B)}`;
  x(this, E3, new BroadcastChannel(p3));
  let a2 = `pglite-tab:${h(this, L5)}`;
  x(this, v3, new BroadcastChannel(a2)), h(this, E3).addEventListener("message", async (o3) => {
    o3.data.type === "leader-here" ? (x(this, x5, false), h(this, m4).dispatchEvent(new Event("leader-change")), T(this, c2, D4).call(this)) : o3.data.type === "notify" && T(this, c2, J3).call(this, o3.data.channel, o3.data.payload);
  }), h(this, v3).addEventListener("message", async (o3) => {
    o3.data.type === "connected" && (x(this, x5, true), h(this, m4).dispatchEvent(new Event("connected")), x(this, C4, await T(this, c2, w4).call(this, "getDebugLevel")), x(this, T4, true));
  }), h(this, k3).addEventListener("message", async (o3) => {
    o3.data.type === "leader-now" && (x(this, _3, true), h(this, m4).dispatchEvent(new Event("leader-change")));
  }), T(this, c2, D4).call(this), this._initArrayTypes();
}, D4 = async function() {
  h(this, x5) || (h(this, E3).postMessage({ type: "tab-here", id: h(this, L5) }), setTimeout(() => T(this, c2, D4).call(this), 16));
}, w4 = async function(e, ...r2) {
  let n3 = Cr(), s4 = { type: "rpc-call", callId: n3, method: e, args: r2 };
  return h(this, v3).postMessage(s4), await new Promise((p3, a2) => {
    let o3 = (R4) => {
      if (R4.data.callId !== n3)
        return;
      l4();
      let f3 = R4.data;
      if (f3.type === "rpc-return")
        p3(f3.result);
      else if (f3.type === "rpc-error") {
        let S3 = new Error(f3.error.message);
        Object.assign(S3, f3.error), a2(S3);
      } else
        a2(new Error("Invalid message"));
    }, h3 = () => {
      l4(), a2(new U3);
    }, l4 = () => {
      h(this, v3).removeEventListener("message", o3), h(this, m4).removeEventListener("leader-change", h3);
    };
    h(this, m4).addEventListener("leader-change", h3), h(this, v3).addEventListener("message", o3);
  });
}, J3 = function(e, r2) {
  let n3 = h(this, P4).get(e);
  if (n3)
    for (let s4 of n3)
      queueMicrotask(() => s4(r2));
  for (let s4 of h(this, b4))
    queueMicrotask(() => s4(e, r2));
};
async function se3({ init: g5 }) {
  postMessage({ type: "here" });
  let i4 = await new Promise((h3) => {
    addEventListener("message", (l4) => {
      l4.data.type === "init" && h3(l4.data.options);
    }, { once: true });
  }), e = i4.id ?? `${import.meta.url}:${i4.dataDir ?? ""}`;
  postMessage({ type: "ready", id: e });
  let r2 = `pglite-election-lock:${e}`, n3 = `pglite-broadcast:${e}`, s4 = new BroadcastChannel(n3), p3 = new Set;
  await q2(r2);
  let a2 = g5(i4);
  s4.onmessage = async (h3) => {
    let l4 = h3.data;
    switch (l4.type) {
      case "tab-here":
        V2(l4.id, await a2, p3);
        break;
    }
  }, s4.postMessage({ type: "leader-here", id: e }), postMessage({ type: "leader-now" }), (await a2).onNotification((h3, l4) => {
    s4.postMessage({ type: "notify", channel: h3, payload: l4 });
  });
}
function V2(g5, i4, e) {
  if (e.has(g5))
    return;
  e.add(g5);
  let r2 = `pglite-tab:${g5}`, n3 = `pglite-tab-close:${g5}`, s4 = new BroadcastChannel(r2);
  navigator.locks.request(n3, () => new Promise((a2) => {
    s4.close(), e.delete(g5), a2();
  }));
  let p3 = X3(g5, i4);
  s4.addEventListener("message", async (a2) => {
    let o3 = a2.data;
    switch (o3.type) {
      case "rpc-call": {
        await i4.waitReady;
        let { callId: h3, method: l4, args: R4 } = o3;
        try {
          let f3 = await p3[l4](...R4);
          s4.postMessage({ type: "rpc-return", callId: h3, result: f3 });
        } catch (f3) {
          console.error(f3), s4.postMessage({ type: "rpc-error", callId: h3, error: { message: f3.message } });
        }
        break;
      }
    }
  }), s4.postMessage({ type: "connected" });
}
function X3(g5, i4) {
  let e = null, r2 = null, n3 = `pglite-tab-close:${g5}`;
  return q2(n3).then(() => {
    r2 && i4.exec("ROLLBACK"), e?.(), r2?.();
  }), { async getDebugLevel() {
    return i4.debug;
  }, async close() {
    await i4.close();
  }, async execProtocol(s4) {
    let { messages: p3, data: a2 } = await i4.execProtocol(s4);
    if (a2.byteLength !== a2.buffer.byteLength) {
      let o3 = new ArrayBuffer(a2.byteLength), h3 = new Uint8Array(o3);
      return h3.set(a2), { messages: p3, data: h3 };
    } else
      return { messages: p3, data: a2 };
  }, async execProtocolRaw(s4, p3 = {}) {
    let a2 = await i4.execProtocolRaw(s4, p3);
    if (a2.byteLength !== a2.buffer.byteLength) {
      let o3 = new ArrayBuffer(a2.byteLength), h3 = new Uint8Array(o3);
      return h3.set(a2), h3;
    } else
      return a2;
  }, async dumpDataDir() {
    return await i4.dumpDataDir();
  }, async syncToFs() {
    return await i4.syncToFs();
  }, async _handleBlob(s4) {
    return await i4._handleBlob(s4);
  }, async _getWrittenBlob() {
    return await i4._getWrittenBlob();
  }, async _cleanupBlob() {
    return await i4._cleanupBlob();
  }, async _checkReady() {
    return await i4._checkReady();
  }, async _acquireQueryLock() {
    return new Promise((s4) => {
      i4._runExclusiveQuery(() => new Promise((p3) => {
        e = p3, s4();
      }));
    });
  }, async _releaseQueryLock() {
    e?.(), e = null;
  }, async _acquireTransactionLock() {
    return new Promise((s4) => {
      i4._runExclusiveTransaction(() => new Promise((p3) => {
        r2 = p3, s4();
      }));
    });
  }, async _releaseTransactionLock() {
    r2?.(), r2 = null;
  } };
}
var U3 = class extends Error {
  constructor() {
    super("Leader changed, pending operation in indeterminate state");
  }
};
async function q2(g5) {
  let i4;
  return await new Promise((e) => {
    navigator.locks.request(g5, () => new Promise((r2) => {
      i4 = r2, e();
    }));
  }), i4;
}

// src/app/~workers/db.worker.ts
se3({
  async init() {
    const pg = new qe2({
      fs: new ee2("converse-ai"),
      relaxedDurability: true
    });
    return pg;
  }
});
